/*
@license
The following license applies to all parts of this software except as
documented below.

    Copyright (c) 2019, Twilio, inc.
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are
    met:

      1. Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.

      2. Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in
         the documentation and/or other materials provided with the
         distribution.

      3. Neither the name of Twilio nor the names of its contributors may
         be used to endorse or promote products derived from this software
         without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This software includes javascript-state-machine under the following license.

    Copyright (c) 2012, 2013, 2014, 2015, Jake Gordon and contributors

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

This software includes loglevel under the following license.

    Copyright (c) 2013 Tim Perry

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without
    restriction, including without limitation the rights to use,
    copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following
    conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.

This software includes q under the following license.

    Copyright 2009â€“2014 Kristopher Michael Kowal. All rights reserved.
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to
    deal in the Software without restriction, including without limitation the
    rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
    sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
    IN THE SOFTWARE.

This software includes platform.js under the following license.

    Copyright 2014 Benjamin Tan <https://d10.github.io/>
    Copyright 2011-2015 John-David Dalton <http://allyoucanleet.com/>

    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var loglevelLog = require('loglevel');
var iso8601Duration = require('iso8601-duration');
var JsonDiff = require('rfc6902');
var declarativeTypeValidator = require('@twilio/declarative-type-validator');
var replayEventEmitter = require('@twilio/replay-event-emitter');
var operationRetrier = require('@twilio/operation-retrier');
var twilsock = require('twilsock');
var notifications = require('@twilio/notifications');
var twilioSync = require('twilio-sync');
var mcsClient = require('@twilio/mcs-client');
var uuid = require('uuid');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () {
                        return e[k];
                    }
                });
            }
        });
    }
    n['default'] = e;
    return Object.freeze(n);
}

var loglevelLog__namespace = /*#__PURE__*/_interopNamespace(loglevelLog);
var JsonDiff__namespace = /*#__PURE__*/_interopNamespace(JsonDiff);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function prepareLine(prefix, args) {
    return [`${new Date().toISOString()} Conversations ${prefix}:`].concat(Array.from(args));
}
const log$9 = loglevelLog__namespace.getLogger('twilio-conversations'); // twilio-conversations is used by Flex SDK. Please DO NOT change
class Logger {
    constructor(prefix) {
        this.prefix = '';
        this.prefix = prefix !== null && prefix !== undefined && prefix.length > 0
            ? prefix + ' '
            : '';
    }
    static scope(prefix) {
        return new Logger(prefix);
    }
    setLevel(level) {
        log$9.setLevel(level);
    }
    static setLevel(level) {
        log$9.setLevel(level);
    }
    trace(...args) { log$9.trace.apply(null, prepareLine(this.prefix + 'T', args)); }
    debug(...args) { log$9.debug.apply(null, prepareLine(this.prefix + 'D', args)); }
    info(...args) { log$9.info.apply(null, prepareLine(this.prefix + 'I', args)); }
    warn(...args) { log$9.warn.apply(null, prepareLine(this.prefix + 'W', args)); }
    error(...args) { log$9.error.apply(null, prepareLine(this.prefix + 'E', args)); }
    static trace(...args) { log$9.trace.apply(null, prepareLine('T', args)); }
    static debug(...args) { log$9.debug.apply(null, prepareLine('D', args)); }
    static info(...args) { log$9.info.apply(null, prepareLine('I', args)); }
    static warn(...args) { log$9.warn.apply(null, prepareLine('W', args)); }
    static error(...args) { log$9.error.apply(null, prepareLine('E', args)); }
}

const TYPING_TIMEOUT = 5;
const HTTP_CACHE_LIFETIME = 'PT5S';
const CONSUMPTION_HORIZON_SENDING_INTERVAL = 'PT5S';
const USER_INFOS_TO_SUBSCRIBE = 100;
const MINIMUM_RETRY_DELAY = 1000;
const MAXIMUM_RETRY_DELAY = 4000;
const MAXIMUM_ATTEMPTS_COUNT = 3;
const RETRY_WHEN_THROTTLED = true;
class Configuration {
    constructor(options = {}, configurationResponse, logger) {
        var _a, _b, _c, _d, _e, _f;
        this.typingIndicatorTimeoutDefault = TYPING_TIMEOUT * 1000;
        const constructorOptions = options.Chat || options.IPMessaging || options || {};
        this.productId = constructorOptions.productId;
        this.links = {
            myConversations: configurationResponse.links.my_conversations,
            conversations: configurationResponse.links.conversations,
            users: configurationResponse.links.users,
            currentUser: configurationResponse.links.current_user,
            typing: configurationResponse.links.typing,
            mediaService: configurationResponse.links.media_service,
            mediaSetService: configurationResponse.links.media_set_service,
            messagesReceipts: configurationResponse.links.messages_receipts
        };
        this.limits = {
            mediaAttachmentsCountLimit: configurationResponse.options.media_attachments_count_limit,
            mediaAttachmentSizeLimitInMb: configurationResponse.options.media_attachment_size_limit_in_mb,
            mediaAttachmentsTotalSizeLimitInMb: configurationResponse.options.media_attachments_total_size_limit_in_mb,
            emailHistoriesAllowedMimeTypes: configurationResponse.options.email_histories_allowed_mime_types,
            emailBodiesAllowedMimeTypes: configurationResponse.options.email_bodies_allowed_mime_types
        };
        this.typingIndicatorTimeoutOverride = constructorOptions.typingIndicatorTimeoutOverride;
        this.backoffConfiguration = Object.assign({ min: MINIMUM_RETRY_DELAY, max: MAXIMUM_RETRY_DELAY, maxAttemptsCount: MAXIMUM_ATTEMPTS_COUNT }, constructorOptions.backoffConfigOverride);
        this.retryWhenThrottled = constructorOptions.retryWhenThrottledOverride !== undefined
            ? constructorOptions.retryWhenThrottledOverride
            : RETRY_WHEN_THROTTLED;
        this.userInfosToSubscribe = (_b = (_a = constructorOptions.userInfosToSubscribeOverride) !== null && _a !== void 0 ? _a : configurationResponse.options.user_infos_to_subscribe) !== null && _b !== void 0 ? _b : USER_INFOS_TO_SUBSCRIBE;
        this.reachabilityEnabled = configurationResponse.options.reachability_enabled;
        this.userIdentity = configurationResponse.identity;
        this.userInfo = configurationResponse.sync_objects.my_user_info;
        this.myConversations = configurationResponse.sync_objects.my_conversations;
        const httpCacheInterval = (_d = (_c = constructorOptions.httpCacheIntervalOverride) !== null && _c !== void 0 ? _c : configurationResponse.options.http_cache_interval) !== null && _d !== void 0 ? _d : HTTP_CACHE_LIFETIME;
        try {
            this.httpCacheInterval = iso8601Duration.toSeconds(iso8601Duration.parse(httpCacheInterval));
        }
        catch (_g) {
            logger.error(`Failed to parse http cache interval ${httpCacheInterval}, using default value ${HTTP_CACHE_LIFETIME}`);
            this.httpCacheInterval = iso8601Duration.toSeconds(iso8601Duration.parse(HTTP_CACHE_LIFETIME));
        }
        const consumptionReportInterval = (_f = (_e = constructorOptions.consumptionReportIntervalOverride) !== null && _e !== void 0 ? _e : configurationResponse.options.consumption_report_interval) !== null && _f !== void 0 ? _f : CONSUMPTION_HORIZON_SENDING_INTERVAL;
        try {
            this.consumptionReportInterval = iso8601Duration.toSeconds(iso8601Duration.parse(consumptionReportInterval));
        }
        catch (_h) {
            logger.error(`Failed to parse consumption report interval ${consumptionReportInterval}, using default value ${CONSUMPTION_HORIZON_SENDING_INTERVAL}`);
            this.consumptionReportInterval = iso8601Duration.toSeconds(iso8601Duration.parse(CONSUMPTION_HORIZON_SENDING_INTERVAL));
        }
    }
}

/**
 * Checks if objects are equal
 */
function isDeepEqual(o1, o2) {
    return JsonDiff__namespace.createPatch(o1, o2).length === 0;
}
/**
 * Deep-clone an object. Note that this does not work on object containing
 * functions.
 * @param {object} obj - the object to deep-clone
 * @returns {object}
 */
function deepClone(obj) {
    return JSON.parse(JSON.stringify(obj));
}
function parseToNumber(value) {
    if (typeof value !== 'undefined' && !isNaN(Number(value))) {
        return Number(value);
    }
    return null;
}
// timeString cannot be typed `string` because in member.ts
// call to parseTime(data.lastReadTimestamp) uses number not a string for timestamp.
function parseTime$1(timeString) {
    try {
        return new Date(timeString);
    }
    catch (e) {
        return null;
    }
}
function parseAttributes(rawAttributes, warningMessage, log) {
    let attributes = {};
    if (rawAttributes) {
        try {
            attributes = JSON.parse(rawAttributes);
        }
        catch (e) {
            log.warn(warningMessage, e);
        }
    }
    return attributes;
}
/**
 * Construct URI with query parameters
 */
class UriBuilder {
    constructor(base) {
        this.base = base.replace(/\/$/, '');
        this.args = [];
        this.paths = [];
    }
    arg(name, value) {
        if (typeof value !== 'undefined') {
            this.args.push(encodeURIComponent(name) + '=' + encodeURIComponent(value));
        }
        return this;
    }
    path(name) {
        this.paths.push(encodeURIComponent(name));
        return this;
    }
    build() {
        let result = this.base;
        if (this.paths.length) {
            result += '/' + this.paths.join('/');
        }
        if (this.args.length) {
            result += '?' + this.args.join('&');
        }
        return result;
    }
}

const log$8 = Logger.scope('User');
/**
 * Extended user information.
 * Note that `isOnline` and `isNotifiable` properties are eligible
 * for use only if the reachability function is enabled.
 * You may check if it is enabled by reading the value of {@link Client.reachabilityEnabled}.
 */
class User extends replayEventEmitter.ReplayEventEmitter {
    /**
     * @internal
     */
    constructor(identity, entityName, configuration, services) {
        super();
        this.promiseToFetch = null;
        /**
         * Fired when the properties or the reachability status of the message has been updated.
         *
         * Parameters:
         * 1. object `data` - info object provided with the event. It has the following properties:
         *     * {@link User} `user` - the user in question
         *     * {@link UserUpdateReason}[] `updateReasons` - array of reasons for the update
         * @event
         */
        this.updated = 'updated';
        /**
         * Fired when the client has subscribed to the user.
         *
         * Parameters:
         * 1. {@link User} `user` - the user in question
         * @event
         */
        this.userSubscribed = 'userSubscribed';
        /**
         * Fired when the client has unsubscribed from the user.
         *
         * Parameters:
         * 1. {@link User} `user` - the user in question
         * @event
         */
        this.userUnsubscribed = 'userUnsubscribed';
        this.services = services;
        this.subscribed = 'initializing';
        this.setMaxListeners(0);
        this.state = {
            identity,
            entityName,
            friendlyName: null,
            attributes: {},
            online: null,
            notifiable: null
        };
        this._initializationPromise = new Promise((resolve) => {
            this._resolveInitializationPromise = resolve;
        });
        if (configuration !== null) {
            this._resolveInitialization(configuration, identity, entityName, false);
        }
    }
    /**
     * User identity.
     */
    get identity() { return this.state.identity; }
    set identity(identity) { this.state.identity = identity; }
    set entityName(name) { this.state.entityName = name; }
    /**
     * Custom attributes of the user.
     */
    get attributes() { return this.state.attributes; }
    /**
     * Friendly name of the user, null if not set.
     */
    get friendlyName() { return this.state.friendlyName; }
    /**
     * Status of the real-time conversation connection of the user.
     */
    get isOnline() { return this.state.online; }
    /**
     * User push notification registration status.
     */
    get isNotifiable() { return this.state.notifiable; }
    /**
     * True if this user is receiving real-time status updates.
     */
    get isSubscribed() { return this.subscribed == 'subscribed'; }
    // Handles service updates
    async _update(key, value) {
        await this._initializationPromise;
        let updateReasons = [];
        log$8.debug('User for', this.state.identity, 'updated:', key, value);
        switch (key) {
            case 'friendlyName':
                if (this.state.friendlyName !== value.value) {
                    updateReasons.push('friendlyName');
                    this.state.friendlyName = value.value;
                }
                break;
            case 'attributes':
                const updateAttributes = parseAttributes(value.value, `Retrieved malformed attributes from the server for user: ${this.state.identity}`, log$8);
                if (!isDeepEqual(this.state.attributes, updateAttributes)) {
                    this.state.attributes = updateAttributes;
                    updateReasons.push('attributes');
                }
                break;
            case 'reachability':
                if (this.state.online !== value.online) {
                    this.state.online = value.online;
                    updateReasons.push('reachabilityOnline');
                }
                if (this.state.notifiable !== value.notifiable) {
                    this.state.notifiable = value.notifiable;
                    updateReasons.push('reachabilityNotifiable');
                }
                break;
            default:
                return;
        }
        if (updateReasons.length > 0) {
            this.emit('updated', { user: this, updateReasons: updateReasons });
        }
    }
    // Fetch reachability info
    async _updateReachabilityInfo(map, update) {
        await this._initializationPromise;
        if (!this.configuration.reachabilityEnabled) {
            return Promise.resolve();
        }
        return map.get('reachability')
            .then(update)
            .catch(err => { log$8.warn('Failed to get reachability info for ', this.state.identity, err); });
    }
    // Fetch user
    async _fetch() {
        await this._initializationPromise;
        if (!this.state.entityName) {
            return this;
        }
        this.promiseToFetch = this.services.syncClient.map({
            id: this.state.entityName,
            mode: 'open_existing',
            includeItems: true
        })
            .then(map => {
            this.entity = map;
            map.on('itemUpdated', args => {
                log$8.debug(this.state.entityName + ' (' + this.state.identity + ') itemUpdated: ' + args.item.key);
                return this._update(args.item.key, args.item.data);
            });
            return Promise.all([
                map.get('friendlyName')
                    .then(item => this._update(item.key, item.data)),
                map.get('attributes')
                    .then(item => this._update(item.key, item.data)),
                this._updateReachabilityInfo(map, item => this._update(item.key, item.data))
            ]);
        })
            .then(() => {
            log$8.debug('Fetched for', this.identity);
            this.subscribed = 'subscribed';
            this.emit('userSubscribed', this);
            return this;
        })
            .catch(err => {
            this.promiseToFetch = null;
            throw err;
        });
        return this.promiseToFetch;
    }
    async _ensureFetched() {
        await this._initializationPromise;
        return this.promiseToFetch || this._fetch();
    }
    /**
     * Edit user attributes.
     * @param attributes New attributes.
     */
    async updateAttributes(attributes) {
        await this._initializationPromise;
        if (this.subscribed == 'unsubscribed') {
            throw new Error('Can\'t modify unsubscribed object');
        }
        await this.services.commandExecutor.mutateResource('post', this.links.self, {
            attributes: JSON.stringify(attributes)
        });
        return this;
    }
    /**
     * Update the friendly name of the user.
     * @param friendlyName New friendly name.
     */
    async updateFriendlyName(friendlyName) {
        await this._initializationPromise;
        if (this.subscribed == 'unsubscribed') {
            throw new Error('Can\'t modify unsubscribed object');
        }
        await this.services.commandExecutor.mutateResource('post', this.links.self, {
            friendly_name: friendlyName
        });
        return this;
    }
    /**
     * Remove the user from the subscription list.
     * @return A promise of completion.
     */
    async unsubscribe() {
        await this._initializationPromise;
        if (this.promiseToFetch) {
            await this.promiseToFetch;
            this.entity.close();
            this.promiseToFetch = null;
            this.subscribed = 'unsubscribed';
            this.emit('userUnsubscribed', this);
        }
    }
    _resolveInitialization(configuration, identity, entityName, emitUpdated) {
        this.configuration = configuration;
        this.identity = identity;
        this.entityName = entityName;
        this.links = {
            self: `${this.configuration.links.users}/${this.identity}`
        };
        this._resolveInitializationPromise();
        if (emitUpdated) {
            this.emit('updated', {
                user: this,
                updateReasons: [
                    'friendlyName',
                    'attributes',
                    'reachabilityOnline',
                    'reachabilityNotifiable'
                ]
            });
        }
    }
}
__decorate([
    declarativeTypeValidator.validateTypesAsync(['string', 'number', 'boolean', 'object', declarativeTypeValidator.literal(null)]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], User.prototype, "updateAttributes", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(['string']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], User.prototype, "updateFriendlyName", null);

class Network {
    constructor(configuration, services) {
        this.configuration = configuration;
        this.services = services;
        this.cache = new Map();
        this.cacheLifetime = this.configuration.httpCacheInterval * 100;
        this.cleanupCache();
    }
    isExpired(timestamp) {
        return !this.cacheLifetime || (Date.now() - timestamp) > this.cacheLifetime;
    }
    cleanupCache() {
        for (let [k, v] of this.cache) {
            if (this.isExpired(v.timestamp)) {
                this.cache.delete(k);
            }
        }
        if (this.cache.size === 0) {
            clearInterval(this.timer);
        }
    }
    pokeTimer() {
        this.timer = this.timer || setInterval(() => this.cleanupCache(), this.cacheLifetime * 2);
    }
    executeWithRetry(request, retryWhenThrottled = false) {
        return new Promise((resolve, reject) => {
            let codesToRetryOn = [502, 503, 504];
            if (retryWhenThrottled) {
                codesToRetryOn.push(429);
            }
            let retrier = new operationRetrier.Retrier(this.configuration.backoffConfiguration);
            retrier.on('attempt', () => {
                request()
                    .then(result => retrier.succeeded(result))
                    .catch(err => {
                    if (codesToRetryOn.indexOf(err.status) > -1) {
                        retrier.failed(err);
                    }
                    else if (err.message === 'Twilsock disconnected') {
                        // Ugly hack. We must make a proper exceptions for twilsock
                        retrier.failed(err);
                    }
                    else {
                        // Fatal error
                        retrier.removeAllListeners();
                        retrier.cancel();
                        reject(err);
                    }
                });
            });
            retrier.on('succeeded', result => { resolve(result); });
            retrier.on('cancelled', err => reject(err));
            retrier.on('failed', err => reject(err));
            retrier.start();
        });
    }
    async get(url) {
        let cacheEntry = this.cache.get(url);
        if (cacheEntry && !this.isExpired(cacheEntry.timestamp)) {
            return cacheEntry.response;
        }
        const headers = {};
        let response = await this.executeWithRetry(() => this.services.transport.get(url, headers, this.configuration.productId), this.configuration.retryWhenThrottled);
        this.cache.set(url, { response, timestamp: Date.now() });
        this.pokeTimer();
        return response;
    }
}

class NotificationTypes {
}
NotificationTypes.TYPING_INDICATOR = 'twilio.ipmsg.typing_indicator';
NotificationTypes.NEW_MESSAGE = 'twilio.conversations.new_message';
NotificationTypes.ADDED_TO_CONVERSATION = 'twilio.conversations.added_to_conversation';
// static readonly INVITED_TO_CHANNEL = 'twilio.channel.invited_to_channel';
NotificationTypes.REMOVED_FROM_CONVERSATION = 'twilio.conversations.removed_from_conversation';
NotificationTypes.CONSUMPTION_UPDATE = 'twilio.channel.consumption_update';

const log$7 = Logger.scope('Participant');
/**
 * A participant represents a remote client in a conversation.
 */
class Participant extends replayEventEmitter.ReplayEventEmitter {
    /**
     * @internal
     */
    constructor(data, sid, conversation, links, services) {
        super();
        this.conversation = conversation;
        this.links = links;
        this.services = services;
        this.state = {
            attributes: parseAttributes(data.attributes, 'Retrieved malformed attributes from the server for participant: ' + sid, log$7),
            dateCreated: data.dateCreated ? parseTime$1(data.dateCreated) : null,
            dateUpdated: data.dateCreated ? parseTime$1(data.dateUpdated) : null,
            sid: sid,
            typingTimeout: null,
            isTyping: false,
            identity: data.identity || null,
            roleSid: data.roleSid || null,
            lastReadMessageIndex: Number.isInteger(data.lastConsumedMessageIndex) ? data.lastConsumedMessageIndex : null,
            lastReadTimestamp: data.lastConsumptionTimestamp ? parseTime$1(data.lastConsumptionTimestamp) : null,
            type: data.type || 'chat',
            userInfo: data.userInfo
        };
        if (!data.identity && !data.type) {
            throw new Error('Received invalid Participant object from server: Missing identity or type of Participant.');
        }
    }
    /**
     * The server-assigned unique identifier for the participant.
     */
    get sid() { return this.state.sid; }
    /**
     * Custom attributes of the participant.
     */
    get attributes() { return this.state.attributes; }
    /**
     * Date this participant was created on.
     */
    get dateCreated() { return this.state.dateCreated; }
    /**
     * Date this participant was last updated on.
     */
    get dateUpdated() { return this.state.dateUpdated; }
    /**
     * Identity of the participant.
     */
    get identity() { return this.state.identity; }
    /**
     * Indicates whether the participant is currently typing.
     */
    get isTyping() { return this.state.isTyping; }
    /**
     * The index of the last read message by the participant.
     * Note that retrieving messages on a client endpoint does not mean that messages are read,
     * please consider reading about the [Read Horizon feature](https://www.twilio.com/docs/api/chat/guides/consumption-horizon)
     * to find out about the proper way to mark messages as read.
     */
    get lastReadMessageIndex() { return this.state.lastReadMessageIndex; }
    /**
     * Date of the most recent read horizon update.
     */
    get lastReadTimestamp() { return this.state.lastReadTimestamp; }
    get roleSid() { return this.state.roleSid; }
    /**
     * Message type of the participant.
     */
    get type() { return this.state.type; }
    /**
     * Internal method used to start or reset the typing indicator timeout (with event emitting).
     * @internal
     */
    _startTyping(timeout) {
        clearTimeout(this.state.typingTimeout);
        this.state.isTyping = true;
        this.emit('typingStarted', this);
        this.conversation.emit('typingStarted', this);
        this.state.typingTimeout = setTimeout(() => this._endTyping(), timeout);
        return this;
    }
    /**
     * Internal method function used to stop the typing indicator timeout (with event emitting).
     * @internal
     */
    _endTyping() {
        if (!this.state.typingTimeout) {
            return;
        }
        this.state.isTyping = false;
        this.emit('typingEnded', this);
        this.conversation.emit('typingEnded', this);
        clearInterval(this.state.typingTimeout);
        this.state.typingTimeout = null;
    }
    /**
     * Internal method function used update local object's property roleSid with a new value.
     * @internal
     */
    _update(data) {
        let updateReasons = [];
        let updateAttributes = parseAttributes(data.attributes, 'Retrieved malformed attributes from the server for participant: ' + this.state.sid, log$7);
        if (data.attributes && !isDeepEqual(this.state.attributes, updateAttributes)) {
            this.state.attributes = updateAttributes;
            updateReasons.push('attributes');
        }
        let updatedDateUpdated = parseTime$1(data.dateUpdated);
        if (data.dateUpdated &&
            updatedDateUpdated.getTime() !== (this.state.dateUpdated && this.state.dateUpdated.getTime())) {
            this.state.dateUpdated = updatedDateUpdated;
            updateReasons.push('dateUpdated');
        }
        let updatedDateCreated = parseTime$1(data.dateCreated);
        if (data.dateCreated &&
            updatedDateCreated.getTime() !== (this.state.dateCreated && this.state.dateCreated.getTime())) {
            this.state.dateCreated = updatedDateCreated;
            updateReasons.push('dateCreated');
        }
        if (data.roleSid && this.state.roleSid !== data.roleSid) {
            this.state.roleSid = data.roleSid;
            updateReasons.push('roleSid');
        }
        if ((Number.isInteger(data.lastConsumedMessageIndex) || data.lastConsumedMessageIndex === null)
            && this.state.lastReadMessageIndex !== data.lastConsumedMessageIndex) {
            this.state.lastReadMessageIndex = data.lastConsumedMessageIndex;
            updateReasons.push('lastReadMessageIndex');
        }
        if (data.lastConsumptionTimestamp) {
            let lastReadTimestamp = new Date(data.lastConsumptionTimestamp);
            if (!this.state.lastReadTimestamp ||
                this.state.lastReadTimestamp.getTime() !== lastReadTimestamp.getTime()) {
                this.state.lastReadTimestamp = lastReadTimestamp;
                updateReasons.push('lastReadTimestamp');
            }
        }
        if (updateReasons.length > 0) {
            this.emit('updated', { participant: this, updateReasons: updateReasons });
        }
        return this;
    }
    /**
     * Get the user for this participant and subscribes to it. Supported only for participants of type `chat`.
     */
    async getUser() {
        if (this.type != 'chat') {
            throw new Error('Getting User is not supported for this Participant type: ' + this.type);
        }
        return this.services.users.getUser(this.state.identity, this.state.userInfo);
    }
    /**
     * Remove the participant from the conversation.
     */
    async remove() {
        return this.conversation.removeParticipant(this);
    }
    /**
     * Update the attributes of the participant.
     * @param attributes New attributes.
     */
    async updateAttributes(attributes) {
        await this.services.commandExecutor.mutateResource('post', this.links.self, {
            attributes: JSON.stringify(attributes)
        });
        return this;
    }
}
/**
 * Fired when the participant has started typing.
 *
 * Parameters:
 * 1. {@link Participant} `participant` - the participant in question
 * @event
 */
Participant.typingStarted = 'typingStarted';
/**
 * Fired when the participant has stopped typing.
 *
 * Parameters:
 * 1. {@link Participant} `participant` - the participant in question
 * @event
 */
Participant.typingEnded = 'typingEnded';
/**
 * Fired when the fields of the participant have been updated.
 *
 * Parameters:
 * 1. object `data` - info object provided with the event. It has the following properties:
 *     * {@link Participant} participant - the participant in question
 *     * {@link ParticipantUpdateReason}[] updateReasons - array of reasons for the update
 * @event
 */
Participant.updated = 'updated';
__decorate([
    declarativeTypeValidator.validateTypesAsync(['string', 'number', 'boolean', 'object', declarativeTypeValidator.literal(null)]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], Participant.prototype, "updateAttributes", null);

const log$6 = Logger.scope('Participants');
/**
 * @classdesc Represents the collection of participants for the conversation
 * @fires Participants#participantJoined
 * @fires Participants#participantLeft
 * @fires Participants#participantUpdated
 */
class Participants extends replayEventEmitter.ReplayEventEmitter {
    constructor(conversation, participants, links, configuration, services) {
        super();
        this.conversation = conversation;
        this.participants = participants;
        this.links = links;
        this.configuration = configuration;
        this.services = services;
    }
    async unsubscribe() {
        if (this.rosterEntityPromise) {
            let entity = await this.rosterEntityPromise;
            entity.close();
            this.rosterEntityPromise = null;
        }
    }
    subscribe(rosterObjectName) {
        return this.rosterEntityPromise = this.rosterEntityPromise
            || this.services.syncClient.map({ id: rosterObjectName, mode: 'open_existing' })
                .then(rosterMap => {
                rosterMap.on('itemAdded', args => {
                    log$6.debug(this.conversation.sid + ' itemAdded: ' + args.item.key);
                    this.upsertParticipant(args.item.key, args.item.data)
                        .then(participant => {
                        this.emit('participantJoined', participant);
                    });
                });
                rosterMap.on('itemRemoved', args => {
                    log$6.debug(this.conversation.sid + ' itemRemoved: ' + args.key);
                    let participantSid = args.key;
                    if (!this.participants.has(participantSid)) {
                        return;
                    }
                    let leftParticipant = this.participants.get(participantSid);
                    this.participants.delete(participantSid);
                    this.emit('participantLeft', leftParticipant);
                });
                rosterMap.on('itemUpdated', args => {
                    log$6.debug(this.conversation.sid + ' itemUpdated: ' + args.item.key);
                    this.upsertParticipant(args.item.key, args.item.data);
                });
                let participantsPromises = [];
                let that = this;
                const rosterMapHandler = function (paginator) {
                    paginator.items.forEach(item => { participantsPromises.push(that.upsertParticipant(item.key, item.data)); });
                    return paginator.hasNextPage ? paginator.nextPage().then(rosterMapHandler) : null;
                };
                return rosterMap
                    .getItems()
                    .then(rosterMapHandler)
                    .then(() => Promise.all(participantsPromises))
                    .then(() => rosterMap);
            })
                .catch(err => {
                this.rosterEntityPromise = null;
                if (this.services.syncClient.connectionState != 'disconnected') {
                    log$6.error('Failed to get roster object for conversation', this.conversation.sid, err);
                }
                log$6.debug('ERROR: Failed to get roster object for conversation', this.conversation.sid, err);
                throw err;
            });
    }
    async upsertParticipant(participantSid, data) {
        let participant = this.participants.get(participantSid);
        if (participant) {
            return participant._update(data);
        }
        const links = {
            self: `${this.links.participants}/${participantSid}`
        };
        participant = new Participant(data, participantSid, this.conversation, links, this.services);
        this.participants.set(participantSid, participant);
        participant.on('updated', (args) => this.emit('participantUpdated', args));
        return participant;
    }
    /**
     * @returns {Promise<Array<Participant>>} returns list of participants {@see Participant}
     */
    getParticipants() {
        return this.rosterEntityPromise.then(() => {
            let participants = [];
            this.participants.forEach(participant => participants.push(participant));
            return participants;
        });
    }
    /**
     * Get participant by SID from conversation
     * @returns {Promise<Participant>}
     */
    async getParticipantBySid(participantSid) {
        return this.rosterEntityPromise.then(() => {
            let participant = this.participants.get(participantSid);
            if (!participant) {
                throw new Error('Participant with SID ' + participantSid + ' was not found');
            }
            return participant;
        });
    }
    /**
     * Get participant by identity from conversation
     * @returns {Promise<Participant>}
     */
    async getParticipantByIdentity(identity) {
        let foundParticipant = null;
        return this.rosterEntityPromise.then(() => {
            this.participants.forEach(participant => {
                if (participant.identity === identity) {
                    foundParticipant = participant;
                }
            });
            if (!foundParticipant) {
                throw new Error('Participant with identity ' + identity + ' was not found');
            }
            return foundParticipant;
        });
    }
    /**
     * Add a chat participant to the conversation
     * @returns {Promise<any>}
     */
    async add(identity, attributes) {
        return await this.services.commandExecutor.mutateResource('post', this.links.participants, {
            identity,
            attributes: typeof attributes !== 'undefined' ? JSON.stringify(attributes) : undefined
        });
    }
    /**
     * Add a non-chat participant to the conversation.
     *
     * @param proxyAddress
     * @param address
     * @param attributes
     * @returns {Promise<any>}
     */
    addNonChatParticipant(proxyAddress, address, attributes) {
        return this.services.commandExecutor.mutateResource('post', this.links.participants, {
            attributes: typeof attributes !== 'undefined' ? JSON.stringify(attributes) : undefined,
            messaging_binding: {
                address,
                proxy_address: proxyAddress
            }
        });
    }
    /**
     * Remove the participant with a given identity from a conversation.
     */
    remove(identity) {
        return this.services.commandExecutor.mutateResource('delete', `${this.links.participants}/${identity}`);
    }
}
/**
 * Fired when participant joined conversation
 * @event Participants#participantJoined
 * @type {Participant}
 */
/**
 * Fired when participant left conversation
 * @event Participants#participantLeft
 * @type {Participant}
 */
/**
 * Fired when participant updated
 * @event Participants#participantUpdated
 * @type {Object}
 * @property {Participant} participant - Updated Participant
 * @property {Participant#UpdateReason[]} updateReasons - Array of Participant's updated event reasons
 */

/**
 * Represents a media information for a message in a conversation.
 */
class Media {
    /**
     * @internal
     */
    constructor(data, services) {
        this.mcsMedia = null;
        this.services = services;
        if (data instanceof mcsClient.McsMedia) {
            this.mcsMedia = data;
        }
        this.state = {
            sid: data.sid,
            category: data.category,
            filename: data.filename,
            contentType: data.contentType,
            size: data.size
        };
    }
    /**
     * Server-assigned unique identifier for the media.
     */
    get sid() { return this.state.sid; }
    /**
     * File name. Null if absent.
     */
    get filename() { return this.state.filename; }
    /**
     * Content type of the media.
     */
    get contentType() { return this.state.contentType; }
    /**
     * Size of the media in bytes.
     */
    get size() { return this.state.size; }
    /**
     * Media category, can be one of the {@link MediaCategory} values.
     */
    get category() { return this.state.category; }
    /**
     * Returns the direct content URL for the media.
     *
     * This URL is impermanent, it will expire in several minutes and cannot be cached.
     * If the URL becomes expired, you need to request a new one.
     * Each call to this function produces a new temporary URL.
     */
    async getContentTemporaryUrl() {
        await this._fetchMcsMedia();
        return this.mcsMedia.getContentUrl();
    }
    /**
     * Returns cached direct content URL for the media.
     *
     * This URL will expire in several minutes. This function does not refresh the URL and can be used to query it several times
     * without causing network traffic.
     * If the URL becomes expired, you need to request a new one using getContentTemporaryUrl().
     *
     * @returns {Promise<String>}
     */
    async getCachedTemporaryUrl() {
        await this._fetchMcsMedia();
        return this.mcsMedia.getCachedContentUrl();
    }
    async _fetchMcsMedia() {
        if (!this.mcsMedia) {
            if (this.services.mcsClient) {
                this.mcsMedia = await this.services.mcsClient.get(this.state.sid);
            }
            else {
                throw new Error('Media Content Service is unavailable');
            }
        }
    }
}

/**
 * Contains aggregated information about delivery statuses of a message across all participants
 * of a conversation.
 *
 * At any moment during the message delivery to a participant, the message can have zero or more of following
 * delivery statuses:
 * * Message is considered as **sent** to a participant if the nearest upstream carrier accepted the message.
 * * Message is considered as **delivered** to a participant if Twilio has received confirmation of message
 * delivery from the upstream carrier, and, where available, the destination handset.
 * * Message considered as **undelivered** to a participant if Twilio has received a delivery receipt
 * indicating that the message was not delivered. This can happen for many reasons including carrier content
 * filtering and the availability of the destination handset.
 * * Message considered as **read** by a participant if the message has been delivered and opened by the
 * recipient in a conversation. The recipient must have enabled the read receipts.
 * * Message considered as **failed** to be delivered to a participant if the message could not be sent.
 * This can happen for various reasons including queue overflows, account suspensions and media
 * errors (in the case of MMS for instance).
 *
 * {@link AggregatedDeliveryReceipt} class contains an aggregated value {@link DeliveryAmount} for each delivery status.
 */
class AggregatedDeliveryReceipt {
    /**
     * @internal
     */
    constructor(data) {
        this.state = data;
    }
    /**
     * Maximum number of delivery events expected for the message.
     */
    get total() {
        return this.state.total;
    }
    /**
     * Message is considered as **sent** to a participant if the nearest upstream carrier accepted the message.
     *
     * @return Amount of participants that have the **sent** delivery status for the message.
     */
    get sent() {
        return this.state.sent;
    }
    /**
     * Message is considered as **delivered** to a participant if Twilio has received confirmation of message
     * delivery from the upstream carrier, and, where available, the destination handset.
     *
     * @return Amount of participants that have the **delivered** delivery status for the message.
     */
    get delivered() {
        return this.state.delivered;
    }
    /**
     * Message is considered as **read** by a participant, if the message has been delivered and opened by the
     * recipient in a conversation. The recipient must have enabled the read receipts.
     *
     * @return Amount of participants that have the **read** delivery status for the message.
     */
    get read() {
        return this.state.read;
    }
    /**
     * Message is considered as **undelivered** to a participant if Twilio has received a delivery receipt
     * indicating that the message was not delivered. This can happen for many reasons including carrier content
     * filtering and the availability of the destination handset.
     *
     * @return Ammount of participants that have the **undelivered** delivery status for the message.
     */
    get undelivered() {
        return this.state.undelivered;
    }
    /**
     * Message is considered as **failed** to be delivered to a participant if the message could not be sent.
     * This can happen for various reasons including queue overflows, account suspensions and media
     * errors (in the case of MMS for instance). Twilio does not charge you for failed messages.
     *
     * @return Amount of participants that have the **failed** delivery status for the message.
     */
    get failed() {
        return this.state.failed;
    }
    _update(data) {
        this.state = data;
    }
    _isEquals(data) {
        const isTotalSame = this.total === data.total;
        const isSentSame = this.sent === data.sent;
        const isDeliveredSame = this.delivered === data.delivered;
        const isReadSame = this.read === data.read;
        const isUndeliveredSame = this.undelivered === data.undelivered;
        const isFailedSame = this.failed === data.failed;
        return isTotalSame && isSentSame && isDeliveredSame && isReadSame && isUndeliveredSame && isFailedSame;
    }
}

/**
 * Pagination helper class.
 */
class RestPaginator {
    /**
     * @internal
     */
    constructor(items, source, prevToken, nextToken) {
        this.state = {
            prevToken,
            nextToken,
            source,
            items
        };
    }
    /**
     * Indicates the existence of the next page.
     */
    get hasNextPage() { return !!this.state.nextToken; }
    /**
     * Indicates the existence of the previous page
     */
    get hasPrevPage() { return !!this.state.prevToken; }
    /**
     * Array of elements on the current page.
     */
    get items() { return this.state.items; }
    /**
     * Request the next page. Does not modify the existing object.
     */
    nextPage() {
        return this.hasNextPage ? this.state.source(this.state.nextToken) : Promise.reject(new Error('No next page'));
    }
    /**
     * Request the previous page. Does not modify the existing object.
     */
    prevPage() {
        return this.hasPrevPage ? this.state.source(this.state.prevToken) : Promise.reject(new Error('No previous page'));
    }
}

/**
 * Represents a delivery receipt of a message.
 */
class DetailedDeliveryReceipt {
    /**
     * @internal
     */
    constructor(descriptor) {
        this.sid = descriptor.sid;
        this.messageSid = descriptor.message_sid;
        this.conversationSid = descriptor.conversation_sid;
        this.channelMessageSid = descriptor.channel_message_sid;
        this.participantSid = descriptor.participant_sid;
        this.status = descriptor.status || 'queued';
        this.errorCode = descriptor.error_code || 0;
        this.dateCreated = descriptor.date_created;
        this.dateUpdated = descriptor.date_updated;
    }
}

const log$5 = Logger.scope('Message');
/**
 * A message in a conversation.
 */
class Message extends replayEventEmitter.ReplayEventEmitter {
    /**
     * @internal
     */
    constructor(index, data, conversation, links, configuration, services) {
        var _a, _b, _c, _d, _e;
        super();
        this.conversation = conversation;
        this.links = links;
        this.configuration = configuration;
        this.services = services;
        this.state = {
            sid: data.sid,
            index: index,
            author: (_a = data.author) !== null && _a !== void 0 ? _a : null,
            subject: (_b = data.subject) !== null && _b !== void 0 ? _b : null,
            body: data.text,
            timestamp: data.timestamp ? new Date(data.timestamp) : null,
            dateUpdated: data.dateUpdated ? new Date(data.dateUpdated) : null,
            lastUpdatedBy: (_c = data.lastUpdatedBy) !== null && _c !== void 0 ? _c : null,
            attributes: parseAttributes(data.attributes, `Got malformed attributes for the message ${data.sid}`, log$5),
            type: (_d = data.type) !== null && _d !== void 0 ? _d : 'text',
            media: (data.type && data.type === 'media' && data.media)
                ? new Media(data.media, this.services) : null,
            medias: (data.type && data.type === 'media' && data.medias)
                ? data.medias.map((m) => new Media(m, this.services)) : null,
            participantSid: (_e = data.memberSid) !== null && _e !== void 0 ? _e : null,
            aggregatedDeliveryReceipt: data.delivery ? new AggregatedDeliveryReceipt(data.delivery) : null
        };
    }
    /**
     * The server-assigned unique identifier for the message.
     */
    get sid() { return this.state.sid; }
    /**
     * Name of the user that sent the message.
     */
    get author() { return this.state.author; }
    /**
     * Message subject. Used only in email conversations.
     */
    get subject() { return this.state.subject; }
    /**
     * Body of the message.
     */
    get body() { return this.state.body; }
    /**
     * Date this message was last updated on.
     */
    get dateUpdated() { return this.state.dateUpdated; }
    /**
     * Index of the message in the conversation's messages list.
     * By design of the Conversations system, the message indices may have arbitrary gaps between them,
     * that does not necessarily mean they were deleted or otherwise modified - just that
     * messages may have some non-contiguous indices even if they are being sent immediately one after another.
     *
     * Trying to use indices for some calculations is going to be unreliable.
     *
     * To calculate the number of unread messages it is better to use the read horizon API.
     * See {@link Conversation.getUnreadMessagesCount} for details.
     */
    get index() { return this.state.index; }
    /**
     * Identity of the last user that updated the message.
     */
    get lastUpdatedBy() { return this.state.lastUpdatedBy; }
    /**
     * Date this message was created on.
     */
    get dateCreated() { return this.state.timestamp; }
    /**
     * Custom attributes of the message.
     */
    get attributes() { return this.state.attributes; }
    /**
     * Push notification type of the message.
     */
    get type() { return this.state.type; }
    /**
     * One of the attached media.
     * @deprecated Use attachedMedia instead. Note that the latter is now an array.
     */
    get media() { return this.state.media; }
    /**
     * Return all media attachments, except email body/history attachments, without temporary urls.
     */
    get attachedMedia() { return this.getMediaByCategory(['media']); }
    /**
     * The server-assigned unique identifier of the authoring participant.
     */
    get participantSid() { return this.state.participantSid; }
    /**
     * Aggregated information about the message delivery statuses across all participants of a conversation..
     */
    get aggregatedDeliveryReceipt() {
        return this.state.aggregatedDeliveryReceipt;
    }
    /**
     * Return a (possibly empty) array of media matching a specific set of categories.
     * Allowed category is so far only 'media'.
     * @param categories Array of categories to match.
     * @returns Array of media descriptors matching given categories.
     */
    getMediaByCategory(categories) {
        var _a;
        return (_a = this.state.medias) === null || _a === void 0 ? void 0 : _a.filter((m) => categories.includes(m.category));
    }
    _update(data) {
        let updateReasons = [];
        if ((data.text || ((typeof data.text) === 'string')) && data.text !== this.state.body) {
            this.state.body = data.text;
            updateReasons.push('body');
        }
        if (data.subject && data.subject !== this.state.subject) {
            this.state.subject = data.subject;
            updateReasons.push('subject');
        }
        if (data.lastUpdatedBy && data.lastUpdatedBy !== this.state.lastUpdatedBy) {
            this.state.lastUpdatedBy = data.lastUpdatedBy;
            updateReasons.push('lastUpdatedBy');
        }
        if (data.author && data.author !== this.state.author) {
            this.state.author = data.author;
            updateReasons.push('author');
        }
        if (data.dateUpdated &&
            new Date(data.dateUpdated).getTime() !== (this.state.dateUpdated && this.state.dateUpdated.getTime())) {
            this.state.dateUpdated = new Date(data.dateUpdated);
            updateReasons.push('dateUpdated');
        }
        if (data.timestamp &&
            new Date(data.timestamp).getTime() !== (this.state.timestamp && this.state.timestamp.getTime())) {
            this.state.timestamp = new Date(data.timestamp);
            updateReasons.push('dateCreated');
        }
        let updatedAttributes = parseAttributes(data.attributes, `Got malformed attributes for the message ${this.sid}`, log$5);
        if (!isDeepEqual(this.state.attributes, updatedAttributes)) {
            this.state.attributes = updatedAttributes;
            updateReasons.push('attributes');
        }
        let updatedAggregatedDelivery = data.delivery;
        let currentAggregatedDelivery = this.state.aggregatedDeliveryReceipt;
        let isUpdatedAggregateDeliveryValid = !!updatedAggregatedDelivery && !!updatedAggregatedDelivery.total &&
            !!updatedAggregatedDelivery.delivered && !!updatedAggregatedDelivery.failed && !!updatedAggregatedDelivery.read &&
            !!updatedAggregatedDelivery.sent && !!updatedAggregatedDelivery.undelivered;
        if (isUpdatedAggregateDeliveryValid) {
            if (!currentAggregatedDelivery) {
                this.state.aggregatedDeliveryReceipt = new AggregatedDeliveryReceipt(updatedAggregatedDelivery);
                updateReasons.push('deliveryReceipt');
            }
            else if (!currentAggregatedDelivery._isEquals(updatedAggregatedDelivery)) {
                currentAggregatedDelivery._update(updatedAggregatedDelivery);
                updateReasons.push('deliveryReceipt');
            }
        }
        if (updateReasons.length > 0) {
            this.emit('updated', { message: this, updateReasons: updateReasons });
        }
    }
    /**
     * Get the participant who is the author of the message.
     */
    async getParticipant() {
        let participant = null;
        if (this.state.participantSid) {
            participant = await this.conversation.getParticipantBySid(this.participantSid)
                .catch(() => {
                log$5.debug(`Participant with sid "${this.participantSid}" not found for message ${this.sid}`);
                return null;
            });
        }
        if (!participant && this.state.author) {
            participant = await this.conversation.getParticipantByIdentity(this.state.author)
                .catch(() => {
                log$5.debug(`Participant with identity "${this.author}" not found for message ${this.sid}`);
                return null;
            });
        }
        if (participant) {
            return participant;
        }
        let errorMesage = 'Participant with ';
        if (this.state.participantSid) {
            errorMesage += 'SID \'' + this.state.participantSid + '\' ';
        }
        if (this.state.author) {
            if (this.state.participantSid) {
                errorMesage += 'or ';
            }
            errorMesage += 'identity \'' + this.state.author + '\' ';
        }
        if (errorMesage === 'Participant with ') {
            errorMesage = 'Participant ';
        }
        errorMesage += 'was not found';
        throw new Error(errorMesage);
    }
    /**
     * Get the delivery receipts of the message.
     */
    async getDetailedDeliveryReceipts() {
        let paginator = await this._getDetailedDeliveryReceiptsPaginator();
        let detailedDeliveryReceipts = [];
        while (true) {
            detailedDeliveryReceipts = [...detailedDeliveryReceipts, ...paginator.items];
            if (!paginator.hasNextPage) {
                break;
            }
            paginator = await paginator.nextPage();
        }
        return detailedDeliveryReceipts;
    }
    /**
     * Remove the message.
     */
    async remove() {
        await this.services.commandExecutor.mutateResource('delete', this.links.self);
        return this;
    }
    /**
     * Edit the message body.
     * @param body New body of the message.
     */
    async updateBody(body) {
        await this.services.commandExecutor.mutateResource('post', this.links.self, {
            body
        });
        return this;
    }
    /**
     * Edit the message attributes.
     * @param attributes New attributes.
     */
    async updateAttributes(attributes) {
        await this.services.commandExecutor.mutateResource('post', this.links.self, {
            attributes: typeof attributes !== 'undefined' ? JSON.stringify(attributes) : undefined
        });
        return this;
    }
    /**
     * Get content URLs for all media attachments in the given set using single operation.
     * @param contentSet Set of media attachments to query for content URL.
     */
    async attachTemporaryUrlsFor(contentSet) {
        // We ignore existing mcsMedia members of each of the media entries.
        // Instead we just collect their sids and pull new descriptors from a mediaSet GET endpoint.
        const sids = contentSet.map((m) => m.sid);
        if (this.services.mcsClient) {
            return (await this.services.mcsClient.mediaSetGet(sids)).map((item) => { return new Media(item, this.services); });
        }
        else {
            throw new Error('Media Content Service is unavailable');
        }
    }
    async _getDetailedDeliveryReceiptsPaginator(options) {
        const messagesReceiptsUrl = this.configuration.links.messagesReceipts
            .replace('%s', this.conversation.sid)
            .replace('%s', this.sid);
        const url = new UriBuilder(messagesReceiptsUrl)
            .arg('PageToken', options === null || options === void 0 ? void 0 : options.pageToken)
            .arg('PageSize', options === null || options === void 0 ? void 0 : options.pageSize)
            .build();
        const response = await this.services.network.get(url);
        return new RestPaginator(response.body.delivery_receipts.map((x) => new DetailedDeliveryReceipt(x)), (pageToken, pageSize) => this._getDetailedDeliveryReceiptsPaginator({ pageToken, pageSize }), response.body.meta.previous_token, response.body.meta.next_token);
    }
}
/**
 * Fired when the properties or the body of the message has been updated.
 *
 * Parameters:
 * 1. object `data` - info object provided with the event. It has the following properties:
 *     * {@link Message} message - the message in question
 *     * {@link MessageUpdateReason}[] updateReasons - array of reasons for the update
 */
Message.updated = 'updated';
__decorate([
    declarativeTypeValidator.validateTypesAsync('string'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], Message.prototype, "updateBody", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(['string', 'number', 'boolean', 'object', declarativeTypeValidator.literal(null)]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], Message.prototype, "updateAttributes", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.custom(value => [
        value instanceof Array && value.length > 0 && value.reduce((a, c) => a && c instanceof Media),
        'a non-empty array of Media'
    ])),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array]),
    __metadata("design:returntype", Promise)
], Message.prototype, "attachTemporaryUrlsFor", null);

const log$4 = Logger.scope('Messages');
/**
 * Represents the collection of messages in a conversation
 */
class Messages extends replayEventEmitter.ReplayEventEmitter {
    constructor(conversation, configuration, services) {
        super();
        this.conversation = conversation;
        this.configuration = configuration;
        this.services = services;
        this.messagesByIndex = new Map();
        this.messagesListPromise = null;
    }
    /**
     * Subscribe to the Messages Event Stream
     * @param name - The name of Sync object for the Messages resource.
     */
    async subscribe(name) {
        if (this.messagesListPromise) {
            return this.messagesListPromise;
        }
        this.messagesListPromise = this.services.syncClient.list({
            id: name,
            mode: 'open_existing',
        });
        try {
            const list = await this.messagesListPromise;
            list.on('itemAdded', (args) => {
                log$4.debug(`${this.conversation.sid} itemAdded: ${args.item.index}`);
                const links = {
                    self: `${this.conversation.links.messages}/${args.item.data.sid}`,
                    conversation: this.conversation.links.self,
                    messages_receipts: `${this.conversation.links.messages}/${args.item.data.sid}/Receipts`,
                };
                const message = new Message(args.item.index, args.item.data, this.conversation, links, this.configuration, this.services);
                if (this.messagesByIndex.has(message.index)) {
                    log$4.debug('Message arrived, but is already known and ignored', this.conversation.sid, message.index);
                    return;
                }
                this.messagesByIndex.set(message.index, message);
                message.on('updated', (args) => this.emit('messageUpdated', args));
                this.emit('messageAdded', message);
            });
            list.on('itemRemoved', (args) => {
                log$4.debug(`#{this.conversation.sid} itemRemoved: ${args.index}`);
                const index = args.index;
                if (this.messagesByIndex.has(index)) {
                    let message = this.messagesByIndex.get(index);
                    this.messagesByIndex.delete(message.index);
                    message.removeAllListeners('updated');
                    this.emit('messageRemoved', message);
                }
            });
            list.on('itemUpdated', (args) => {
                log$4.debug(`${this.conversation.sid} itemUpdated: ${args.item.index}`);
                const message = this.messagesByIndex.get(args.item.index);
                if (message) {
                    message._update(args.item.data);
                }
            });
            return list;
        }
        catch (err) {
            this.messagesListPromise = null;
            if (this.services.syncClient.connectionState !== 'disconnected') {
                log$4.error('Failed to get messages object for conversation', this.conversation.sid, err);
            }
            log$4.debug('ERROR: Failed to get messages object for conversation', this.conversation.sid, err);
            throw err;
        }
    }
    async unsubscribe() {
        if (!this.messagesListPromise) {
            return;
        }
        const entity = await this.messagesListPromise;
        entity.close();
        this.messagesListPromise = null;
    }
    /**
     * Send Message to the conversation, message could include both text and multiple media attachments.
     * @param message Message to post
     * @returns Returns promise which can fail
     */
    async sendV2(message) {
        var _a;
        log$4.debug('Sending message V2', message.mediaContent, message.attributes, message.emailOptions);
        const media = [];
        for (const [category, mediaContent] of message.mediaContent) {
            log$4.debug(`Adding media to a message as ${mediaContent instanceof FormData ? 'FormData' : 'SendMediaOptions'}`, mediaContent);
            media.push(mediaContent instanceof FormData
                ? await this.services.mcsClient.postFormData(mediaContent, category)
                : await this.services.mcsClient.post(mediaContent.contentType, mediaContent.media, category, mediaContent.filename));
        }
        return await this.services.commandExecutor.mutateResource('post', this.conversation.links.messages, {
            body: message.text,
            subject: (_a = message.emailOptions) === null || _a === void 0 ? void 0 : _a.subject,
            media_sids: media.map((m) => m.sid),
            attributes: typeof message.attributes !== 'undefined'
                ? JSON.stringify(message.attributes)
                : undefined,
        });
    }
    /**
     * Send Message to the conversation
     * @param message Message to post
     * @param attributes Message attributes
     * @param emailOptions Options that modify E-mail integration behaviors.
     * @returns Returns promise which can fail
     */
    async send(message, attributes = {}, emailOptions) {
        log$4.debug('Sending text message', message, attributes, emailOptions);
        return await this.services.commandExecutor.mutateResource('post', this.conversation.links.messages, {
            body: message !== null && message !== void 0 ? message : '',
            attributes: typeof attributes !== 'undefined'
                ? JSON.stringify(attributes)
                : undefined,
            subject: emailOptions === null || emailOptions === void 0 ? void 0 : emailOptions.subject,
        });
    }
    /**
     * Send Media Message to the conversation
     * @param mediaContent Media content to post
     * @param attributes Message attributes
     * @param emailOptions Email options
     * @returns Returns promise which can fail
     */
    async sendMedia(mediaContent, attributes = {}, emailOptions) {
        log$4.debug('Sending media message', mediaContent, attributes, emailOptions);
        log$4.debug(`Sending media message as ${mediaContent instanceof FormData ? 'FormData' : 'SendMediaOptions'}`, mediaContent, attributes);
        const media = mediaContent instanceof FormData
            ? await this.services.mcsClient.postFormData(mediaContent)
            : await this.services.mcsClient.post(mediaContent.contentType, mediaContent.media, 'media', mediaContent.filename);
        // emailOptions are currently ignored for media messages.
        return await this.services.commandExecutor.mutateResource('post', this.conversation.links.messages, {
            media_sids: [media.sid],
            attributes: typeof attributes !== 'undefined'
                ? JSON.stringify(attributes)
                : undefined,
        });
    }
    /**
     * Returns messages from conversation using paginator interface
     * @param pageSize Number of messages to return in single chunk. By default it's 30.
     * @param anchor Most early message id which is already known, or 'end' by default
     * @param direction Pagination order 'backwards' or 'forward', 'forward' by default
     * @returns Last page of messages by default
     */
    async getMessages(pageSize, anchor, direction = 'backwards') {
        return this._getMessages(pageSize, anchor, direction);
    }
    _wrapPaginator(order, page, op) {
        // Due to an inconsistency between Sync and Chat conventions, next and
        // previous pages should be swapped.
        const shouldReverse = order === 'desc';
        const nextPage = () => page.nextPage().then((page) => this._wrapPaginator(order, page, op));
        const previousPage = () => page.prevPage().then((page) => this._wrapPaginator(order, page, op));
        return op(page.items).then((items) => ({
            items: items.sort((x, y) => {
                return x.index - y.index;
            }),
            hasPrevPage: shouldReverse ? page.hasNextPage : page.hasPrevPage,
            hasNextPage: shouldReverse ? page.hasPrevPage : page.hasNextPage,
            prevPage: shouldReverse ? nextPage : previousPage,
            nextPage: shouldReverse ? previousPage : nextPage,
        }));
    }
    _upsertMessage(index, value) {
        const cachedMessage = this.messagesByIndex.get(index);
        if (cachedMessage) {
            return cachedMessage;
        }
        const links = {
            self: `${this.conversation.links.messages}/${value.sid}`,
            conversation: this.conversation.links.self,
            messages_receipts: `${this.conversation.links.messages}/${value.sid}/Receipts`,
        };
        const message = new Message(index, value, this.conversation, links, this.configuration, this.services);
        this.messagesByIndex.set(message.index, message);
        message.on('updated', (args) => this.emit('messageUpdated', args));
        return message;
    }
    /**
     * Returns last messages from conversation
     * @param {Number} [pageSize] Number of messages to return in single chunk. By default it's 30.
     * @param {String} [anchor] Most early message id which is already known, or 'end' by default
     * @param {String} [direction] Pagination order 'backwards' or 'forward', or 'forward' by default
     * @returns {Promise<SyncPaginator<Message>>} last page of messages by default
     * @private
     */
    async _getMessages(pageSize = 30, anchor = 'end', direction = 'forward') {
        const order = direction === 'backwards' ? 'desc' : 'asc';
        const list = await this.messagesListPromise;
        const page = await list.getItems({
            from: anchor !== 'end' ? anchor : void 0,
            pageSize,
            order,
            limit: pageSize, // @todo Limit equals pageSize by default in Sync. This is probably not ideal.
        });
        return await this._wrapPaginator(order, page, (items) => Promise.all(items.map((item) => this._upsertMessage(item.index, item.data))));
    }
}

/**
 * An unsent message. Returned from {@link MessageBuilder.build}.
 */
class UnsentMessage {
    /**
     * @internal
     */
    constructor(messagesEntity) {
        this.messagesEntity = messagesEntity;
        this.attributes = {};
        this.mediaContent = [];
        this.emailOptions = {};
    }
    /**
     * Send the prepared message to the conversation.
     * @returns Index of the new message in the conversation.
     */
    async send() {
        const response = await this.messagesEntity.sendV2(this);
        return parseToNumber(response.index);
    }
}

/**
 * Message builder. Allows the message to be built and sent via method chaining.
 *
 * Example:
 *
 * ```ts
 * await testConversation.prepareMessage()
 *   .setBody('Hello!')
 *   .setAttributes({foo: 'bar'})
 *   .addMedia(media1)
 *   .addMedia(media2)
 *   .build()
 *   .send();
 * ```
 */
class MessageBuilder {
    /**
     * @internal
     */
    constructor(limits, messagesEntity) {
        this.limits = limits;
        this.message = new UnsentMessage(messagesEntity);
    }
    /**
     * Sets the message body.
     * @param text Contents of the body.
     */
    setBody(text) {
        this.message.text = text;
        return this;
    }
    /**
     * Sets the message subject.
     * @param subject Contents of the subject.
     */
    setSubject(subject) {
        this.message.emailOptions.subject = subject;
        return this;
    }
    /**
     * Sets the message attributes.
     * @param attributes Message attributes.
     */
    setAttributes(attributes) {
        this.message.attributes = attributes;
        return this;
    }
    /**
     * Adds media to the message.
     * @param payload Media to add.
     */
    addMedia(payload) {
        this.message.mediaContent.push(['media', payload]);
        return this;
    }
    /**
     * Builds the message, making it ready to be sent.
     */
    build() {
        if (this.message.mediaContent.length > this.limits.mediaAttachmentsCountLimit) {
            throw new Error(`Too many media attachments in the message (${this.message.mediaContent.length} > ${this.limits.mediaAttachmentsCountLimit})`);
        }
        // @todo we don't know the sizes of the attachments in FormData
        return this.message;
    }
    getPayloadContentType(payload) {
        if (typeof FormData !== 'undefined' && (payload instanceof FormData)) {
            return payload.get('Content-Type');
        }
        return payload.contentType;
    }
}

const log$3 = Logger.scope('Conversation');
const fieldMappings = {
    lastMessage: 'lastMessage',
    attributes: 'attributes',
    createdBy: 'createdBy',
    dateCreated: 'dateCreated',
    dateUpdated: 'dateUpdated',
    friendlyName: 'friendlyName',
    lastConsumedMessageIndex: 'lastConsumedMessageIndex',
    notificationLevel: 'notificationLevel',
    sid: 'sid',
    status: 'status',
    uniqueName: 'uniqueName',
    state: 'state'
};
function parseTime(timeString) {
    try {
        return new Date(timeString);
    }
    catch (e) {
        return null;
    }
}
/**
 * A conversation represents communication between multiple Conversations clients
 */
class Conversation extends replayEventEmitter.ReplayEventEmitter {
    /**
     * @internal
     */
    constructor(descriptor, sid, links, configuration, services) {
        super();
        this.sid = sid;
        this.links = links;
        this.configuration = configuration;
        this.services = services;
        let attributes = descriptor.attributes || {};
        let createdBy = descriptor.createdBy;
        let dateCreated = parseTime(descriptor.dateCreated);
        let dateUpdated = parseTime(descriptor.dateUpdated);
        let friendlyName = descriptor.friendlyName || null;
        let lastReadMessageIndex = Number.isInteger(descriptor.lastConsumedMessageIndex) ? descriptor.lastConsumedMessageIndex : null;
        let uniqueName = descriptor.uniqueName || null;
        try {
            JSON.stringify(attributes);
        }
        catch (e) {
            throw new Error('Attributes must be a valid JSON object.');
        }
        this.entityName = descriptor.channel;
        this.channelState = {
            uniqueName,
            status: 'notParticipating',
            attributes,
            createdBy,
            dateCreated,
            dateUpdated,
            friendlyName,
            lastReadMessageIndex: lastReadMessageIndex
        };
        if (descriptor.notificationLevel) {
            this.channelState.notificationLevel = descriptor.notificationLevel;
        }
        const participantsLinks = {
            participants: this.links.participants
        };
        this.participants = new Map();
        this.participantsEntity = new Participants(this, this.participants, participantsLinks, this.configuration, this.services);
        this.participantsEntity.on('participantJoined', this.emit.bind(this, 'participantJoined'));
        this.participantsEntity.on('participantLeft', this.emit.bind(this, 'participantLeft'));
        this.participantsEntity.on('participantUpdated', (args) => this.emit('participantUpdated', args));
        this.messagesEntity = new Messages(this, configuration, services);
        this.messagesEntity.on('messageAdded', message => this._onMessageAdded(message));
        this.messagesEntity.on('messageUpdated', (args) => this.emit('messageUpdated', args));
        this.messagesEntity.on('messageRemoved', this.emit.bind(this, 'messageRemoved'));
    }
    /**
     * Unique name of the conversation.
     */
    get uniqueName() { return this.channelState.uniqueName; }
    /**
     * Status of the conversation.
     */
    get status() { return this.channelState.status; }
    /**
     * Name of the conversation.
     */
    get friendlyName() { return this.channelState.friendlyName; }
    /**
     * Date this conversation was last updated on.
     */
    get dateUpdated() { return this.channelState.dateUpdated; }
    /**
     * Date this conversation was created on.
     */
    get dateCreated() { return this.channelState.dateCreated; }
    /**
     * Identity of the user that created this conversation.
     */
    get createdBy() { return this.channelState.createdBy; }
    /**
     * Custom attributes of the conversation.
     */
    get attributes() { return this.channelState.attributes; }
    /**
     * Index of the last message the user has read in this conversation.
     */
    get lastReadMessageIndex() { return this.channelState.lastReadMessageIndex; }
    /**
     * Last message sent to this conversation.
     */
    get lastMessage() { return this.channelState.lastMessage; }
    /**
     * User notification level for this conversation.
     */
    get notificationLevel() { return this.channelState.notificationLevel; }
    get limits() { return this.configuration.limits; }
    /**
     * State of the conversation.
     */
    get state() { return this.channelState.state; }
    /**
     * Load and subscribe to this conversation and do not subscribe to its participants and messages.
     * This or _subscribeStreams will need to be called before any events on conversation will fire.
     * @internal
     */
    _subscribe() {
        var _a;
        return this.entityPromise = (_a = this.entityPromise) !== null && _a !== void 0 ? _a : this.services.syncClient.document({ id: this.entityName, mode: 'open_existing' })
            .then(entity => {
            this.entity = entity;
            this.entity.on('updated', args => { this._update(args.data); });
            this.entity.on('removed', () => this.emit('removed', this));
            this._update(this.entity.data);
            return entity;
        })
            .catch(err => {
            this.entity = null;
            this.entityPromise = null;
            if (this.services.syncClient.connectionState != 'disconnected') {
                log$3.error('Failed to get conversation object', err);
            }
            log$3.debug('ERROR: Failed to get conversation object', err);
            throw err;
        });
    }
    /**
     * Load the attributes of this conversation and instantiate its participants and messages.
     * This or _subscribe will need to be called before any events on the conversation will fire.
     * This will need to be called before any events on participants or messages will fire
     * @internal
     */
    async _subscribeStreams() {
        try {
            await this._subscribe();
            log$3.trace('_subscribeStreams, this.entity.data=', this.entity.data);
            const messagesObjectName = this.entity.data.messages;
            const rosterObjectName = this.entity.data.roster;
            await Promise.all([
                this.messagesEntity.subscribe(messagesObjectName),
                this.participantsEntity.subscribe(rosterObjectName)
            ]);
        }
        catch (err) {
            if (this.services.syncClient.connectionState !== 'disconnected') {
                log$3.error('Failed to subscribe on conversation objects', this.sid, err);
            }
            log$3.debug('ERROR: Failed to subscribe on conversation objects', this.sid, err);
            throw err;
        }
    }
    /**
     * Stop listening for and firing events on this conversation.
     * @internal
     */
    async _unsubscribe() {
        if (this.entity) {
            await this.entity.close();
            this.entity = null;
            this.entityPromise = null;
        }
        return Promise.all([
            this.participantsEntity.unsubscribe(),
            this.messagesEntity.unsubscribe()
        ]);
    }
    /**
     * Set conversation status.
     * @internal
     */
    _setStatus(status, source) {
        this.statusSource = source;
        if (this.channelState.status === status) {
            return;
        }
        this.channelState.status = status;
        if (status === 'joined') {
            this._subscribeStreams()
                .catch(err => {
                log$3.debug('ERROR while setting conversation status ' + status, err);
                if (this.services.syncClient.connectionState !== 'disconnected') {
                    throw err;
                }
            });
        }
        else if (this.entityPromise) {
            this._unsubscribe().catch(err => {
                log$3.debug('ERROR while setting conversation status ' + status, err);
                if (this.services.syncClient.connectionState !== 'disconnected') {
                    throw err;
                }
            });
        }
    }
    /**
     * Get the source of the conversation update.
     * @internal
     */
    _statusSource() {
        return this.statusSource;
    }
    static preprocessUpdate(update, conversationSid) {
        try {
            if (typeof update.attributes === 'string') {
                update.attributes = JSON.parse(update.attributes);
            }
            else if (update.attributes) {
                JSON.stringify(update.attributes);
            }
        }
        catch (e) {
            log$3.warn('Retrieved malformed attributes from the server for conversation: ' + conversationSid);
            update.attributes = {};
        }
        try {
            if (update.dateCreated) {
                update.dateCreated = new Date(update.dateCreated);
            }
        }
        catch (e) {
            log$3.warn('Retrieved malformed dateCreated from the server for conversation: ' + conversationSid);
            delete update.dateCreated;
        }
        try {
            if (update.dateUpdated) {
                update.dateUpdated = new Date(update.dateUpdated);
            }
        }
        catch (e) {
            log$3.warn('Retrieved malformed dateUpdated from the server for conversation: ' + conversationSid);
            delete update.dateUpdated;
        }
        try {
            if (update.lastMessage && update.lastMessage.timestamp) {
                update.lastMessage.timestamp = new Date(update.lastMessage.timestamp);
            }
        }
        catch (e) {
            log$3.warn('Retrieved malformed lastMessage.timestamp from the server for conversation: ' + conversationSid);
            delete update.lastMessage.timestamp;
        }
    }
    /**
     * Update the local conversation object with new values.
     * @internal
     */
    _update(update) {
        var _a, _b, _c, _d, _e;
        log$3.trace('_update', update);
        Conversation.preprocessUpdate(update, this.sid);
        const updateReasons = new Set();
        for (const key of Object.keys(update)) {
            const localKey = fieldMappings[key];
            if (!localKey) {
                continue;
            }
            switch (localKey) {
                case fieldMappings.status:
                    if (!update.status || update.status === 'unknown'
                        || this.channelState.status === update.status) {
                        break;
                    }
                    this.channelState.status = update.status;
                    updateReasons.add(localKey);
                    break;
                case fieldMappings.attributes:
                    if (isDeepEqual(this.channelState.attributes, update.attributes)) {
                        break;
                    }
                    this.channelState.attributes = update.attributes;
                    updateReasons.add(localKey);
                    break;
                case fieldMappings.lastConsumedMessageIndex:
                    if (update.lastConsumedMessageIndex === undefined
                        || update.lastConsumedMessageIndex === this.channelState.lastReadMessageIndex) {
                        break;
                    }
                    this.channelState.lastReadMessageIndex = update.lastConsumedMessageIndex;
                    updateReasons.add('lastReadMessageIndex');
                    break;
                case fieldMappings.lastMessage:
                    if (this.channelState.lastMessage && !update.lastMessage) {
                        delete this.channelState.lastMessage;
                        updateReasons.add(localKey);
                        break;
                    }
                    this.channelState.lastMessage = this.channelState.lastMessage || {};
                    if (((_a = update.lastMessage) === null || _a === void 0 ? void 0 : _a.index) !== undefined
                        && update.lastMessage.index !== this.channelState.lastMessage.index) {
                        this.channelState.lastMessage.index = update.lastMessage.index;
                        updateReasons.add(localKey);
                    }
                    if (((_b = update.lastMessage) === null || _b === void 0 ? void 0 : _b.timestamp) !== undefined
                        && ((_d = (_c = this.channelState.lastMessage) === null || _c === void 0 ? void 0 : _c.dateCreated) === null || _d === void 0 ? void 0 : _d.getTime()) !== update.lastMessage.timestamp.getTime()) {
                        this.channelState.lastMessage.dateCreated = update.lastMessage.timestamp;
                        updateReasons.add(localKey);
                    }
                    if (isDeepEqual(this.channelState.lastMessage, {})) {
                        delete this.channelState.lastMessage;
                    }
                    break;
                case fieldMappings.state:
                    const state = update.state || undefined;
                    if (state !== undefined) {
                        state.dateUpdated = new Date(state.dateUpdated);
                    }
                    if (isDeepEqual(this.channelState.state, state)) {
                        break;
                    }
                    this.channelState.state = state;
                    updateReasons.add(localKey);
                    break;
                default:
                    const isDate = update[key] instanceof Date;
                    const keysMatchAsDates = isDate && ((_e = this.channelState[localKey]) === null || _e === void 0 ? void 0 : _e.getTime()) === update[key].getTime();
                    const keysMatchAsNonDates = !isDate && this[localKey] === update[key];
                    if (keysMatchAsDates || keysMatchAsNonDates) {
                        break;
                    }
                    this.channelState[localKey] = update[key];
                    updateReasons.add(localKey);
            }
        }
        if (updateReasons.size > 0) {
            this.emit('updated', { conversation: this, updateReasons: [...updateReasons] });
        }
    }
    /**
     * @internal
     */
    _onMessageAdded(message) {
        for (let participant of this.participants.values()) {
            if (participant.identity === message.author) {
                participant._endTyping();
                break;
            }
        }
        this.emit('messageAdded', message);
    }
    async _setLastReadMessageIndex(index) {
        const result = await this.services.commandExecutor.mutateResource('post', `${this.configuration.links.myConversations}/${this.sid}`, {
            last_read_message_index: index
        });
        return result.unread_messages_count;
    }
    /**
     * Add a participant to the conversation by its identity.
     * @param identity Identity of the Client to add.
     * @param attributes Attributes to be attached to the participant.
     */
    async add(identity, attributes) {
        return this.participantsEntity.add(identity, attributes);
    }
    /**
     * Add a non-chat participant to the conversation.
     * @param proxyAddress Proxy (Twilio) address of the participant.
     * @param address User address of the participant.
     * @param attributes Attributes to be attached to the participant.
     */
    async addNonChatParticipant(proxyAddress, address, attributes) {
        return this.participantsEntity.addNonChatParticipant(proxyAddress, address, attributes);
    }
    /**
     * Advance the conversation's last read message index to the current read horizon.
     * Rejects if the user is not a participant of the conversation.
     * Last read message index is updated only if the new index value is higher than the previous.
     * @param index Message index to advance to.
     * @return Resulting unread messages count in the conversation.
     */
    async advanceLastReadMessageIndex(index) {
        await this._subscribeStreams();
        if (index < this.lastReadMessageIndex) {
            return await this._setLastReadMessageIndex(this.lastReadMessageIndex);
        }
        return await this._setLastReadMessageIndex(index);
    }
    /**
     * Delete the conversation and unsubscribe from its events.
     */
    async delete() {
        await this.services.commandExecutor.mutateResource('delete', this.links.self);
        return this;
    }
    /**
     * Get the custom attributes of this Conversation.
     */
    async getAttributes() {
        await this._subscribe();
        return this.attributes;
    }
    /**
     * Returns messages from the conversation using the paginator interface.
     * @param pageSize Number of messages to return in a single chunk. Default is 30.
     * @param anchor Index of the newest message to fetch. Default is from the end.
     * @param direction Query direction. By default it queries backwards
     * from newer to older. The `"forward"` value will query in the opposite direction.
     * @return A page of messages.
     */
    async getMessages(pageSize, anchor, direction) {
        await this._subscribeStreams();
        return this.messagesEntity.getMessages(pageSize, anchor, direction);
    }
    /**
     * Get a list of all the participants who are joined to this conversation.
     */
    async getParticipants() {
        await this._subscribeStreams();
        return this.participantsEntity.getParticipants();
    }
    /**
     * Get conversation participants count.
     *
     * This method is semi-realtime. This means that this data will be eventually correct,
     * but will also be possibly incorrect for a few seconds. The Conversations system does not
     * provide real time events for counter values changes.
     *
     * This is useful for any UI badges, but it is not recommended to build any core application
     * logic based on these counters being accurate in real time.
     */
    async getParticipantsCount() {
        const url = new UriBuilder(this.configuration.links.conversations)
            .path(this.sid)
            .build();
        const response = await this.services.network.get(url);
        return response.body.participants_count;
    }
    /**
     * Get a participant by its SID.
     * @param participantSid Participant SID.
     */
    async getParticipantBySid(participantSid) {
        return this.participantsEntity.getParticipantBySid(participantSid);
    }
    /**
     * Get a participant by its identity.
     * @param identity Participant identity.
     */
    async getParticipantByIdentity(identity) {
        return this.participantsEntity.getParticipantByIdentity(identity);
    }
    /**
     * Get the total message count in the conversation.
     *
     * This method is semi-realtime. This means that this data will be eventually correct,
     * but will also be possibly incorrect for a few seconds. The Conversations system does not
     * provide real time events for counter values changes.
     *
     * This is useful for any UI badges, but it is not recommended to build any core application
     * logic based on these counters being accurate in real time.
     */
    async getMessagesCount() {
        const url = new UriBuilder(this.configuration.links.conversations)
            .path(this.sid)
            .build();
        const response = await this.services.network.get(url);
        return response.body.messages_count;
    }
    /**
     * Get unread messages count for the user if they are a participant of this conversation.
     * Rejects if the user is not a participant of the conversation.
     *
     * Use this method to obtain the number of unread messages together with
     * {@link Conversation.updateLastReadMessageIndex} instead of relying on the
     * message indices which may have gaps. See {@link Message.index} for details.
     *
     * This method is semi-realtime. This means that this data will be eventually correct,
     * but will also be possibly incorrect for a few seconds. The Conversations system does not
     * provide real time events for counter values changes.
     *
     * This is useful for any UI badges, but it is not recommended to build any core application
     * logic based on these counters being accurate in real time.
     */
    async getUnreadMessagesCount() {
        const url = new UriBuilder(this.configuration.links.myConversations)
            .path(this.sid)
            .build();
        const response = await this.services.network.get(url);
        if (response.body.conversation_sid !== this.sid) {
            throw new Error('Conversation was not found in the user conversations list');
        }
        const unreadMessageCount = response.body.unread_messages_count;
        if (typeof unreadMessageCount === 'number') {
            return unreadMessageCount;
        }
        return null;
    }
    /**
     * Join the conversation and subscribe to its events.
     */
    async join() {
        await this.services.commandExecutor.mutateResource('post', this.links.participants, {
            identity: this.configuration.userIdentity
        });
        return this;
    }
    /**
     * Leave the conversation.
     */
    async leave() {
        if (this.channelState.status === 'joined') {
            await this.services.commandExecutor.mutateResource('delete', `${this.links.participants}/${this.configuration.userIdentity}`);
        }
        return this;
    }
    /**
     * Remove a participant from the conversation. When a string is passed as the
     * argument, it will assume that the string is an identity or SID.
     * @param participant Identity, SID or the participant object to remove.
     */
    async removeParticipant(participant) {
        await this.participantsEntity.remove(typeof participant === 'string'
            ? participant
            : participant.sid);
    }
    /**
     * Send a message to the conversation.
     * @param message Message body for the text message,
     * `FormData` or {@link SendMediaOptions} for media content. Sending FormData is supported only with the browser engine.
     * @param messageAttributes Attributes for the message.
     * @param emailOptions Email options for the message.
     * @return Index of the new message.
     */
    async sendMessage(message, messageAttributes, emailOptions) {
        if (typeof message === 'string' || message === null) {
            let response = await this.messagesEntity.send(message, messageAttributes, emailOptions);
            return parseToNumber(response.index);
        }
        let response = await this.messagesEntity.sendMedia(message, messageAttributes, emailOptions);
        return parseToNumber(response.index);
    }
    /**
     * New interface to prepare for sending a message.
     * Use instead of `sendMessage`.
     */
    prepareMessage() {
        return new MessageBuilder(this.limits, this.messagesEntity);
    }
    /**
     * Set last read message index of the conversation to the index of the last known message.
     * @return Resulting unread messages count in the conversation.
     */
    async setAllMessagesRead() {
        await this._subscribeStreams();
        let messagesPage = await this.getMessages(1);
        if (messagesPage.items.length > 0) {
            return this.advanceLastReadMessageIndex(messagesPage.items[0].index);
        }
        return Promise.resolve(0);
    }
    /**
     * Set all messages in the conversation unread.
     * @return Resulting unread messages count in the conversation.
     */
    async setAllMessagesUnread() {
        await this._subscribeStreams();
        return await this._setLastReadMessageIndex(null);
    }
    /**
     * Set user notification level for this conversation.
     * @param notificationLevel New user notification level.
     */
    async setUserNotificationLevel(notificationLevel) {
        await this.services.commandExecutor.mutateResource('post', `${this.configuration.links.myConversations}/${this.sid}`, {
            notification_level: notificationLevel
        });
    }
    /**
     * Send a notification to the server indicating that this client is currently typing in this conversation.
     * Typing ended notification is sent after a while automatically, but by calling this method again you ensure that typing ended is not received.
     */
    typing() {
        return this.services.typingIndicator.send(this.sid);
    }
    /**
     * Update the attributes of the conversation.
     * @param attributes New attributes.
     */
    async updateAttributes(attributes) {
        await this.services.commandExecutor.mutateResource('post', this.links.self, {
            attributes: attributes !== undefined ? JSON.stringify(attributes) : undefined
        });
        return this;
    }
    /**
     * Update the friendly name of the conversation.
     * @param friendlyName New friendly name.
     */
    async updateFriendlyName(friendlyName) {
        if (this.channelState.friendlyName !== friendlyName) {
            await this.services.commandExecutor.mutateResource('post', this.links.self, { friendly_name: friendlyName });
        }
        return this;
    }
    /**
     * Set the last read message index to the current read horizon.
     * @param index Message index to set as last read.
     * If null is provided, then the behavior is identical to {@link Conversation.setAllMessagesUnread}.
     * @returns Resulting unread messages count in the conversation.
     */
    async updateLastReadMessageIndex(index) {
        await this._subscribeStreams();
        return this._setLastReadMessageIndex(index);
    }
    /**
     * Update the unique name of the conversation.
     * @param uniqueName New unique name for the conversation. Setting unique name to null removes it.
     */
    async updateUniqueName(uniqueName) {
        if (this.channelState.uniqueName !== uniqueName) {
            if (!uniqueName) {
                uniqueName = '';
            }
            await this.services.commandExecutor.mutateResource('post', this.links.self, {
                unique_name: uniqueName
            });
        }
        return this;
    }
}
/**
 * Fired when a participant has joined the conversation.
 *
 * Parameters:
 * 1. {@link Participant} `participant` - participant that joined the conversation
 * @event
 */
Conversation.participantJoined = 'participantJoined';
/**
 * Fired when a participant has left the conversation.
 *
 * Parameters:
 * 1. {@link Participant} `participant` - participant that left the conversation
 * @event
 */
Conversation.participantLeft = 'participantLeft';
/**
 * Fired when data of a participant has been updated.
 *
 * Parameters:
 * 1. object `data` - info object provided with the event. It has the following properties:
 *     * {@link Participant} `participant` - participant that has received the update
 *     * {@link ParticipantUpdateReason}[] `updateReasons` - array of reasons for update
 * @event
 */
Conversation.participantUpdated = 'participantUpdated';
/**
 * Fired when a new message has been added to the conversation.
 *
 * Parameters:
 * 1. {@link Message} `message` - message that has been added
 * @event
 */
Conversation.messageAdded = 'messageAdded';
/**
 * Fired when message is removed from the conversation's message list.
 *
 * Parameters:
 * 1. {@link Message} `message` - message that has been removed
 * @event
 */
Conversation.messageRemoved = 'messageRemoved';
/**
 * Fired when data of a message has been updated.
 *
 * Parameters:
 * 1. object `data` - info object provided with the event. It has the following properties:
 *     * {@link Message} `message` - message that has received the update
 *     * {@link MessageUpdateReason}[] `updateReasons` - array of reasons for update
 * @event
 */
Conversation.messageUpdated = 'messageUpdated';
/**
 * Fired when a participant has stopped typing.
 *
 * Parameters:
 * 1. {@link Participant} `participant` - the participant that has stopped typing
 * @event
 */
Conversation.typingEnded = 'typingEnded';
/**
 * Fired when a participant has started typing.
 *
 * Parameters:
 * 1. {@link Participant} `participant` - the participant that has started typing
 * @event
 */
Conversation.typingStarted = 'typingStarted';
/**
 * Fired when the data of the conversation has been updated.
 *
 * Parameters:
 * 1. object `data` - info object provided with the event. It has the following properties:
 *     * {@link Conversation} `conversation` - conversation that has received the update
 *     * {@link ConversationUpdateReason}[] `updateReasons` - array of reasons for update
 * @event
 */
Conversation.updated = 'updated';
/**
 * Fired when the conversation was destroyed or the currently-logged-in user has left private conversation.
 *
 * Parameters:
 * 1. {@link Conversation} `conversation` - conversation that has been removed
 * @event
 */
Conversation.removed = 'removed';
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString, ['undefined', 'string', 'number', 'boolean', 'object', declarativeTypeValidator.literal(null)]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], Conversation.prototype, "add", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString, declarativeTypeValidator.nonEmptyString, ['undefined', 'string', 'number', 'boolean', 'object', declarativeTypeValidator.literal(null)]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Object]),
    __metadata("design:returntype", Promise)
], Conversation.prototype, "addNonChatParticipant", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", Promise)
], Conversation.prototype, "advanceLastReadMessageIndex", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(['undefined', declarativeTypeValidator.nonNegativeInteger], ['undefined', declarativeTypeValidator.nonNegativeInteger], ['undefined', declarativeTypeValidator.literal('backwards', 'forward')]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, Number, String]),
    __metadata("design:returntype", Promise)
], Conversation.prototype, "getMessages", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], Conversation.prototype, "getParticipantBySid", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], Conversation.prototype, "getParticipantByIdentity", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync([declarativeTypeValidator.nonEmptyString, Participant]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], Conversation.prototype, "removeParticipant", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync([
        'string',
        declarativeTypeValidator.literal(null),
        // Wrapping it into a custom rule is necessary because the FormData class is not available on initialization.
        declarativeTypeValidator.custom((value) => [value instanceof FormData, 'an instance of FormData']),
        declarativeTypeValidator.objectSchema('media options', {
            contentType: declarativeTypeValidator.nonEmptyString,
            media: declarativeTypeValidator.custom((value) => {
                let isValid = (typeof value === 'string' && value.length > 0) || value instanceof Uint8Array || value instanceof ArrayBuffer;
                if (typeof Blob === 'function') {
                    isValid = isValid || value instanceof Blob;
                }
                return [
                    isValid,
                    'a non-empty string, an instance of Buffer or an instance of Blob'
                ];
            })
        })
    ], ['undefined', 'string', 'number', 'boolean', 'object', declarativeTypeValidator.literal(null)], ['undefined', declarativeTypeValidator.literal(null), declarativeTypeValidator.objectSchema('email attributes', {
            subject: [declarativeTypeValidator.nonEmptyString, 'undefined']
        })]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, Object]),
    __metadata("design:returntype", Promise)
], Conversation.prototype, "sendMessage", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.literal('default', 'muted')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], Conversation.prototype, "setUserNotificationLevel", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(['string', 'number', 'boolean', 'object', declarativeTypeValidator.literal(null)]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], Conversation.prototype, "updateAttributes", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(['string']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], Conversation.prototype, "updateFriendlyName", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync([declarativeTypeValidator.literal(null), declarativeTypeValidator.nonNegativeInteger]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", Promise)
], Conversation.prototype, "updateLastReadMessageIndex", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(['string', declarativeTypeValidator.literal(null)]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], Conversation.prototype, "updateUniqueName", null);

class Deferred {
    constructor() {
        this._promise = new Promise((resolve, reject) => {
            this._resolve = resolve;
            this._reject = reject;
        });
    }
    get promise() { return this._promise; }
    update(value) {
        this._resolve(value);
    }
    set(value) {
        this.current = value;
        this._resolve(value);
    }
    fail(e) {
        this._reject(e);
    }
}

const log$2 = Logger.scope('Conversations');
/**
 * Represents conversations collection
 * {@see Conversation}
 */
class Conversations extends replayEventEmitter.ReplayEventEmitter {
    constructor(configuration, services) {
        super();
        this.conversations = new Map();
        this.myConversationsRead = new Deferred();
        this.tombstones = new Set();
        this.myConversationsFetched = false;
        this.configuration = configuration;
        this.services = services;
    }
    async addConversation(options) {
        var _a, _b, _c;
        const attributes = typeof (options === null || options === void 0 ? void 0 : options.attributes) !== 'undefined'
            ? options.attributes
            : {};
        const response = await this.services.commandExecutor.mutateResource('post', this.configuration.links.conversations, {
            friendly_name: options.friendlyName,
            unique_name: options.uniqueName,
            attributes: typeof attributes !== 'undefined' ? JSON.stringify(attributes) : undefined
        });
        const conversationSid = (_a = response.sid) !== null && _a !== void 0 ? _a : null;
        const conversationDocument = (_c = (_b = response.sync_objects) === null || _b === void 0 ? void 0 : _b.conversation) !== null && _c !== void 0 ? _c : null;
        const links = Object.assign({ self: response.url }, response.links);
        const existingConversation = this.conversations.get(conversationSid);
        if (existingConversation) {
            await existingConversation._subscribe();
            return existingConversation;
        }
        const conversation = new Conversation({
            channel: conversationDocument,
            entityName: null,
            uniqueName: null,
            attributes: null,
            createdBy: null,
            friendlyName: null,
            lastConsumedMessageIndex: null,
            dateCreated: null,
            dateUpdated: null
        }, conversationSid, links, this.configuration, this.services);
        this.conversations.set(conversation.sid, conversation);
        this._registerForEvents(conversation);
        await conversation._subscribe();
        this.emit('conversationAdded', conversation);
        return conversation;
    }
    /**
     * Fetch conversations list and instantiate all necessary objects
     */
    async fetchConversations() {
        try {
            const map = await this._getMap();
            map.on('itemAdded', args => {
                log$2.debug(`itemAdded: ${args.item.key}`);
                this._upsertConversation('sync', args.item.key, args.item.data);
            });
            map.on('itemRemoved', args => {
                log$2.debug(`itemRemoved: ${args.key}`);
                const sid = args.key;
                if (!this.myConversationsFetched) {
                    this.tombstones.add(sid);
                }
                const conversation = this.conversations.get(sid);
                if (!conversation) {
                    return;
                }
                if (conversation.status === 'joined') {
                    conversation._setStatus('notParticipating', 'sync');
                    this.emit('conversationLeft', conversation);
                }
                this.conversations.delete(sid);
                this.emit('conversationRemoved', conversation);
                conversation.emit('removed', conversation);
            });
            map.on('itemUpdated', args => {
                log$2.debug(`itemUpdated: ${args.item.key}`);
                this._upsertConversation('sync', args.item.key, args.item.data);
            });
            const myConversations = await this._fetchMyConversations();
            const upserts = [];
            for (const conversation of myConversations) {
                upserts.push(this._upsertConversation('rest', conversation.channel_sid, conversation));
            }
            this.myConversationsRead.set(true);
            await Promise.all(upserts);
            this.myConversationsFetched = true;
            this.tombstones.clear();
            log$2.debug('The conversations list has been successfully fetched');
            return this;
        }
        catch (error) {
            const errorMessage = 'Failed to fetch the conversations list';
            if (this.services.syncClient.connectionState !== 'disconnected') {
                log$2.error(errorMessage, error);
            }
            log$2.debug(`ERROR: ${errorMessage}`, error);
            throw error;
        }
    }
    async getConversations(args) {
        const conversationsMap = await this._getMap();
        const page = await conversationsMap.getItems();
        return this._wrapPaginator(page, items => Promise.all(items.map((item) => this._upsertConversation('sync', item.key, item.data))));
    }
    async getConversation(sid) {
        const conversationsMap = await this._getMap();
        const page = await conversationsMap.getItems({ from: sid });
        const items = page.items.map((item) => this._upsertConversation('sync', item.key, item.data));
        return items.length > 0 ? items[0] : null;
    }
    async getConversationByUniqueName(uniqueName) {
        const url = new UriBuilder(this.configuration.links.myConversations)
            .path(uniqueName)
            .build();
        const response = await this.services.network.get(url);
        const body = response.body;
        const sid = body.conversation_sid;
        const data = {
            entityName: null,
            lastConsumedMessageIndex: body.last_read_message_index,
            status: (body === null || body === void 0 ? void 0 : body.status) || 'unknown',
            friendlyName: body.friendly_name,
            dateUpdated: body.date_updated,
            dateCreated: body.date_created,
            uniqueName: body.unique_name,
            createdBy: body.created_by,
            attributes: body.attributes,
            channel: body.sync_objects.conversation,
            notificationLevel: body === null || body === void 0 ? void 0 : body.notification_level,
            sid
        };
        return this._upsertConversation('sync', sid, data);
    }
    async peekConversation(sid) {
        const url = new UriBuilder(this.configuration.links.conversations)
            .path(sid)
            .build();
        const response = await this.services.network.get(url);
        const body = response.body;
        const data = {
            entityName: null,
            // lastConsumedMessageIndex: body.last_read_message_index,
            status: (body === null || body === void 0 ? void 0 : body.status) || 'unknown',
            friendlyName: body.friendly_name,
            dateUpdated: body.date_updated,
            dateCreated: body.date_created,
            uniqueName: body.unique_name,
            createdBy: body.created_by,
            attributes: body.attributes,
            channel: `${sid}.channel`,
            // notificationLevel: body?.notification_level,
            sid
        };
        return this._upsertConversation('sync', sid, data);
    }
    async _getMap() {
        return await this.services.syncClient.map({
            id: this.configuration.myConversations,
            mode: 'open_existing'
        });
    }
    async _wrapPaginator(page, op) {
        const items = await op(page.items);
        return {
            items,
            hasNextPage: page.hasNextPage,
            hasPrevPage: page.hasPrevPage,
            nextPage: () => page.nextPage().then(x => this._wrapPaginator(x, op)),
            prevPage: () => page.prevPage().then(x => this._wrapPaginator(x, op))
        };
    }
    async _updateConversation(source, conversation, data) {
        const areSourcesDifferent = conversation._statusSource() !== undefined && source !== conversation._statusSource();
        const isChannelSourceSync = source !== 'rest' || conversation._statusSource() === 'sync';
        if (areSourcesDifferent && isChannelSourceSync && source !== 'sync') {
            log$2.trace('upsertConversation: conversation is known from sync and came from chat, ignoring', {
                sid: conversation.sid,
                data: data.status,
                conversation: conversation.status
            });
            return;
        }
        if (data.status === 'joined' && conversation.status !== 'joined') {
            conversation._setStatus('joined', source);
            let updateData = {};
            if (typeof data.notificationLevel !== 'undefined') {
                updateData.notificationLevel = data.notificationLevel;
            }
            if (typeof data.lastConsumedMessageIndex !== 'undefined') {
                updateData.lastConsumedMessageIndex = data.lastConsumedMessageIndex;
            }
            if (!isDeepEqual(updateData, {})) {
                conversation._update(updateData);
            }
            conversation._subscribe().then(() => {
                this.emit('conversationJoined', conversation);
            });
            return;
        }
        if (data.status === 'notParticipating' && conversation.status === 'joined') {
            conversation._setStatus('notParticipating', source);
            conversation._update(data);
            await conversation._subscribe();
            this.emit('conversationLeft', conversation);
            return;
        }
        if (data.status === 'notParticipating') {
            await conversation._subscribe();
            return;
        }
        conversation._update(data);
    }
    async _upsertConversation(source, sid, data) {
        log$2.trace(`upsertConversation called for ${sid}`, data);
        const conversation = this.conversations.get(sid);
        // If the channel is known, update it
        if (conversation) {
            log$2.trace(`upsertConversation: the conversation ${conversation.sid} is known;` +
                `its status is known from the source ${conversation._statusSource()} ` +
                `and the update came from the source ${source}`, conversation);
            await this._updateConversation(source, conversation, data);
            await conversation._subscribe();
            return conversation;
        }
        // If the conversations is deleted, ignore it
        if (['chat', 'rest'].includes(source) && this.tombstones.has(sid)) {
            log$2.trace('upsertChannel: the channel is deleted but reappeared again from chat, ignoring', sid);
            return;
        }
        // If the conversation is unknown, fetch it
        log$2.trace('upsertConversation: creating a local conversation object with sid ' + sid, data);
        const baseLink = `${this.configuration.links.conversations}/${sid}`;
        const links = {
            self: baseLink,
            messages: `${baseLink}/Messages`,
            participants: `${baseLink}/Participants`
        };
        const newConversation = new Conversation(data, sid, links, this.configuration, this.services);
        this.conversations.set(sid, newConversation);
        await newConversation._subscribe();
        this._registerForEvents(newConversation);
        this.emit('conversationAdded', newConversation);
        if (data.status === 'joined') {
            newConversation._setStatus('joined', source);
            this.emit('conversationJoined', newConversation);
        }
        return newConversation;
    }
    async _fetchMyConversations() {
        let conversations = [];
        let pageToken = null;
        do {
            const url = new UriBuilder(this.configuration.links.myConversations);
            if (pageToken) {
                url.arg('PageToken', pageToken);
            }
            const response = await this.services.network.get(url.build());
            const receivedConversations = response.body.conversations.map((conversationDescriptor) => ({
                descriptor: conversationDescriptor,
                channel_sid: conversationDescriptor.conversation_sid,
                status: conversationDescriptor.status,
                channel: conversationDescriptor.sync_objects.conversation,
                messages: conversationDescriptor.sync_objects.messages,
                roster: `${conversationDescriptor.conversation_sid}.roster`,
                lastConsumedMessageIndex: conversationDescriptor.last_consumed_message_index,
                notificationLevel: conversationDescriptor.notification_level
            }));
            pageToken = response.body.meta.next_token;
            conversations = [...conversations, ...receivedConversations];
        } while (pageToken);
        return conversations;
    }
    _onConversationRemoved(sid) {
        const conversation = this.conversations.get(sid);
        if (conversation) {
            this.conversations.delete(sid);
            this.emit('conversationRemoved', conversation);
        }
    }
    _registerForEvents(conversation) {
        conversation.on('removed', () => this._onConversationRemoved(conversation.sid));
        conversation.on('updated', (args) => this.emit('conversationUpdated', args));
        conversation.on('participantJoined', this.emit.bind(this, 'participantJoined'));
        conversation.on('participantLeft', this.emit.bind(this, 'participantLeft'));
        conversation.on('participantUpdated', (args) => this.emit('participantUpdated', args));
        conversation.on('messageAdded', this.emit.bind(this, 'messageAdded'));
        conversation.on('messageUpdated', (args) => this.emit('messageUpdated', args));
        conversation.on('messageRemoved', this.emit.bind(this, 'messageRemoved'));
        conversation.on('typingStarted', this.emit.bind(this, 'typingStarted'));
        conversation.on('typingEnded', this.emit.bind(this, 'typingEnded'));
    }
}

/**
 * Container for known users
 */
class Users extends replayEventEmitter.ReplayEventEmitter {
    constructor(myself, configuration, services) {
        super();
        this.configuration = configuration;
        this.services = services;
        this.fifoStack = [];
        this.myself = myself;
        this.myself.on('updated', (args) => this.emit('userUpdated', args));
        this.myself.on('userSubscribed', () => this.emit('userSubscribed', this.myself));
        this.myself.on('userUnsubscribed', () => {
            this.emit('userUnsubscribed', this.myself);
            this.myself._ensureFetched();
        });
        this.subscribedUsers = new Map();
    }
    handleUnsubscribeUser(user) {
        if (this.subscribedUsers.has(user.identity)) {
            this.subscribedUsers.delete(user.identity);
        }
        let foundItemIndex = -1;
        let foundItem = this.fifoStack.find((item, index) => {
            if (item == user.identity) {
                foundItemIndex = index;
                return true;
            }
            return false;
        });
        if (foundItem) {
            this.fifoStack.splice(foundItemIndex, 1);
        }
        this.emit('userUnsubscribed', user);
    }
    handleSubscribeUser(user) {
        if (this.subscribedUsers.has(user.identity)) {
            return;
        }
        if (this.fifoStack.length >= this.configuration.userInfosToSubscribe) {
            this.subscribedUsers.get(this.fifoStack.shift()).unsubscribe();
        }
        this.fifoStack.push(user.identity);
        this.subscribedUsers.set(user.identity, user);
        this.emit('userSubscribed', user);
    }
    /**
     * Gets user, if it's in subscribed list - then return the user object from it,
     * if not - then subscribes and adds user to the FIFO stack
     * @returns {Promise<User>} Fully initialized user
     */
    async getUser(identity, entityName = null) {
        await this.myself._ensureFetched();
        if (identity == this.myself.identity) {
            return this.myself;
        }
        let user = this.subscribedUsers.get(identity);
        if (!user) {
            if (!entityName) {
                entityName = await this.getSyncUniqueName(identity);
            }
            user = new User(identity, entityName, this.configuration, this.services);
            user.on('updated', (args) => this.emit('userUpdated', args));
            user.on('userSubscribed', () => this.handleSubscribeUser(user));
            user.on('userUnsubscribed', () => this.handleUnsubscribeUser(user));
            await user._ensureFetched();
        }
        return user;
    }
    /**
     * @returns {Promise<Array<User>>} returns list of subscribed User objects {@see User}
     */
    async getSubscribedUsers() {
        await this.myself._ensureFetched();
        const users = [this.myself];
        this.subscribedUsers.forEach((user) => users.push(user));
        return users;
    }
    /**
     * @returns {Promise<string>} User's sync unique name
     */
    async getSyncUniqueName(identity) {
        const url = new UriBuilder(this.configuration.links.users)
            .path(identity)
            .build();
        const response = await this.services.network.get(url);
        return response.body.sync_objects.user_info_map;
    }
}

const log$1 = Logger.scope('TypingIndicator');
/**
 * An important note in regards to typing timeout timers. There are two places that the SDK can get the "typing_timeout" attribute from. The first
 * place that the attribute appears in is the response received from POST -> /v1/typing REST call. In the body of that response, the value of the
 * "typing_timeout" attribute will be exactly the same as defined in the console. The second place that the attribute appears in is from a
 * notification of type "twilio.ipmsg.typing_indicator". In this case, the "typing_timeout" value will be +1 of that in the console. This
 * intentional. The timeout returned from the POST -> /v1/typing call should be used to disable further calls for that period of time. On contrary,
 * the timeout returned from the notification should be used as the timeout for the "typingEnded" event, +1 is to account for latency.
 *
 * @private
 */
/**
 * @class TypingIndicator
 *
 * @constructor
 * @private
 */
class TypingIndicator {
    constructor(getConversation, config, services) {
        this.configuration = config;
        this.services = services;
        this.getConversation = getConversation;
        this.serviceTypingTimeout = null;
        this.sentUpdates = new Map();
    }
    get typingTimeout() {
        return this.configuration.typingIndicatorTimeoutOverride
            || this.serviceTypingTimeout
            || this.configuration.typingIndicatorTimeoutDefault;
    }
    /**
     * Initialize TypingIndicator controller
     * Registers for needed message types and sets listeners
     * @private
     */
    initialize() {
        // this.services.notificationClient.subscribe(NotificationTypes.TYPING_INDICATOR, 'twilsock');
        this.services.notificationClient.on('message', async (type, message) => {
            if (type === NotificationTypes.TYPING_INDICATOR) {
                await this._handleRemoteTyping(message);
            }
        });
    }
    /**
     * Remote participants typing events handler
     */
    async _handleRemoteTyping(message) {
        log$1.trace('Got new typing indicator ', message);
        this.getConversation(message.channel_sid)
            .then(conversation => {
            if (!conversation) {
                return;
            }
            conversation.participants.forEach(participant => {
                if (participant.identity !== message.identity) {
                    return;
                }
                const timeout = this.configuration.typingIndicatorTimeoutOverride + 1000 || message.typing_timeout * 1000;
                participant._startTyping(timeout);
            });
        })
            .catch(err => {
            log$1.error(err);
            throw err;
        });
    }
    /**
     * Send typing event for the given conversation sid
     * @param {String} conversationSid
     */
    send(conversationSid) {
        const lastUpdate = this.sentUpdates.get(conversationSid);
        if (lastUpdate && lastUpdate > (Date.now() - this.typingTimeout)) {
            return Promise.resolve();
        }
        this.sentUpdates.set(conversationSid, Date.now());
        return this._send(conversationSid);
    }
    _send(conversationSid) {
        log$1.trace('Sending typing indicator');
        const url = this.configuration.links.typing;
        const headers = {
            'Content-Type': 'application/x-www-form-urlencoded'
        };
        const body = `ChannelSid=${conversationSid}`;
        return (this.services.twilsockClient.post(url, headers, body, this.configuration.productId)
            .then((response) => {
            if (response.body.hasOwnProperty('typing_timeout')) {
                this.serviceTypingTimeout = response.body.typing_timeout * 1000;
            }
        })
            .catch((err) => {
            log$1.error('Failed to send typing indicator:', err);
            throw err;
        }));
    }
}

/**
 * Push notification for a Conversations client.
 */
class PushNotification {
    /**
     * @internal
     */
    constructor(data) {
        this.title = data.title || null;
        this.body = data.body || null;
        this.sound = data.sound || null;
        this.badge = data.badge || null;
        this.action = data.action || null;
        this.type = data.type || null;
        this.data = data.data || {};
    }
}

var version = "2.0.0";

const trimSlashes = (url) => url.replace(/(^\/+|\/+$)/g, '');
const isMutationConflictResponse = (response) => response.status.code === 202;
class CommandExecutor {
    constructor(_serviceUrl, _services, _productId) {
        this._serviceUrl = _serviceUrl;
        this._services = _services;
        this._productId = _productId;
    }
    _preProcessUrl(url) {
        const trimmedUrl = trimSlashes(url);
        if (/^https?:\/\//.test(url)) {
            return trimmedUrl;
        }
        return `${trimSlashes(this._serviceUrl)}/${trimmedUrl}`;
    }
    async _makeRequest(method, url, requestBody, headers) {
        const preProcessedUrl = this._preProcessUrl(url);
        const finalHeaders = Object.assign({ 'Content-Type': 'application/json; charset=utf-8' }, (headers || {}));
        let response;
        switch (method) {
            case 'get':
                let getUrl = preProcessedUrl;
                if (requestBody) {
                    getUrl +=
                        '?' +
                            Object.entries(requestBody)
                                .map((entry) => entry.map(encodeURIComponent).join('='))
                                .join('&');
                }
                response = await this._services.transport.get(getUrl, finalHeaders, this._productId);
                break;
            case 'post':
                response = await this._services.transport.post(preProcessedUrl, finalHeaders, JSON.stringify(requestBody), this._productId);
                break;
            case 'delete':
                response = await this._services.transport.delete(preProcessedUrl, finalHeaders, null, this._productId);
                break;
        }
        if (response.status.code < 200 || response.status.code >= 300) {
            throw new Error(`Request responded with a non-success code ${response.status.code}`);
        }
        return response;
    }
    async fetchResource(url, requestBody) {
        const maxAttemptsCount = 6;
        let result;
        try {
            result = await new operationRetrier.AsyncRetrier({ min: 50, max: 1600, maxAttemptsCount })
                .run(() => this._makeRequest('get', url, requestBody));
        }
        catch (_a) {
            throw new Error(`Fetch resource from "${url}" failed.`);
        }
        return result.body;
    }
    async mutateResource(method, url, requestBody) {
        const result = await this._makeRequest(method, url, requestBody, {
            'X-Twilio-Mutation-Id': uuid.v4()
        });
        if (isMutationConflictResponse(result)) {
            return await this.fetchResource(result.body.resource_url);
        }
        return result.body;
    }
}

var Client_1;
const log = Logger.scope('Client');
const SDK_VERSION = version;
class ClientServices {
}
/**
 * A client is the starting point to the Twilio Conversations functionality.
 */
exports.Client = Client_1 = class Client extends replayEventEmitter.ReplayEventEmitter {
    /**
     * Returned Conversations instance is not yet fully initialized. Calling any operations will block until it is.
     * Use connection events to monitor when client becomes fully available (connectionStateChanged with state
     * 'connected') or not available (connectionStateChange with state 'denied', event tokenExpired, event connectionError).
     *
     * @param fpaToken Access token
     * @param options Options to customize the Client
     * @returns A not yet fully-initialized client.
     */
    constructor(fpaToken, options = {}) {
        var _a, _b, _c, _d, _e;
        super();
        /**
         * Client connection state.
         */
        this.connectionState = 'unknown';
        this.conversationsPromise = null;
        this._ensureReady = null;
        this._resolveEnsureReady = null;
        this._rejectEnsureReady = null;
        /**
         * Current version of the Conversations client.
         */
        this.version = SDK_VERSION;
        this.parsePushNotification = Client_1.parsePushNotification;
        this.fpaToken = fpaToken;
        this.options = options;
        if (!this.options.disableDeepClone) {
            let options = Object.assign(Object.assign({}, this.options), { transport: undefined, twilsockClient: undefined });
            options = deepClone(options);
            options.transport = this.options.transport;
            options.twilsockClient = this.options.twilsockClient;
            this.options = options;
        }
        this.options.logLevel = (_a = this.options.logLevel) !== null && _a !== void 0 ? _a : 'silent';
        log.setLevel(this.options.logLevel);
        const productId = this.options.productId = 'ip_messaging';
        // Filling ClientMetadata
        this.options.clientMetadata = this.options.clientMetadata || {};
        if (!this.options.clientMetadata.hasOwnProperty('type')) {
            this.options.clientMetadata.type = 'conversations';
        }
        if (!this.options.clientMetadata.hasOwnProperty('sdk')) {
            this.options.clientMetadata.sdk = 'JS';
            this.options.clientMetadata.sdkv = SDK_VERSION;
        }
        // Enable session local storage for Sync
        this.options.Sync = this.options.Sync || {};
        if (typeof this.options.Sync.enableSessionStorage === 'undefined') {
            this.options.Sync.enableSessionStorage = true;
        }
        if (this.options.region) {
            this.options.Sync.region = this.options.region;
        }
        if (!fpaToken) {
            throw new Error('A valid Twilio token should be provided');
        }
        this.services = new ClientServices();
        this._myself = new User('', '', null, this.services);
        const startTwilsock = !this.options.twilsockClient;
        // Create default init registrations if none were provided.
        // Otherwise, the outside party have to list all the init registrations they
        // need.
        // Init registrations passed to the Conversations client will be passed down
        // to the Sync client as well.
        if (!this.options.initRegistrations) {
            const initRegistration = new twilsock.InitRegistration(productId);
            Client_1.populateInitRegistrations(initRegistration);
            this.options.initRegistrations = [initRegistration];
        }
        this.services.twilsockClient = (this.options.twilsockClient = (_b = this.options.twilsockClient) !== null && _b !== void 0 ? _b : new twilsock.TwilsockClient(fpaToken, productId, this.options));
        this.services.twilsockClient.on('tokenAboutToExpire', ttl => this.emit('tokenAboutToExpire', ttl));
        this.services.twilsockClient.on('tokenExpired', () => this.emit('tokenExpired'));
        this.services.twilsockClient.on('connectionError', (error) => this.emit('connectionError', error));
        this.services.twilsockClient.on('stateChanged', (state) => {
            log.debug(`Handling stateChanged for ConversationsClient: new state ${state}`);
            if (state !== this.connectionState) {
                this.connectionState = state;
                this.emit('connectionStateChanged', this.connectionState);
            }
        });
        this.services.transport = (this.options.transport = ((_c = this.options.transport) !== null && _c !== void 0 ? _c : this.options.twilsockClient));
        this.services.notificationClient = (this.options.notificationsClient = (_d = this.options.notificationsClient) !== null && _d !== void 0 ? _d : new notifications.Notifications(fpaToken, this.options));
        this.services.syncClient = (this.options.syncClient = (_e = this.options.syncClient) !== null && _e !== void 0 ? _e : new twilioSync.SyncClient(fpaToken, this.options));
        const configurationOptions = options.Chat || options.IPMessaging || options || {};
        const region = configurationOptions.region || options.region;
        const baseUrl = configurationOptions.apiUri
            || configurationOptions.typingUri
            || `https://aim.${region || 'us1'}.twilio.com`;
        this.services.commandExecutor = new CommandExecutor(baseUrl, { transport: this.options.transport }, productId);
        const emitFailed = (err) => {
            this._rejectEnsureReady(err);
            this.emit('stateChanged', 'failed');
        };
        this.services.twilsockClient.once('connectionError', emitFailed);
        this.services.twilsockClient.once('disconnected', emitFailed);
        // ConversationsClient will be able to initialize only after twilsock is connected
        this.services.twilsockClient.once('connected', async () => {
            log.debug(`ConversationsClient started INITIALIZING`);
            this.services.twilsockClient.off('connectionError', emitFailed);
            this.services.twilsockClient.off('disconnected', emitFailed);
            try {
                const startupEvent = 'conversations.client.startup';
                this.services.twilsockClient.addPartialTelemetryEvent(new twilsock.TelemetryEventDescription(startupEvent, 'Conversations client startup', new Date()), startupEvent, twilsock.TelemetryPoint.Start);
                await this._initialize();
                this.services.twilsockClient.addPartialTelemetryEvent(new twilsock.TelemetryEventDescription('', '', new Date()), startupEvent, twilsock.TelemetryPoint.End);
            }
            catch (err) {
                // Fail ChatClient if initialization is incomplete
                this._rejectEnsureReady(err);
                this.emit('stateChanged', 'failed');
            }
        });
        this._ensureReady = new Promise((resolve, reject) => {
            this._resolveEnsureReady = resolve;
            this._rejectEnsureReady = reject;
        }).catch((err) => { }); // @todo How to process unhandled rejection here?
        if (startTwilsock) {
            this.services.twilsockClient.connect();
        }
    }
    static populateInitRegistrations(reg) {
        reg.populateInitRegistrations([NotificationTypes.TYPING_INDICATOR]);
        twilioSync.SyncClient.populateInitRegistrations(reg);
    }
    /**
     * @deprecated Call constructor directly.
     *
     * Factory method to create a Conversations client instance.
     *
     * The factory method will automatically trigger connection.
     * Do not use it if you need finer-grained control.
     *
     * Since this method returns an already-initialized client, some of the events
     * will be lost because they happen *before* the initialization. It is
     * recommended that `client.onWithReplay` is used as opposed to `client.on`
     * for subscribing to client events. The `client.onWithReplay` will re-emit
     * the most recent value for a given event if it emitted before the
     * subscription.
     *
     * @param token Access token.
     * @param options Options to customize the client.
     * @returns Returns a fully initialized client.
     */
    static async create(token, options) {
        // The logic is as follows:
        // - If twilsock is not passed in, then the ConversationsClient constructor will call twilsock.connect() by itself
        //   and we do not need to do it here.
        // - If twilsock was passed in from the outside, but customer called ConversationsClient.create() then they are
        //   using an obsolete workflow and the startup sequence will never complete.
        if (options === null || options === void 0 ? void 0 : options.twilsockClient) {
            throw new Error('Obsolete usage of ConversationsClient.create() ' +
                'factory method: if you pass twilsock from the outside then you must ' +
                'use ConversationsClient constructor and be prepared to work with ' +
                'uninitialized client.');
        }
        const client = new Client_1(token, options);
        await client._ensureReady;
        return client;
    }
    /**
     * Information of the logged-in user. Before client initialization, returns an
     * uninitialized user. Will trigger a {@link Client.userUpdated} event after
     * initialization.
     */
    get user() { return this._myself; }
    /**
     * Client reachability state. Throws if accessed before the client
     * initialization was completed.
     */
    get reachabilityEnabled() {
        if (!this.configuration) {
            throw new Error('Reachability information could not yet be accessed as the client ' +
                "has not yet been initialized. Subscribe to the 'stateChanged' event " +
                'to properly react to the client initialization.');
        }
        return this.configuration.reachabilityEnabled;
    }
    get token() { return this.fpaToken; }
    _subscribeToPushNotifications(channelType) {
        [NotificationTypes.NEW_MESSAGE,
            NotificationTypes.ADDED_TO_CONVERSATION,
            NotificationTypes.REMOVED_FROM_CONVERSATION,
            NotificationTypes.TYPING_INDICATOR,
            NotificationTypes.CONSUMPTION_UPDATE]
            .forEach(messageType => {
            this.services.notificationClient.subscribe(channelType, messageType);
        });
    }
    _unsubscribeFromPushNotifications(channelType) {
        [NotificationTypes.NEW_MESSAGE,
            NotificationTypes.ADDED_TO_CONVERSATION,
            NotificationTypes.REMOVED_FROM_CONVERSATION,
            NotificationTypes.TYPING_INDICATOR,
            NotificationTypes.CONSUMPTION_UPDATE]
            .forEach(messageType => {
            this.services.notificationClient.unsubscribe(channelType, messageType);
        });
    }
    async _initialize() {
        const configurationResponse = await this.services.commandExecutor.fetchResource('Client/v2/Configuration');
        this.configuration = new Configuration(this.options, configurationResponse, log);
        this._myself._resolveInitialization(this.configuration, this.configuration.userIdentity, this.configuration.userInfo, true);
        this.services.typingIndicator = new TypingIndicator(this.getConversationBySid.bind(this), this.configuration, this.services);
        this.services.network = new Network(this.configuration, this.services);
        this.services.users = new Users(this._myself, this.configuration, this.services);
        this.services.users.on('userSubscribed', this.emit.bind(this, 'userSubscribed'));
        this.services.users.on('userUpdated', (args) => this.emit('userUpdated', args));
        this.services.users.on('userUnsubscribed', this.emit.bind(this, 'userUnsubscribed'));
        this.conversations = new Conversations(this.configuration, this.services);
        this.conversations.on('conversationAdded', this.emit.bind(this, 'conversationAdded'));
        this.conversations.on('conversationRemoved', this.emit.bind(this, 'conversationRemoved'));
        this.conversations.on('conversationJoined', this.emit.bind(this, 'conversationJoined'));
        this.conversations.on('conversationLeft', this.emit.bind(this, 'conversationLeft'));
        this.conversations.on('conversationUpdated', (args) => this.emit('conversationUpdated', args));
        this.conversations.on('participantJoined', this.emit.bind(this, 'participantJoined'));
        this.conversations.on('participantLeft', this.emit.bind(this, 'participantLeft'));
        this.conversations.on('participantUpdated', (args) => this.emit('participantUpdated', args));
        this.conversations.on('messageAdded', this.emit.bind(this, 'messageAdded'));
        this.conversations.on('messageUpdated', (args) => this.emit('messageUpdated', args));
        this.conversations.on('messageRemoved', this.emit.bind(this, 'messageRemoved'));
        this.conversations.on('typingStarted', this.emit.bind(this, 'typingStarted'));
        this.conversations.on('typingEnded', this.emit.bind(this, 'typingEnded'));
        this.conversationsPromise = this.conversations.fetchConversations()
            .then(() => this.conversations)
            .catch((error) => {
            throw error;
        });
        await this.services.users.myself._ensureFetched();
        Client_1.supportedPushChannels.forEach(channelType => this._subscribeToPushNotifications(channelType));
        this.services.typingIndicator.initialize();
        this.services.mcsClient = new mcsClient.McsClient(this.fpaToken, this.configuration.links.mediaService, this.configuration.links.mediaSetService, Object.assign(Object.assign({}, this.options), { transport: null }));
        this._resolveEnsureReady();
        this.emit('stateChanged', 'initialized');
    }
    /**
     * Gracefully shut down the client.
     */
    async shutdown() {
        await this._ensureReady;
        await this.services.twilsockClient.disconnect();
    }
    /**
     * Update the token used by the client and re-register with the Conversations services.
     * @param token New access token.
     */
    async updateToken(token) {
        await this._ensureReady;
        log.info('updateToken');
        if (this.fpaToken === token) {
            return this;
        }
        await this.services.twilsockClient.updateToken(token);
        await this.services.notificationClient.updateToken(token);
        await this.services.mcsClient.updateToken(token);
        this.fpaToken = token;
        return this;
    }
    /**
     * Get a known conversation by its SID.
     * @param conversationSid Conversation sid
     */
    async getConversationBySid(conversationSid) {
        await this._ensureReady;
        await this.conversations.myConversationsRead.promise;
        let conversation = await this.conversations.getConversation(conversationSid);
        if (!conversation) {
            conversation = await this.conversations.peekConversation(conversationSid);
        }
        if (!conversation) {
            throw new Error(`Conversation with SID ${conversationSid} is not found.`);
        }
        return conversation;
    }
    /**
     * Get a known conversation by its unique identifier name.
     * @param uniqueName The unique identifier name of the conversation.
     */
    async getConversationByUniqueName(uniqueName) {
        await this._ensureReady;
        await this.conversations.myConversationsRead.promise;
        const conversation = await this.conversations.getConversationByUniqueName(uniqueName);
        if (!conversation) {
            throw new Error(`Conversation with unique name ${uniqueName} is not found.`);
        }
        return conversation;
    }
    /**
     * Get the current list of all the subscribed conversations.
     */
    async getSubscribedConversations(args) {
        await this._ensureReady;
        return this.conversationsPromise.then(conversations => conversations.getConversations(args));
    }
    /**
     * Create a conversation on the server and subscribe to its events.
     * The default is a conversation with an empty friendly name.
     * @param options Options for the conversation.
     */
    async createConversation(options) {
        await this._ensureReady;
        options = options || {};
        return this.conversationsPromise.then(conversationsEntity => conversationsEntity.addConversation(options));
    }
    /**
     * Register for push notifications.
     * @param channelType Channel type.
     * @param registrationId Push notification ID provided by the FCM/APNS service on the platform.
     */
    async setPushRegistrationId(channelType, registrationId) {
        await this._ensureReady;
        this._subscribeToPushNotifications(channelType);
        this.services.notificationClient.setPushRegistrationId(channelType, registrationId);
        await this.services.notificationClient.commitChanges(); // Committing before this point is useless because we have no push id
    }
    /**
     * Unregister from push notifications.
     * @param channelType Channel type.
     * @deprecated Use removePushRegistrations() instead.
     */
    async unsetPushRegistrationId(channelType) {
        await this._ensureReady;
        this._unsubscribeFromPushNotifications(channelType);
        await this.services.notificationClient.commitChanges();
    }
    /**
     * Clear existing registrations directly using provided device token.
     * This is useful to ensure stopped subscriptions without resubscribing.
     *
     * This function goes completely beside the state machine and removes all registrations.
     * Use with caution: if it races with current state machine operations, madness will ensue.
     *
     * @param channelType Channel type.
     * @param registrationId Push notification ID provided by the FCM/APNS service on the platform.
     */
    async removePushRegistrations(channelType, registrationId) {
        // do not await this._ensureReady() here - it could be called at any moment
        await this.services.notificationClient.removeRegistrations(channelType, registrationId);
    }
    static parsePushNotificationChatData(data) {
        const result = {};
        for (let key in Client_1.supportedPushDataFields) {
            if (typeof data[key] === 'undefined' || data[key] === null) {
                continue;
            }
            if (key !== 'message_index') {
                result[Client_1.supportedPushDataFields[key]] = data[key];
                continue;
            }
            if (parseToNumber(data[key]) !== null) {
                result[Client_1.supportedPushDataFields[key]] = Number(data[key]);
            }
        }
        return result;
    }
    /**
     * Static method for push notification payload parsing. Returns parsed push as a {@link PushNotification} object.
     * @param notificationPayload Push notification payload.
     */
    static parsePushNotification(notificationPayload) {
        log.debug('parsePushNotification, notificationPayload=', notificationPayload);
        // APNS specifics
        if (typeof notificationPayload.aps !== 'undefined') {
            if (!notificationPayload.twi_message_type) {
                throw new Error('Provided push notification payload does not contain Programmable Chat push notification type');
            }
            let data = Client_1.parsePushNotificationChatData(notificationPayload);
            let apsPayload = notificationPayload.aps;
            let body = null;
            let title = null;
            if (typeof apsPayload.alert === 'string') {
                body = apsPayload.alert || null;
            }
            else {
                body = apsPayload.alert.body || null;
                title = apsPayload.alert.title || null;
            }
            return new PushNotification({
                title: title,
                body: body,
                sound: apsPayload.sound || null,
                badge: apsPayload.badge || null,
                action: apsPayload.category || null,
                type: notificationPayload.twi_message_type,
                data: data
            });
        }
        // FCM specifics
        if (typeof notificationPayload.data !== 'undefined') {
            let dataPayload = notificationPayload.data;
            if (!dataPayload.twi_message_type) {
                throw new Error('Provided push notification payload does not contain Programmable Chat push notification type');
            }
            let data = Client_1.parsePushNotificationChatData(notificationPayload.data);
            return new PushNotification({
                title: dataPayload.twi_title || null,
                body: dataPayload.twi_body || null,
                sound: dataPayload.twi_sound || null,
                badge: null,
                action: dataPayload.twi_action || null,
                type: dataPayload.twi_message_type,
                data: data
            });
        }
        throw new Error('Provided push notification payload is not Programmable Chat notification');
    }
    /**
     * Handle push notification payload parsing and emit the {@link Client.pushNotification} event on this {@link Client} instance.
     * @param notificationPayload Push notification payload
     */
    async handlePushNotification(notificationPayload) {
        await this._ensureReady;
        log.debug('handlePushNotification, notificationPayload=', notificationPayload);
        this.emit('pushNotification', Client_1.parsePushNotification(notificationPayload));
    }
    /**
     * Gets a user with the given identity. If it's in the subscribed list, then return the user object from it;
     * if not, then subscribe and add user to the subscribed list.
     * @param identity Identity of the user.
     * @returns A fully initialized user.
     */
    async getUser(identity) {
        await this._ensureReady;
        return this.services.users.getUser(identity);
    }
    /**
     * Get a list of subscribed user objects.
     */
    async getSubscribedUsers() {
        await this._ensureReady;
        return this.services.users.getSubscribedUsers();
    }
};
/**
 * Current version of the Conversations client.
 */
exports.Client.version = SDK_VERSION;
exports.Client.supportedPushChannels = ['fcm', 'apn'];
exports.Client.supportedPushDataFields = {
    'conversation_sid': 'conversationSid',
    'message_sid': 'messageSid',
    'message_index': 'messageIndex'
};
/**
 * Fired when a conversation becomes visible to the client. The event is also triggered when the client creates a new conversation.
 * Fired for all conversations client has joined.
 *
 * Parameters:
 * 1. {@link Conversation} `conversation` - the conversation in question
 * @event
 */
exports.Client.conversationAdded = 'conversationAdded';
/**
 * Fired when the client joins a conversation.
 *
 * Parameters:
 * 1. {@link Conversation} `conversation` - the conversation in question
 * @event
 */
exports.Client.conversationJoined = 'conversationJoined';
/**
 * Fired when the client leaves a conversation.
 *
 * Parameters:
 * 1. {@link Conversation} `conversation` - the conversation in question
 * @event
 */
exports.Client.conversationLeft = 'conversationLeft';
/**
 * Fired when a conversation is no longer visible to the client.
 *
 * Parameters:
 * 1. {@link Conversation} `conversation` - the conversation in question
 * @event
 */
exports.Client.conversationRemoved = 'conversationRemoved';
/**
 * Fired when the attributes or the metadata of a conversation have been updated.
 * During conversation's creation and initialization, this event might be fired multiple times
 * for same joined or created conversation as new data is arriving from different sources.
 *
 * Parameters:
 * 1. object `data` - info object provided with the event. It has the following properties:
 *     * {@link Conversation} `conversation` - the conversation in question
 *     * {@link ConversationUpdateReason}[] `updateReasons` - array of reasons for the update
 * @event
 */
exports.Client.conversationUpdated = 'conversationUpdated';
/**
 * Fired when a participant has joined a conversation.
 *
 * Parameters:
 * 1. {@link Participant} `participant` - the participant in question
 * @event
 */
exports.Client.participantJoined = 'participantJoined';
/**
 * Fired when a participant has left a conversation.
 *
 * Parameters:
 * 1. {@link Participant} `participant` - the participant in question
 * @event
 */
exports.Client.participantLeft = 'participantLeft';
/**
 * Fired when a participant's fields have been updated.
 *
 * Parameters:
 * 1. object `data` - info object provided with the event. It has the following properties:
 *     * {@link Participant} `participant` - the participant in question
 *     * {@link ParticipantUpdateReason}[] `updateReasons` - array of reasons for the update
 * @event
 */
exports.Client.participantUpdated = 'participantUpdated';
/**
 * Fired when a new message has been added to the conversation on the server.
 *
 * Parameters:
 * 1. {@link Message} `message` - the message in question
 * @event
 */
exports.Client.messageAdded = 'messageAdded';
/**
 * Fired when a message is removed from the message list of a conversation.
 *
 * Parameters:
 * 1. {@link Message} `message` - the message in question
 * @event
 */
exports.Client.messageRemoved = 'messageRemoved';
/**
 * Fired when the fields of an existing message are updated with new values.
 *
 * Parameters:
 * 1. object `data` - info object provided with the event. It has the following properties:
 *     * {@link Message} `message` - the message in question
 *     * {@link MessageUpdateReason}[] `updateReasons` - array of reasons for the update
 * @event
 */
exports.Client.messageUpdated = 'messageUpdated';
/**
 * Fired when the token is about to expire and needs to be updated.
 * * Parameters:
 * 1. number `message` - token's time to live
 * @event
 */
exports.Client.tokenAboutToExpire = 'tokenAboutToExpire';
/**
 * Fired when the token has expired.
 * @event
 */
exports.Client.tokenExpired = 'tokenExpired';
/**
 * Fired when a participant has stopped typing.
 *
 * Parameters:
 * 1. {@link Participant} `participant` - the participant in question
 * @event
 */
exports.Client.typingEnded = 'typingEnded';
/**
 * Fired when a participant has started typing.
 *
 * Parameters:
 * 1. {@link Participant} `participant` - the participant in question
 * @event
 */
exports.Client.typingStarted = 'typingStarted';
/**
 * Fired when the client has received (and parsed) a push notification via one of the push channels (apn or fcm).
 *
 * Parameters:
 * 1. {@link PushNotification} `pushNotification` - the push notification in question
 * @event
 */
exports.Client.pushNotification = 'pushNotification';
/**
 * Fired when the client has subscribed to a user.
 *
 * Parameters:
 * 1. {@link User} `user` - the user in question
 * @event
 */
exports.Client.userSubscribed = 'userSubscribed';
/**
 * Fired when the client has unsubscribed from a user.
 *
 * Parameters:
 * 1. {@link User} `user` - the user in question
 * @event
 */
exports.Client.userUnsubscribed = 'userUnsubscribed';
/**
 * Fired when the properties or the reachability status of a user have been updated.
 *
 * Parameters:
 * 1. object `data` - info object provided with the event. It has the following properties:
 *     * {@link User} `user` - the user in question
 *     * {@link UserUpdateReason}[] `updateReasons` - array of reasons for the update
 * @event
 */
exports.Client.userUpdated = 'userUpdated';
/**
 * Fired when the state of the client has been changed.
 *
 * Parameters:
 * 1. {@link State} `state` - the new client state
 * @event
 */
exports.Client.stateChanged = 'stateChanged';
/**
 * Fired when the connection state of the client has been changed.
 *
 * Paremeters:
 * 1. {@link ConnectionState} `state` - the new connection state
 * @event
 */
exports.Client.connectionStateChanged = 'connectionStateChanged';
/**
 * Fired when the connection is interrupted for an unexpected reason.
 *
 * Parameters:
 * 1. object `data` - info object provided with the event. It has the following properties:
 *     * boolean `terminal` - Twilsock will stop connection attempts if true
 *     * string `message` - the error message of the root cause
 *     * number? `httpStatusCode` - http status code if available
 *     * number? `errorCode` - Twilio public error code if available
 * @event
 */
exports.Client.connectionError = 'connectionError';
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], exports.Client.prototype, "updateToken", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], exports.Client.prototype, "getConversationBySid", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], exports.Client.prototype, "getConversationByUniqueName", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync([
        'undefined',
        declarativeTypeValidator.objectSchema('conversation options', {
            friendlyName: ['string', 'undefined'],
            isPrivate: ['boolean', 'undefined'],
            uniqueName: ['string', 'undefined']
        })
    ]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], exports.Client.prototype, "createConversation", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.literal('fcm', 'apn'), 'string'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], exports.Client.prototype, "setPushRegistrationId", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.literal('fcm', 'apn')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], exports.Client.prototype, "unsetPushRegistrationId", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.literal('fcm', 'apn'), declarativeTypeValidator.nonEmptyString),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], exports.Client.prototype, "removePushRegistrations", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.pureObject),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], exports.Client.prototype, "handlePushNotification", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], exports.Client.prototype, "getUser", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync('string', ['undefined', declarativeTypeValidator.pureObject]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], exports.Client, "create", null);
__decorate([
    declarativeTypeValidator.validateTypes(declarativeTypeValidator.pureObject),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", PushNotification)
], exports.Client, "parsePushNotification", null);
exports.Client = Client_1 = __decorate([
    declarativeTypeValidator.validateConstructorTypes(declarativeTypeValidator.nonEmptyString, [
        declarativeTypeValidator.pureObject,
        'undefined'
    ]),
    __metadata("design:paramtypes", [String, Object])
], exports.Client);

exports.AggregatedDeliveryReceipt = AggregatedDeliveryReceipt;
exports.Conversation = Conversation;
exports.DetailedDeliveryReceipt = DetailedDeliveryReceipt;
exports.Media = Media;
exports.Message = Message;
exports.MessageBuilder = MessageBuilder;
exports.NotificationTypes = NotificationTypes;
exports.Participant = Participant;
exports.PushNotification = PushNotification;
exports.RestPaginator = RestPaginator;
exports.UnsentMessage = UnsentMessage;
exports.User = User;
//# sourceMappingURL=react-native.js.map
