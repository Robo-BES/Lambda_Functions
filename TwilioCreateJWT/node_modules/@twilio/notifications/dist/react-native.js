/*
@license
The MIT License (MIT)

Copyright (c) 2016 Twilio Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var twilsock = require('twilsock');
var operationRetrier = require('@twilio/operation-retrier');
var logger = require('loglevel');
var declarativeTypeValidator = require('@twilio/declarative-type-validator');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () {
                        return e[k];
                    }
                });
            }
        });
    }
    n['default'] = e;
    return Object.freeze(n);
}

var logger__namespace = /*#__PURE__*/_interopNamespace(logger);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

var domain;

// This constructor is used to store event handlers. Instantiating this is
// faster than explicitly calling `Object.create(null)` to get a "clean" empty
// object (tested with v8 v4.9).
function EventHandlers() {}
EventHandlers.prototype = Object.create(null);

function EventEmitter() {
  EventEmitter.init.call(this);
}

// nodejs oddity
// require('events') === require('events').EventEmitter
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.usingDomains = false;

EventEmitter.prototype.domain = undefined;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

EventEmitter.init = function() {
  this.domain = null;
  if (EventEmitter.usingDomains) {
    // if there is an active domain, then attach to it.
    if (domain.active ) ;
  }

  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers();
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events, domain;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  domain = this.domain;

  // If there is no 'error' event listener then throw.
  if (doError) {
    er = arguments[1];
    if (domain) {
      if (!er)
        er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain;
      er.domainThrown = false;
      domain.emit('error', er);
    } else if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] :
                                          [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
                            existing.length + ' ' + type + ' listeners added. ' +
                            'Use emitter.setMaxListeners() to increase limit');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }

  return target;
}
function emitWarning(e) {
  typeof console.warn === 'function' ? console.warn(e) : console.log(e);
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function _onceWrap(target, type, listener) {
  var fired = false;
  function g() {
    target.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || (list.listener && list.listener === listener)) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length; i-- > 0;) {
          if (list[i] === listener ||
              (list[i].listener && list[i].listener === listener)) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (list.length === 1) {
          list[0] = undefined;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };
    
// Alias for removeListener added in NodeJS 10.0
// https://nodejs.org/api/events.html#events_emitter_off_eventname_listener
EventEmitter.prototype.off = function(type, listener){
    return this.removeListener(type, listener);
};

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        for (var i = 0, key; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        do {
          this.removeListener(type, listeners[listeners.length - 1]);
        } while (listeners[0]);
      }

      return this;
    };

EventEmitter.prototype.listeners = function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;

  if (!events)
    ret = [];
  else {
    evlistener = events[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === 'function')
      ret = [evlistener.listener || evlistener];
    else
      ret = unwrapListeners(evlistener);
  }

  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, i) {
  var copy = new Array(i);
  while (i--)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

const log = logger__namespace.getLogger("twilio-notificatiions");
function prepareLine(prefix, args) {
    return [`${new Date().toISOString()} Twilio.Notifications ${prefix}:`].concat(Array.from(args));
}
class Logger {
    setLevel(level) {
        log.setLevel(level);
    }
    trace(...args) {
        log.trace.apply(null, prepareLine("T", args));
    }
    debug(...args) {
        log.debug.apply(null, prepareLine("D", args));
    }
    info(...args) {
        log.info.apply(null, prepareLine("I", args));
    }
    warn(...args) {
        log.warn.apply(null, prepareLine("W", args));
    }
    error(...args) {
        log.error.apply(null, prepareLine("E", args));
    }
}
const logInstance = new Logger();

class RegistrationState {
    constructor(token = "", notificationId = "", messageTypes = new Set()) {
        this.token = token;
        this.notificationId = notificationId;
        this.messageTypes = messageTypes;
    }
}
function setDifference(a, b) {
    return [
        ...[...a].filter((x) => !b.has(x)),
        ...[...b].filter((x) => !a.has(x)),
    ];
}
function hasDifference(a, b) {
    const reasons = new Set();
    if (a.notificationId !== b.notificationId) {
        reasons.add("notificationId");
    }
    if (a.token !== b.token) {
        reasons.add("token");
    }
    if (setDifference(a.messageTypes, b.messageTypes).length > 0) {
        reasons.add("messageType");
    }
    return [reasons.size > 0, reasons];
}
class Connector extends EventEmitter {
    constructor(channelType) {
        super();
        this.channelType = channelType;
        this.desiredState = new RegistrationState();
        this.currentState = new RegistrationState();
        this._hasActiveAttempt = false; // @todo replace with FSM
    }
    /**
     * Set desired notification ID for the registration.
     * Call commitChanges() afterwards to commit this change.
     * @param notificationId Notification context ID to register.
     */
    setNotificationId(notificationId) {
        this.desiredState.notificationId = notificationId;
    }
    /**
     * Return true is this connector is in usable state and should be able to commit changes.
     */
    isActive() {
        return this.desiredState.notificationId !== "";
    }
    subscribe(messageType) {
        if (this.desiredState.messageTypes.has(messageType)) {
            logInstance.debug(`message type '${messageType}' for channel ${this.channelType} is already registered`);
            return;
        }
        this.desiredState.messageTypes.add(messageType);
    }
    unsubscribe(messageType) {
        if (!this.desiredState.messageTypes.has(messageType)) {
            return;
        }
        this.desiredState.messageTypes.delete(messageType);
    }
    updateToken(token) {
        // @todo not entirely correct?
        this.desiredState.token = token;
    }
    /**
     * Perform actual registration after all required changes are settled.
     */
    async commitChanges() {
        // if (!this.config.token || this.config.token.length === 0) { // @todo factor desiredState.token here?
        //   log.trace("Can't persist registration: token is not set");
        //   return;
        // }
        if (this._hasActiveAttempt) {
            // Concurrent access violation
            logInstance.error("One registration attempt is already in progress");
            throw new Error("One registration attempt is already in progress");
        }
        const [needToUpdate, reasons] = hasDifference(this.desiredState, this.currentState);
        if (!needToUpdate) {
            // The state did not change - complete successfully!
            return;
        }
        if (!this.currentState.notificationId) {
            reasons.delete("notificationId");
        }
        logInstance.trace(`Persisting ${this.channelType} registration`, reasons, this.desiredState);
        try {
            this._hasActiveAttempt = true;
            const stateToPersist = new RegistrationState();
            stateToPersist.token = this.desiredState.token;
            stateToPersist.notificationId = this.desiredState.notificationId;
            stateToPersist.messageTypes = new Set(this.desiredState.messageTypes);
            if (stateToPersist.messageTypes.size > 0) {
                const persistedState = await this.updateRegistration(stateToPersist, reasons);
                this.currentState.token = persistedState.token;
                this.currentState.notificationId = persistedState.notificationId;
                this.currentState.messageTypes = new Set(persistedState.messageTypes);
                // @todo twilsock emits registered(notificationContextId) when this context is reg'd
                this.emit("stateChanged", this.channelType, "registered", this.currentState);
            }
            else {
                await this.removeRegistration();
                this.currentState.token = stateToPersist.token;
                this.currentState.notificationId = stateToPersist.notificationId;
                this.currentState.messageTypes.clear();
                this.emit("stateChanged", this.channelType, "unregistered", this.currentState);
            }
        }
        catch (e) {
            throw e; // Forward any errors up
        }
        finally {
            this._hasActiveAttempt = false;
        }
    }
}

const retrierConfig = {
    min: 2000,
    max: 120000,
    randomness: 0.2,
};
/**
 * Manages the registrations on ERS service.
 * Deduplicates registrations and manages them automatically.
 */
class RegistrarConnector extends Connector {
    /**
     * Creates new instance of the ERS registrar
     *
     * @param channelType {string} Channel this connector will be servicing.
     * @param context {any} productId, platform, and protocolVersion.
     * @param twilsock {TwilsockClient} connection transport.
     * @param registrarUrl {string}
     */
    constructor(channelType, context, // context is separate from config because it's not shared with other connectors
    twilsock, registrarUrl) {
        super(channelType);
        this.context = context;
        this.twilsock = twilsock;
        this.registrarUrl = registrarUrl;
        this.registrationId = null;
    }
    async updateRegistration(registration, reasons) {
        if (reasons.has("notificationId")) {
            await this.removeRegistration();
        }
        if (!registration.notificationId || !registration.notificationId.length) {
            logInstance.error(`No push notification ID for registration`);
            throw new Error(`No push notification ID for registration`); // @todo FSM update to error perhaps
        }
        logInstance.trace("Registering", this.channelType, registration);
        const registrarRequest = {
            endpoint_platform: this.context.platform,
            channel_type: this.channelType,
            version: this.context.protocolVersion.toString(),
            message_types: Array.from(registration.messageTypes),
            data: {
                registration_id: registration.notificationId,
            },
            //ttl: 'PT24H' - This is totally ignored by notify, all bindings use PT1Y ttl.
        };
        const productId = this.context.productId;
        const url = `${this.registrarUrl}?productId=${productId}`;
        const headers = {
            "Content-Type": "application/json",
            // 'X-Twilio-Token': registration.token
        };
        logInstance.trace(`Creating registration for channel ${this.channelType}`);
        try {
            const response = (await new operationRetrier.AsyncRetrier(retrierConfig).run(() => this.twilsock.post(url, headers, registrarRequest, productId)));
            this.registrationId = response.body.id;
            logInstance.debug("Registration created: ", response);
        }
        catch (err) {
            logInstance.error("Registration failed: ", err);
            throw err;
        }
        return registration;
    }
    async removeRegistration() {
        if (!this.registrationId) {
            // No registration ID - no problem, finish successfully.
            return;
        }
        const productId = this.context.productId;
        const url = `${this.registrarUrl}/${this.registrationId}?productId=${productId}`;
        const headers = {
            "Content-Type": "application/json",
            // 'X-Twilio-Token': this.config.token
        };
        logInstance.trace(`Removing registration for ${this.channelType}`);
        try {
            await new operationRetrier.AsyncRetrier(Object.assign(retrierConfig, { maxAttemptsCount: 3 })).run(() => this.twilsock.delete(url, headers, {}, productId));
            this.registrationId = null;
            this.currentState.notificationId = "";
            logInstance.debug(`Registration removed for ${this.channelType}`);
        }
        catch (err) {
            logInstance.error("Failed to remove registration ", this.channelType, err);
            throw err;
        }
    }
    async sendDeviceRemoveRequest(registrationId) {
        if (registrationId === "") {
            throw new Error("Empty registration ID");
        }
        const productId = this.context.productId;
        const url = `${this.registrarUrl}?productId=${productId}`;
        const headers = {
            "Content-Type": "application/json",
            // @todo Content-Length??
        };
        const payload = {
            binding_type: this.channelType,
            address: registrationId,
        };
        try {
            logInstance.trace(`Removing old registrations for ${this.channelType}`);
            await new operationRetrier.AsyncRetrier(Object.assign(retrierConfig, { maxAttemptsCount: 3 })).run(() => this.twilsock.delete(url, headers, payload, productId));
            this.registrationId = null;
            this.currentState.notificationId = "";
            logInstance.debug(`Registration removed for ${this.channelType}`);
        }
        catch (err) {
            logInstance.error("Failed to remove registration ", this.channelType, err);
            throw err;
        }
    }
}

var rngBrowser = {exports: {}};

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  rngBrowser.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  rngBrowser.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid$2(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]]
  ]).join('');
}

var bytesToUuid_1 = bytesToUuid$2;

var rng$1 = rngBrowser.exports;
var bytesToUuid$1 = bytesToUuid_1;

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;
var _clockseq;

// Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0;

// See https://github.com/uuidjs/uuid for API details
function v1$1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189
  if (node == null || clockseq == null) {
    var seedBytes = rng$1();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [
        seedBytes[0] | 0x01,
        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
      ];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  }

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid$1(b);
}

var v1_1 = v1$1;

var rng = rngBrowser.exports;
var bytesToUuid = bytesToUuid_1;

function v4$1(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

var v4_1 = v4$1;

var v1 = v1_1;
var v4 = v4_1;

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

var uuid_1 = uuid;

/**
 * Registrar connector implementation for twilsock -- @todo Drop twilsock.connector COMPLETELY?!
 */
class TwilsockConnector extends Connector {
    /**
     * Create twilsock registration connector.
     * @param productId product ID
     * @param platform platform ID string
     * @param twilsock {TwilsockClient} connection transport.
     */
    constructor(productId, platform, twilsock) {
        super("twilsock");
        this.productId = productId;
        this.platform = platform;
        this.twilsock = twilsock;
        this.contextId = uuid_1.v4();
    }
    async updateRegistration(registration, reasons) {
        if (!reasons.has("messageType")) {
            // No changed message types - it is fine, finish successfully.
            return registration;
        }
        const messageTypes = Array.from(registration.messageTypes);
        const context = {
            product_id: this.productId,
            notification_protocol_version: 4,
            endpoint_platform: this.platform,
            message_types: messageTypes,
        };
        try {
            await this.twilsock.setNotificationsContext(this.contextId, context);
        }
        catch (err) {
            logInstance.error(`Failed to update twilsock notification context: ${err}`);
            throw err;
        }
        return registration;
    }
    async removeRegistration() {
        try {
            await this.twilsock.removeNotificationsContext(this.contextId);
        }
        catch (err) {
            logInstance.error(`Failed to remove twilsock notification context: ${err}`);
            throw err;
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async sendDeviceRemoveRequest(registrationId) {
        // no need to do anything here, twilsock backend handles it on its own
    }
}

var Client_1;
// For validating Connector.ChannelType - keep synchronized!
const channelTypeRule = declarativeTypeValidator.literal("apn", "fcm", "twilsock");
/**
 * @class
 * @alias Notifications
 * @classdesc The helper library for the notification service.
 * Provides high level api for creating and managing notification subscriptions and receiving messages
 * Creates the instance of Notification helper library
 *
 * @constructor
 * @param {string} token - Twilio access token
 * @param {Notifications#ClientOptions} options - Options to customize client behavior
 *
 * @event stateChanged channelType (registered|unregistered) -- coming from connector, i.e. it's per-connector type!
 * @event transportState Forwarded from Twilsock's stateChanged event.
 * @event message Routed from twilsock as a notification event.
 */
exports.Notifications = Client_1 = class Client extends EventEmitter {
    constructor(token, options = {}) {
        var _a, _b, _c, _d, _e, _f;
        super();
        options.logLevel = (_a = options.logLevel) !== null && _a !== void 0 ? _a : "error";
        logInstance.setLevel(options.logLevel);
        const productId = (_b = options.productId) !== null && _b !== void 0 ? _b : "notifications";
        const startTwilsock = !options.twilsockClient;
        const twilsock$1 = (options.twilsockClient =
            (_c = options.twilsockClient) !== null && _c !== void 0 ? _c : new twilsock.TwilsockClient(token, productId, options));
        const config = (_d = options.notifications) !== null && _d !== void 0 ? _d : {};
        const region = (_f = (_e = config.region) !== null && _e !== void 0 ? _e : options.region) !== null && _f !== void 0 ? _f : "us1";
        const defaultUrl = `https://ers.${region}.twilio.com/v1/registrations`;
        const registrarUrl = config.ersUrl || defaultUrl;
        this.connectors = new Map();
        const platform = Client_1._detectPlatform();
        this.connectors.set("apn", new RegistrarConnector("apn", { protocolVersion: 4, productId, platform }, twilsock$1, registrarUrl));
        this.connectors.set("fcm", new RegistrarConnector("fcm", { protocolVersion: 3, productId, platform }, twilsock$1, registrarUrl));
        this.connectors.set("twilsock", new TwilsockConnector(productId, platform, twilsock$1));
        twilsock$1.on("stateChanged", (state) => this.emit("transportState", state));
        this._connector("twilsock").on("stateChanged", (type, value, state) => this.emit("stateChanged", type, value, state));
        this._connector("apn").on("stateChanged", (type, value, state) => this.emit("stateChanged", type, value, state));
        this._connector("fcm").on("stateChanged", (type, value, state) => this.emit("stateChanged", type, value, state));
        // Router
        twilsock$1.on("message", (type, message) => this._routeMessage(type, message));
        this.updateToken(token);
        // Start only if we created twilsock locally,
        // otherwise it's the responsibility of whoever created the Twilsock client.
        if (startTwilsock) {
            twilsock$1.connect();
            this.twilsock = twilsock$1;
        }
    }
    async shutdown() {
        this.connectors.clear();
        if (this.twilsock) {
            await this.twilsock.disconnect();
        }
    }
    /**
     * Set OS-provided APNS/FCM registration binding for the given channel type. Not used for 'twilsock'.
     *
     * You must call this function once you've received the ID of your device from the underlying OS.
     *
     * @param {ChannelType} channelType Channel type ('apn'/'fcm').
     * @param {string} pushRegistrationId Token received from FCM/APNS system on device.
     */
    setPushRegistrationId(channelType, pushRegistrationId) {
        logInstance.debug(`Set ${channelType} push registration id '${pushRegistrationId}'`);
        this._connector(channelType).setNotificationId(pushRegistrationId);
    }
    /**
     * Subscribe to a given message type for a given channel type.
     *
     * Creates a subscriptions to receive incoming messages according to message type.
     * Subscription establishes a binding and you will receive a signal when a notification
     * of this type has been received by the library.
     *
     * Subscribed binding is preserved for 1 year, after which time it needs to be re-subscribed.
     * This is the responsibility of the client SDK.
     *
     * @param {ChannelType} channelType Supported are 'twilsock', 'apn' and 'fcm'
     * @param {string} messageType The type of message that you want to receive
     */
    subscribe(channelType, messageType) {
        logInstance.debug(`Add ${channelType} subscriptions for message type ${messageType}`);
        this._connector(channelType).subscribe(messageType);
    }
    /**
     * Unsubscribe from a given message type.
     *
     * Unsubscribing breaks a binding and you will not receive more notifications for this message type.
     * Please note that you have to call commitChanges() and receive a successful result before
     * the subscription is actually removed.
     *
     * @param {ChannelType} channelType Supported are 'twilsock', 'apn' and 'fcm'
     * @param {string} messageType The type of message that you don't want to receive anymore
     */
    unsubscribe(channelType, messageType) {
        logInstance.debug(`Remove ${channelType} subscriptions for message type ${messageType}`);
        this._connector(channelType).unsubscribe(messageType);
    }
    /**
     * Update subscription token. You must update the token when the old one expires.
     *
     * When you receive onTokenWillExpire event from twilsock, call this function with the new refreshed
     * token _after_ you have updated twilsock and other associated objects with the new token.
     *
     * @param {string} token Authentication token for registrations
     */
    updateToken(token) {
        this.connectors.forEach((connector) => connector.updateToken(token));
    }
    /**
     * Commit all collected subscription changes as a batched update. This function tries to reduce
     * number of network calls necessary to update bindings status.
     */
    async commitChanges() {
        const promises = [];
        this.connectors.forEach((connector) => {
            if (connector.isActive()) {
                promises.push(connector.commitChanges());
            }
        });
        await Promise.all(promises);
    }
    /**
     * Clear existing registrations directly using provided device token.
     * This is useful to ensure stopped subscriptions without resubscribing.
     *
     * This function goes completely beside the state machine and removes all registrations.
     * Use with caution: if it races with current state machine operations, madness will ensue.
     *
     * @param {ChannelType} channelType Channel type ('apn'/'fcm').
     * @param {string} registrationId Token received from FCM/APNS system on device.
     */
    async removeRegistrations(channelType, registrationId) {
        await this._connector(channelType).sendDeviceRemoveRequest(registrationId);
    }
    /**
     * Handle incoming push notification.
     * Client application should call this method when it receives push notifications and pass the received data.
     * @param {Object} message push message
     * @return {PushNotification} A reformatted payload with extracted message type.
     */
    handlePushNotification(message) {
        return {
            messageType: message.twi_message_type,
            payload: message.payload,
        };
    }
    /**
     * Routes messages to the external subscribers
     */
    _routeMessage(type, message) {
        logInstance.debug("Notification message arrived: ", type, message);
        this.emit("message", type, message);
    }
    /**
     * @param {String} type Channel type
     * @throws {Error} Error with description
     */
    _connector(type) {
        const connector = this.connectors.get(type);
        if (!connector) {
            throw new Error(`Unknown channel type: ${type}`);
        }
        return connector;
    }
    /**
     * Returns platform string limited to max 128 chars
     */
    static _detectPlatform() {
        let platform = "";
        if (typeof navigator !== "undefined") {
            platform = "unknown";
            if (typeof navigator.product !== "undefined") {
                platform = navigator.product;
            }
            if (typeof navigator.userAgent !== "undefined") {
                platform = navigator.userAgent;
            }
        }
        else {
            platform = "web";
        }
        return platform.substring(0, 128);
    }
};
__decorate([
    declarativeTypeValidator.validateTypes(channelTypeRule, declarativeTypeValidator.nonEmptyString),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", void 0)
], exports.Notifications.prototype, "setPushRegistrationId", null);
__decorate([
    declarativeTypeValidator.validateTypes(channelTypeRule, declarativeTypeValidator.nonEmptyString),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", void 0)
], exports.Notifications.prototype, "subscribe", null);
__decorate([
    declarativeTypeValidator.validateTypes(channelTypeRule, declarativeTypeValidator.nonEmptyString),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", void 0)
], exports.Notifications.prototype, "unsubscribe", null);
__decorate([
    declarativeTypeValidator.validateTypes(declarativeTypeValidator.nonEmptyString),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", void 0)
], exports.Notifications.prototype, "updateToken", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(channelTypeRule, declarativeTypeValidator.nonEmptyString),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], exports.Notifications.prototype, "removeRegistrations", null);
exports.Notifications = Client_1 = __decorate([
    declarativeTypeValidator.validateConstructorTypes(declarativeTypeValidator.nonEmptyString, [
        declarativeTypeValidator.pureObject,
        "undefined",
        declarativeTypeValidator.literal(null),
    ]),
    __metadata("design:paramtypes", [String, Object])
], exports.Notifications);
//# sourceMappingURL=react-native.js.map
