/*
@license
The following license applies to all parts of this software except as
documented below.

    Copyright (c) 2016, Twilio, inc.
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are
    met:

      1. Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.

      2. Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in
         the documentation and/or other materials provided with the
         distribution.

      3. Neither the name of Twilio nor the names of its contributors may
         be used to endorse or promote products derived from this software
         without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This software includes javascript-state-machine under the following license.

    Copyright (c) 2012, 2013, 2014, 2015, Jake Gordon and contributors

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

This software includes loglevel under the following license.

    Copyright (c) 2013 Tim Perry

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without
    restriction, including without limitation the rights to use,
    copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following
    conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.


*/
'use strict';

var global =
  typeof global !== "undefined"
    ? global
    : typeof self !== "undefined"
    ? self
    : typeof window !== "undefined"
    ? window
    : {};

Object.defineProperty(exports, '__esModule', { value: true });

var declarativeTypeValidator = require('@twilio/declarative-type-validator');
var loglevelLog = require('loglevel');
var StateMachine = require('javascript-state-machine');
var uuid = require('uuid');
var operationRetrier = require('@twilio/operation-retrier');
var platform = require('platform');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () {
                        return e[k];
                    }
                });
            }
        });
    }
    n['default'] = e;
    return Object.freeze(n);
}

var loglevelLog__namespace = /*#__PURE__*/_interopNamespace(loglevelLog);
var StateMachine__namespace = /*#__PURE__*/_interopNamespace(StateMachine);
var platform__namespace = /*#__PURE__*/_interopNamespace(platform);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

var domain;

// This constructor is used to store event handlers. Instantiating this is
// faster than explicitly calling `Object.create(null)` to get a "clean" empty
// object (tested with v8 v4.9).
function EventHandlers() {}
EventHandlers.prototype = Object.create(null);

function EventEmitter() {
  EventEmitter.init.call(this);
}

// nodejs oddity
// require('events') === require('events').EventEmitter
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.usingDomains = false;

EventEmitter.prototype.domain = undefined;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

EventEmitter.init = function() {
  this.domain = null;
  if (EventEmitter.usingDomains) {
    // if there is an active domain, then attach to it.
    if (domain.active ) ;
  }

  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers();
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events, domain;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  domain = this.domain;

  // If there is no 'error' event listener then throw.
  if (doError) {
    er = arguments[1];
    if (domain) {
      if (!er)
        er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain;
      er.domainThrown = false;
      domain.emit('error', er);
    } else if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] :
                                          [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
                            existing.length + ' ' + type + ' listeners added. ' +
                            'Use emitter.setMaxListeners() to increase limit');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }

  return target;
}
function emitWarning(e) {
  typeof console.warn === 'function' ? console.warn(e) : console.log(e);
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function _onceWrap(target, type, listener) {
  var fired = false;
  function g() {
    target.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || (list.listener && list.listener === listener)) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length; i-- > 0;) {
          if (list[i] === listener ||
              (list[i].listener && list[i].listener === listener)) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (list.length === 1) {
          list[0] = undefined;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };
    
// Alias for removeListener added in NodeJS 10.0
// https://nodejs.org/api/events.html#events_emitter_off_eventname_listener
EventEmitter.prototype.off = function(type, listener){
    return this.removeListener(type, listener);
};

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        for (var i = 0, key; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        do {
          this.removeListener(type, listeners[listeners.length - 1]);
        } while (listeners[0]);
      }

      return this;
    };

EventEmitter.prototype.listeners = function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;

  if (!events)
    ret = [];
  else {
    evlistener = events[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === 'function')
      ret = [evlistener.listener || evlistener];
    else
      ret = unwrapListeners(evlistener);
  }

  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, i) {
  var copy = new Array(i);
  while (i--)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

const log = loglevelLog__namespace.getLogger("twilsock"); // twilsock is used by Flex SDK. Please DO NOT change
function prepareLine(prefix, args) {
    return [`${new Date().toISOString()} Twilsock ${prefix}:`].concat(Array.from(args));
}
class Logger {
    constructor(prefix) {
        this.prefix = "";
        this.prefix =
            prefix !== null && prefix !== undefined && prefix.length > 0
                ? " " + prefix + ":"
                : "";
    }
    setLevel(level) {
        log.setLevel(level);
    }
    static setLevel(level) {
        log.setLevel(level);
    }
    trace(...args) {
        log.trace.apply(null, prepareLine("T", args));
    }
    debug(...args) {
        log.debug.apply(null, prepareLine("D", args));
    }
    info(...args) {
        log.info.apply(null, prepareLine("I", args));
    }
    warn(...args) {
        log.warn.apply(null, prepareLine("W", args));
    }
    error(...args) {
        log.error.apply(null, prepareLine("E", args));
    }
    static trace(...args) {
        log.trace.apply(null, prepareLine("T", args));
    }
    static debug(...args) {
        log.debug.apply(null, prepareLine("D", args));
    }
    static info(...args) {
        log.info.apply(null, prepareLine("I", args));
    }
    static warn(...args) {
        log.warn.apply(null, prepareLine("W", args));
    }
    static error(...args) {
        log.error.apply(null, prepareLine("E", args));
    }
}
const logInstance = new Logger("");

var version = "0.12.0";

/**
 * Settings container for the Twilsock client library
 */
class Configuration {
    /**
     * @param {String} token - authentication token
     * @param {Object} options - options to override defaults
     */
    constructor(token, activeGrant, options) {
        this.confirmedCapabilities = new Set();
        this.activeGrant = activeGrant;
        this._token = token;
        const region = options.region || "us1";
        const defaultTwilsockUrl = `wss://tsock.${region}.twilio.com/v3/wsconnect`;
        const twilsockOptions = options.twilsock || options.Twilsock || {};
        this.url = twilsockOptions.uri || defaultTwilsockUrl;
        this._continuationToken = options.continuationToken
            ? options.continuationToken
            : null;
        this.logLevel = options.logLevel ? options.logLevel : "error";
        this.retryPolicy = options.retryPolicy
            ? options.retryPolicy
            : {
                min: 1 * 1000,
                max: 2 * 60 * 1000,
                randomness: 0.2,
            };
        this.clientMetadata = options.clientMetadata ? options.clientMetadata : {};
        this.clientMetadata.ver = version;
        this.initRegistrations = options.initRegistrations
            ? options.initRegistrations
            : null;
        this.tweaks = options.tweaks ? options.tweaks : null;
    }
    get token() {
        return this._token;
    }
    get continuationToken() {
        return this._continuationToken;
    }
    updateToken(token) {
        this._token = token;
    }
    updateContinuationToken(continuationToken) {
        this._continuationToken = continuationToken;
    }
}

class AbstractMessage {
    constructor(id) {
        this.id = id || `TM${uuid.v4()}`;
    }
}

class Init extends AbstractMessage {
    constructor(token, continuationToken, metadata, registrations, tweaks) {
        super();
        this.method = "init";
        this.token = token;
        this.continuation_token = continuationToken;
        this.metadata = metadata;
        this.registrations = registrations;
        this.tweaks = tweaks;
        this.capabilities = ["client_update", "offline_storage", "telemetry.v1"];
    }
}

class InitReply extends AbstractMessage {
    constructor(id, continuationToken, confirmedCapabilities, continuationTokenStatus, offlineStorage, initRegistrations, debugInfo) {
        super(id);
        this.continuationToken = continuationToken;
        this.continuationTokenStatus = continuationTokenStatus;
        this.offlineStorage = offlineStorage;
        this.initRegistrations = initRegistrations;
        this.debugInfo = debugInfo;
        this.confirmedCapabilities = confirmedCapabilities;
    }
}

class Update extends AbstractMessage {
    constructor(token) {
        super();
        this.method = "update";
        this.token = token;
    }
}

class Message extends AbstractMessage {
    constructor(grant, contentType, request) {
        super();
        this.method = "message";
        this.active_grant = grant;
        this.payload_type = contentType;
        this.http_request = request;
    }
}

class Reply extends AbstractMessage {
    constructor(id) {
        super(id);
        this.method = "reply";
        this.payload_type = "application/json";
        this.status = { code: 200, status: "OK" };
    }
}

class Close extends AbstractMessage {
    constructor() {
        super();
        this.method = "close";
    }
}

class TelemetryEvent {
    constructor(start, // relative to event send time
    end, // relative to event send time
    title, details, id, // optional, default will be random assigned by backend
    type) {
        this.start = start;
        this.end = end;
        this.title = title;
        this.details = details;
        this.id = id;
        this.type = type;
    } // optional, default will be "SDK" assigned by backend
}
class Telemetry extends AbstractMessage {
    constructor(events) {
        super();
        this.method = "telemetry.v1";
        this.events = events;
    }
}

function byteLength(s) {
    const escstr = encodeURIComponent(s);
    const binstr = escstr.replace(/%([0-9A-F]{2})/g, (match, p1) => String.fromCharCode(Number("0x" + p1)));
    return binstr.length;
}
function stringToUint8Array(s) {
    const escstr = encodeURIComponent(s);
    const binstr = escstr.replace(/%([0-9A-F]{2})/g, (match, p1) => String.fromCharCode(Number("0x" + p1)));
    const ua = new Uint8Array(binstr.length);
    Array.prototype.forEach.call(binstr, (ch, i) => {
        ua[i] = ch.charCodeAt(0);
    });
    return ua;
}
function uint8ArrayToString(ua) {
    const binstr = Array.prototype.map
        .call(ua, (ch) => String.fromCharCode(ch))
        .join("");
    const escstr = binstr.replace(/(.)/g, (m, p) => {
        let code = p.charCodeAt(0).toString(16).toUpperCase();
        if (code.length < 2) {
            code = "0" + code;
        }
        return "%" + code;
    });
    return decodeURIComponent(escstr);
}
function getJsonObject(array) {
    return JSON.parse(uint8ArrayToString(array));
}
function getMagic(buffer) {
    let strMagic = "";
    let idx = 0;
    for (; idx < buffer.length; ++idx) {
        const chr = String.fromCharCode(buffer[idx]);
        strMagic += chr;
        if (chr === "\r") {
            idx += 2;
            break;
        }
    }
    const magics = strMagic.split(" ");
    return {
        size: idx,
        protocol: magics[0],
        version: magics[1],
        headerSize: Number(magics[2]),
    };
}
class Parser {
    static parse(message) {
        const fieldMargin = 2;
        const dataView = new Uint8Array(message);
        const magic = getMagic(dataView);
        if (magic.protocol !== "TWILSOCK" || magic.version !== "V3.0") {
            logInstance.error(`unsupported protocol: ${magic.protocol} ver ${magic.version}`);
            //throw new Error('Unsupported protocol');
            //this.fsm.unsupportedProtocol();
            return null;
        }
        let header;
        try {
            header = getJsonObject(dataView.subarray(magic.size, magic.size + magic.headerSize));
        }
        catch (e) {
            logInstance.error("failed to parse message header", e, message);
            //throw new Error('Failed to parse message');
            //this.fsm.protocolError();
            return null;
        }
        logInstance.debug("message received: ", header.method);
        logInstance.trace("message received: ", header);
        let payload;
        if (header.payload_size > 0) {
            const payloadOffset = fieldMargin + magic.size + magic.headerSize;
            const payloadSize = header.payload_size;
            if (!header.hasOwnProperty("payload_type") ||
                header.payload_type.indexOf("application/json") === 0) {
                try {
                    payload = getJsonObject(dataView.subarray(payloadOffset, payloadOffset + payloadSize));
                }
                catch (e) {
                    logInstance.error("failed to parse message body", e, message);
                    //this.fsm.protocolError();
                    return null;
                }
            }
            else if (header.payload_type.indexOf("text/plain") === 0) {
                payload = uint8ArrayToString(dataView.subarray(payloadOffset, payloadOffset + payloadSize));
            }
        }
        return { method: header.method, header, payload };
    }
    static createPacket(header, payloadString = "") {
        header.payload_size = byteLength(payloadString); // eslint-disable-line camelcase
        const headerString = JSON.stringify(header);
        const magicString = "TWILSOCK V3.0 " + byteLength(headerString);
        logInstance.debug("send request:", magicString + headerString + payloadString);
        const message = stringToUint8Array(magicString + "\r\n" + headerString + "\r\n" + payloadString);
        return message.buffer;
    }
}

class TwilsockError extends Error {
    constructor(description) {
        super(description);
    }
}

class TwilsockReplyError extends TwilsockError {
    constructor(description, reply) {
        super(description);
        this.reply = reply;
    }
}

class BackoffRetrier extends EventEmitter {
    constructor(options) {
        super();
        this.newBackoff = null;
        this.usedBackoff = null;
        this.retrier = null;
        this.options = options ? Object.assign({}, options) : {};
    }
    get inProgress() {
        return !!this.retrier;
    }
    /**
     * Should be called once per attempt series to start retrier.
     */
    start() {
        if (this.inProgress) {
            throw new Error("Already waiting for next attempt, call finishAttempt(success : boolean) to finish it");
        }
        this.createRetrier();
    }
    /**
     * Should be called to stop retrier entirely.
     */
    stop() {
        this.cleanRetrier();
        this.newBackoff = null;
        this.usedBackoff = null;
    }
    /**
     * Modifies backoff for next attempt.
     * Expected behavior:
     * - If there was no backoff passed previously reschedulling next attempt to given backoff
     * - If previous backoff was longer then ignoring this one.
     * - If previous backoff was shorter then reschedulling with this one.
     * With or without backoff retrier will keep growing normally.
     * @param delay delay of next attempts in ms.
     */
    modifyBackoff(delay) {
        this.newBackoff = delay;
    }
    /**
     * Mark last emmited attempt as failed, initiating either next of fail if limits were hit.
     */
    attemptFailed() {
        var _a, _b;
        if (!this.inProgress) {
            throw new Error("No attempt is in progress");
        }
        if (this.newBackoff) {
            const shouldUseNewBackoff = !this.usedBackoff || this.usedBackoff < this.newBackoff;
            if (shouldUseNewBackoff) {
                this.createRetrier();
            }
            else {
                (_a = this.retrier) === null || _a === void 0 ? void 0 : _a.failed(new Error());
            }
        }
        else {
            (_b = this.retrier) === null || _b === void 0 ? void 0 : _b.failed(new Error());
        }
    }
    cancel() {
        var _a;
        (_a = this.retrier) === null || _a === void 0 ? void 0 : _a.cancel();
    }
    cleanRetrier() {
        var _a, _b;
        (_a = this.retrier) === null || _a === void 0 ? void 0 : _a.removeAllListeners();
        (_b = this.retrier) === null || _b === void 0 ? void 0 : _b.cancel();
        this.retrier = null;
    }
    getRetryPolicy() {
        const clone = Object.assign({}, this.options);
        if (this.newBackoff) {
            clone.min = this.newBackoff;
            clone.max =
                this.options.max && this.options.max > this.newBackoff
                    ? this.options.max
                    : this.newBackoff;
        }
        // As we're always skipping first attempt we should add one extra if limit is present
        clone.maxAttemptsCount = this.options.maxAttemptsCount
            ? this.options.maxAttemptsCount + 1
            : undefined;
        return clone;
    }
    createRetrier() {
        this.cleanRetrier();
        const retryPolicy = this.getRetryPolicy();
        this.retrier = new operationRetrier.Retrier(retryPolicy);
        this.retrier.once("attempt", () => {
            var _a, _b;
            (_a = this.retrier) === null || _a === void 0 ? void 0 : _a.on("attempt", () => this.emit("attempt"));
            (_b = this.retrier) === null || _b === void 0 ? void 0 : _b.failed(new Error("Skipping first attempt"));
        });
        this.retrier.on("failed", (err) => this.emit("failed", err));
        this.usedBackoff = this.newBackoff;
        this.newBackoff = null;
        this.retrier.start();
        // .catch(err => {});
    }
}

const DISCONNECTING_TIMEOUT = 3000;
// Wraps asynchronous rescheduling
// Just makes it simpler to find these hacks over the code
// Currently there's exactly one instance of this in closeSocket()
function trampoline(f) {
    setTimeout(f, 0);
}
/**
 * Twilsock channel level protocol implementation
 */
class TwilsockChannel extends EventEmitter {
    constructor(websocket, transport, config) {
        super();
        this.disconnectingTimer = null;
        this.disconnectedPromiseResolve = null;
        this.terminalStates = ["disconnected", "rejected"];
        this.tokenExpiredSasCode = 20104;
        this.terminationReason = "Connection is not initialized";
        this.websocket = websocket;
        this.websocket.on("connected", () => this.fsm.socketConnected());
        this.websocket.on("disconnected", () => this.fsm.socketClosed());
        this.websocket.on("message", (message) => this.onIncomingMessage(message));
        this.websocket.on("socketError", (e) => this.emit("connectionError", {
            terminal: false,
            message: `Socket error: ${e.message}`,
            httpStatusCode: null,
            errorCode: null,
        }));
        this.transport = transport;
        this.config = config;
        this.retrier = new BackoffRetrier(config.retryPolicy);
        this.retrier.on("attempt", () => this.retry());
        this.retrier.on("failed", (err) => {
            logInstance.warn(`Retrying failed: ${err.message}`);
            this.disconnect();
        });
        if (typeof window !== "undefined" &&
            typeof window.addEventListener !== "undefined") {
            window.addEventListener("online", () => {
                logInstance.debug("Browser reported connectivity state: online");
                this.resetBackoff();
                this.fsm.systemOnline();
            });
            window.addEventListener("offline", () => {
                logInstance.debug("Browser reported connectivity state: offline");
                this.websocket.close();
                this.fsm.socketClosed();
            });
        }
        // We have to use a factory function in here because using the default
        // StateMachine constructor would cause an error for the consumers of the
        // rollup bundles. This is a quirk unique to the javascript-state-machine
        // library.
        const TwilsockStateMachine = StateMachine__namespace.factory({
            init: "disconnected",
            transitions: [
                {
                    name: "userConnect",
                    from: ["disconnected", "rejected"],
                    to: "connecting",
                },
                { name: "userConnect", from: ["connecting", "connected"] },
                {
                    name: "userDisconnect",
                    from: [
                        "connecting",
                        "initialising",
                        "connected",
                        "updating",
                        "retrying",
                        "rejected",
                        "waitSocketClosed",
                        "waitOffloadSocketClosed",
                    ],
                    to: "disconnecting",
                },
                { name: "userRetry", from: ["retrying"], to: "connecting" },
                { name: "socketConnected", from: ["connecting"], to: "initialising" },
                {
                    name: "socketClosed",
                    from: [
                        "connecting",
                        "initialising",
                        "connected",
                        "updating",
                        "error",
                        "waitOffloadSocketClosed",
                    ],
                    to: "retrying",
                },
                { name: "socketClosed", from: ["disconnecting"], to: "disconnected" },
                {
                    name: "socketClosed",
                    from: ["waitSocketClosed"],
                    to: "disconnected",
                },
                { name: "socketClosed", from: ["rejected"], to: "rejected" },
                { name: "initSuccess", from: ["initialising"], to: "connected" },
                { name: "initError", from: ["initialising"], to: "error" },
                {
                    name: "tokenRejected",
                    from: ["initialising", "updating"],
                    to: "rejected",
                },
                {
                    name: "protocolError",
                    from: ["initialising", "connected", "updating"],
                    to: "error",
                },
                {
                    name: "receiveClose",
                    from: ["initialising", "connected", "updating"],
                    to: "waitSocketClosed",
                },
                {
                    name: "receiveOffload",
                    from: ["initialising", "connected", "updating"],
                    to: "waitOffloadSocketClosed",
                },
                {
                    name: "unsupportedProtocol",
                    from: ["initialising", "connected", "updating"],
                    to: "unsupported",
                },
                {
                    name: "receiveFatalClose",
                    from: ["initialising", "connected", "updating"],
                    to: "unsupported",
                },
                {
                    name: "userUpdateToken",
                    from: ["disconnected", "rejected", "connecting", "retrying"],
                    to: "connecting",
                },
                { name: "userUpdateToken", from: ["connected"], to: "updating" },
                { name: "updateSuccess", from: ["updating"], to: "connected" },
                { name: "updateError", from: ["updating"], to: "error" },
                { name: "userSend", from: ["connected"], to: "connected" },
                { name: "systemOnline", from: ["retrying"], to: "connecting" },
            ],
            methods: {
                onConnecting: () => {
                    this.setupSocket();
                    this.emit("connecting");
                },
                onEnterInitialising: () => {
                    this.sendInit();
                },
                onLeaveInitialising: () => {
                    this.cancelInit();
                },
                onEnterUpdating: () => {
                    this.sendUpdate();
                },
                onLeaveUpdating: () => {
                    this.cancelUpdate();
                },
                onEnterRetrying: () => {
                    this.initRetry();
                    this.emit("connecting");
                },
                onEnterConnected: () => {
                    this.resetBackoff();
                    this.onConnected();
                },
                onUserUpdateToken: () => {
                    this.resetBackoff();
                },
                onTokenRejected: () => {
                    this.resetBackoff();
                    this.closeSocket(true);
                    this.finalizeSocket();
                },
                onUserDisconnect: () => {
                    this.closeSocket(true);
                },
                onEnterDisconnecting: () => {
                    this.startDisconnectTimer();
                },
                onLeaveDisconnecting: () => {
                    this.cancelDisconnectTimer();
                },
                onEnterWaitSocketClosed: () => {
                    this.startDisconnectTimer();
                },
                onLeaveWaitSocketClosed: () => {
                    this.cancelDisconnectTimer();
                },
                onEnterWaitOffloadSocketClosed: () => {
                    this.startDisconnectTimer();
                },
                onLeaveWaitOffloadSocketClosed: () => {
                    this.cancelDisconnectTimer();
                },
                onDisconnected: () => {
                    this.resetBackoff();
                    this.finalizeSocket();
                },
                onReceiveClose: () => {
                    this.onCloseReceived();
                },
                onReceiveOffload: (event, args) => {
                    logInstance.debug("onreceiveoffload: ", args);
                    this.modifyBackoff(args.body);
                    this.onCloseReceived();
                },
                onUnsupported: () => {
                    this.closeSocket(true);
                    this.finalizeSocket();
                },
                onError: (lifecycle, graceful) => {
                    this.closeSocket(graceful);
                    this.finalizeSocket();
                },
                onEnterState: (event) => {
                    if (event.from !== "none") {
                        this.changeState(event);
                    }
                },
                onInvalidTransition: (transition, from, to) => {
                    logInstance.warn("FSM: unexpected transition", from, to);
                },
            },
        });
        this.fsm = new TwilsockStateMachine();
    }
    changeState(event) {
        logInstance.debug(`FSM: ${event.transition}: ${event.from} --> ${event.to}`);
        if (this.lastEmittedState !== this.state) {
            this.lastEmittedState = this.state;
            this.emit("stateChanged", this.state);
        }
    }
    resetBackoff() {
        logInstance.trace("resetBackoff");
        this.retrier.stop();
    }
    modifyBackoff(body) {
        logInstance.trace("modifyBackoff", body);
        const backoffPolicy = body ? body.backoff_policy : null;
        if (backoffPolicy && typeof backoffPolicy.reconnect_min_ms === "number") {
            this.retrier.modifyBackoff(backoffPolicy.reconnect_min_ms);
        }
    }
    startDisconnectTimer() {
        logInstance.trace("startDisconnectTimer");
        if (this.disconnectingTimer) {
            clearTimeout(this.disconnectingTimer);
            this.disconnectingTimer = null;
        }
        this.disconnectingTimer = setTimeout(() => {
            logInstance.debug("disconnecting is timed out");
            this.closeSocket(true);
        }, DISCONNECTING_TIMEOUT);
    }
    cancelDisconnectTimer() {
        logInstance.trace("cancelDisconnectTimer");
        if (this.disconnectingTimer) {
            clearTimeout(this.disconnectingTimer);
            this.disconnectingTimer = null;
        }
    }
    get isConnected() {
        return this.state === "connected" && this.websocket.isConnected;
    }
    get state() {
        switch (this.fsm.state) {
            case "connecting":
            case "initialising":
            case "retrying":
            case "error":
                return "connecting";
            case "updating":
            case "connected":
                return "connected";
            case "rejected":
                return "denied";
            case "disconnecting":
            case "waitSocketClosed":
            case "waitOffloadSocketClosed":
                return "disconnecting";
            case "disconnected":
            default:
                return "disconnected";
        }
    }
    initRetry() {
        logInstance.debug("initRetry");
        if (this.retrier.inProgress) {
            this.retrier.attemptFailed();
        }
        else {
            this.retrier.start();
        }
    }
    retry() {
        if (this.fsm.state != "connecting") {
            logInstance.trace("retry");
            this.websocket.close();
            this.fsm.userRetry();
        }
        else {
            logInstance.trace("can\t retry as already connecting");
        }
    }
    onConnected() {
        this.emit("connected");
    }
    finalizeSocket() {
        logInstance.trace("finalizeSocket");
        this.websocket.close();
        this.emit("disconnected");
        if (this.disconnectedPromiseResolve) {
            this.disconnectedPromiseResolve();
            this.disconnectedPromiseResolve = null;
        }
    }
    setupSocket() {
        logInstance.trace("setupSocket:", this.config.token);
        this.emit("beforeConnect"); // This is used by client to record startup telemetry event
        this.websocket.connect();
    }
    onIncomingMessage(message) {
        const parsedMessage = Parser.parse(message);
        if (!parsedMessage) {
            return;
        }
        const { method, header, payload } = parsedMessage;
        if (method !== "reply") {
            this.confirmReceiving(header);
        }
        if (method === "notification") {
            this.emit("message", header.message_type, payload);
        }
        else if (header.method === "reply") {
            this.transport.processReply({
                id: header.id,
                status: header.status,
                header: header,
                body: payload,
            });
        }
        else if (header.method === "client_update") {
            if (header.client_update_type === "token_about_to_expire") {
                this.emit("tokenAboutToExpire");
            }
        }
        else if (header.method === "close") {
            if (header.status.code === 308) {
                logInstance.debug("Connection has been offloaded");
                this.fsm.receiveOffload({
                    status: header.status.status,
                    body: payload,
                });
            }
            else if (header.status.code === 406) {
                // Not acceptable message
                const message = `Server closed connection because can't parse protocol: ${JSON.stringify(header.status)}`;
                this.emitReplyConnectionError(message, header, true);
                logInstance.error(message);
                this.fsm.receiveFatalClose();
            }
            else if (header.status.code === 417) {
                // Protocol error
                logInstance.error(`Server closed connection because can't parse client reply: ${JSON.stringify(header.status)}`);
                this.fsm.receiveFatalClose(header.status.status);
            }
            else if (header.status.code === 410) {
                // Expired token
                logInstance.warn(`Server closed connection: ${JSON.stringify(header.status)}`);
                this.fsm.receiveClose(header.status.status);
                this.emit("tokenExpired");
            }
            else if (header.status.code === 401) {
                // Authentication fail
                logInstance.error(`Server closed connection: ${JSON.stringify(header.status)}`);
                this.fsm.receiveClose(header.status.status);
            }
            else {
                logInstance.warn("unexpected message: ", header.status);
                // Try to reconnect
                this.fsm.receiveOffload({ status: header.status.status, body: null });
            }
        }
    }
    async sendInit() {
        logInstance.trace("sendInit");
        try {
            this.emit("beforeSendInit"); // This is used by client to record startup telemetry event
            const reply = await this.transport.sendInit();
            this.config.updateContinuationToken(reply.continuationToken);
            this.config.confirmedCapabilities = reply.confirmedCapabilities;
            this.fsm.initSuccess(reply);
            this.emit("initialized", reply);
            this.emit("tokenUpdated");
        }
        catch (ex) {
            if (ex instanceof TwilsockReplyError) {
                let isTerminalError = false;
                logInstance.warn(`Init rejected by server: ${JSON.stringify(ex.reply.status)}`);
                this.emit("sendInitFailed"); // This is used by client to record startup telemetry event
                // @todo emit telemetry from inside "if" below for more granularity...
                if (ex.reply.status.code === 401 || ex.reply.status.code === 403) {
                    isTerminalError = true;
                    this.fsm.tokenRejected(ex.reply.status);
                    if (ex.reply.status.errorCode === this.tokenExpiredSasCode) {
                        this.emit("tokenExpired");
                    }
                }
                else if (ex.reply.status.code === 429) {
                    this.modifyBackoff(ex.reply.body);
                    this.fsm.initError(true);
                }
                else if (ex.reply.status.code === 500) {
                    this.fsm.initError(false);
                }
                else {
                    this.fsm.initError(true);
                }
                this.emitReplyConnectionError(ex.message, ex.reply, isTerminalError);
            }
            else {
                this.terminationReason = ex.message;
                this.emit("connectionError", {
                    terminal: true,
                    message: `Unknown error during connection initialisation: ${ex.message}\n${JSON.stringify(ex, null, 2)}`,
                    httpStatusCode: null,
                    errorCode: null,
                });
                this.fsm.initError(true);
            }
            this.emit("tokenUpdated", ex);
        }
    }
    async sendUpdate() {
        logInstance.trace("sendUpdate");
        const message = new Update(this.config.token);
        try {
            const reply = await this.transport.sendWithReply(message);
            this.fsm.updateSuccess(reply.body);
            this.emit("tokenUpdated");
        }
        catch (ex) {
            if (ex instanceof TwilsockReplyError) {
                let isTerminalError = false;
                logInstance.warn(`Token update rejected by server: ${JSON.stringify(ex.reply.status)}`);
                if (ex.reply.status.code === 401 || ex.reply.status.code === 403) {
                    isTerminalError = true;
                    this.fsm.tokenRejected(ex.reply.status);
                    if (ex.reply.status.errorCode === this.tokenExpiredSasCode) {
                        this.emit("tokenExpired");
                    }
                }
                else if (ex.reply.status.code === 429) {
                    this.modifyBackoff(ex.reply.body);
                    this.fsm.updateError(ex.reply.status);
                }
                else {
                    this.fsm.updateError(ex.reply.status);
                }
                this.emitReplyConnectionError(ex.message, ex.reply, isTerminalError);
            }
            else {
                this.emit("error", false, ex.message, null, null);
                this.fsm.updateError(ex);
            }
            this.emit("tokenUpdated", ex);
        }
    }
    emitReplyConnectionError(message, header, terminal) {
        const description = header.status && header.status.description
            ? header.status.description
            : message;
        const httpStatusCode = header.status.code;
        const errorCode = header.status && header.status.errorCode ? header.status.errorCode : null;
        if (terminal) {
            this.terminationReason = description;
        }
        this.emit("connectionError", {
            terminal: terminal,
            message: `Connection error: ${description}`,
            httpStatusCode: httpStatusCode,
            errorCode: errorCode,
        });
    }
    cancelInit() {
        logInstance.trace("cancelInit");
        // TODO: implement
    }
    cancelUpdate() {
        logInstance.trace("cancelUpdate");
        // TODO: implement
    }
    /**
     * Should be called for each message to confirm it received
     */
    confirmReceiving(messageHeader) {
        logInstance.trace("confirmReceiving");
        try {
            //@todo send telemetry events AnyEvents
            this.transport.send(new Reply(messageHeader.id));
        }
        catch (e) {
            logInstance.debug("failed to confirm packet receiving", e);
        }
    }
    /**
     * Shutdown connection
     */
    closeSocket(graceful) {
        logInstance.trace(`closeSocket (graceful: ${graceful})`);
        if (graceful && this.transport.isConnected) {
            this.transport.sendClose();
        }
        this.websocket.close();
        trampoline(() => this.fsm.socketClosed());
    }
    /**
     * Initiate the twilsock connection
     * If already connected, it does nothing
     */
    connect() {
        logInstance.trace("connect");
        this.fsm.userConnect();
    }
    /**
     * Close twilsock connection
     * If already disconnected, it does nothing
     */
    disconnect() {
        logInstance.trace("disconnect");
        if (this.fsm.is("disconnected")) {
            return Promise.resolve();
        }
        return new Promise((resolve) => {
            this.disconnectedPromiseResolve = resolve;
            this.fsm.userDisconnect();
        });
    }
    /**
     * Update fpa token for twilsock connection
     */
    updateToken(token) {
        logInstance.trace("updateToken:", token);
        return new Promise((resolve, reject) => {
            this.once("tokenUpdated", (e) => {
                if (e) {
                    reject(e);
                }
                else {
                    resolve();
                }
            });
            this.fsm.userUpdateToken();
        });
    }
    get isTerminalState() {
        return this.terminalStates.indexOf(this.fsm.state) !== -1;
    }
    get getTerminationReason() {
        return this.terminationReason;
    }
    onCloseReceived() {
        this.websocket.close();
    }
}

class Metadata {
    static getMetadata(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const overrides = options && options.clientMetadata ? options.clientMetadata : {};
        const fieldNames = [
            "ver",
            "env",
            "envv",
            "os",
            "osv",
            "osa",
            "type",
            "sdk",
            "sdkv",
            "dev",
            "devv",
            "devt",
            "app",
            "appv",
        ];
        const defaults = {
            env: (_a = platform__namespace.name) !== null && _a !== void 0 ? _a : "unknown",
            envv: (_b = platform__namespace.version) !== null && _b !== void 0 ? _b : "unknown",
            os: (_d = (_c = platform__namespace.os) === null || _c === void 0 ? void 0 : _c.family) !== null && _d !== void 0 ? _d : "unknown",
            osv: (_f = (_e = platform__namespace.os) === null || _e === void 0 ? void 0 : _e.version) !== null && _f !== void 0 ? _f : "unknown",
            osa: (_h = (_g = platform__namespace.os) === null || _g === void 0 ? void 0 : _g.architecture) !== null && _h !== void 0 ? _h : "unknown",
            sdk: "js-default",
        };
        const finalClientMetadata = {};
        fieldNames
            .filter((key) => key in overrides || key in defaults)
            .forEach((key) => (finalClientMetadata[key] =
            key in overrides ? overrides[key] : defaults[key]));
        return finalClientMetadata;
    }
}

const REQUEST_TIMEOUT$1 = 30000;
function isHttpSuccess$1(code) {
    return code >= 200 && code < 300;
}
/**
 * Makes sure that body is properly stringified
 */
function preparePayload(payload) {
    switch (typeof payload) {
        case "undefined":
            return "";
        case "object":
            return JSON.stringify(payload);
        default:
            return payload;
    }
}
class PacketInterface {
    constructor(channel, config) {
        this.config = config;
        this.activeRequests = new Map();
        this.channel = channel;
        this.channel.on("reply", (reply) => this.processReply(reply));
        this.channel.on("disconnected", () => {
            this.activeRequests.forEach((descriptor) => {
                clearTimeout(descriptor.timeout);
                descriptor.reject(new TwilsockError("disconnected"));
            });
            this.activeRequests.clear();
        });
    }
    get isConnected() {
        return this.channel.isConnected;
    }
    processReply(reply) {
        const request = this.activeRequests.get(reply.id);
        if (request) {
            clearTimeout(request.timeout);
            this.activeRequests.delete(reply.id);
            if (!isHttpSuccess$1(reply.status.code)) {
                request.reject(new TwilsockReplyError("Transport failure: " + reply.status.status, reply));
                logInstance.trace("message rejected");
            }
            else {
                request.resolve(reply);
            }
        }
    }
    storeRequest(id, resolve, reject) {
        const requestDescriptor = {
            resolve: resolve,
            reject: reject,
            timeout: setTimeout(() => {
                logInstance.trace("request", id, "is timed out");
                reject(new TwilsockError("Twilsock: request timeout: " + id));
            }, REQUEST_TIMEOUT$1),
        };
        this.activeRequests.set(id, requestDescriptor);
    }
    shutdown() {
        this.activeRequests.forEach((descriptor) => {
            clearTimeout(descriptor.timeout);
            descriptor.reject(new TwilsockError("Twilsock: request cancelled by user"));
        });
        this.activeRequests.clear();
    }
    async sendInit() {
        logInstance.trace("sendInit");
        const metadata = Metadata.getMetadata(this.config);
        const message = new Init(this.config.token, this.config.continuationToken, metadata, this.config.initRegistrations, this.config.tweaks);
        const response = await this.sendWithReply(message);
        return new InitReply(response.id, response.header.continuation_token, new Set(response.header.capabilities), response.header.continuation_token_status, response.header.offline_storage, response.header.init_registrations, response.header.debug_info);
    }
    sendClose() {
        const message = new Close();
        //@todo send telemetry AnyEventsIncludingUnfinished
        this.send(message);
    }
    sendWithReply(header, payload) {
        return new Promise((resolve, reject) => {
            const id = this.send(header, payload);
            this.storeRequest(id, resolve, reject);
        });
    }
    send(header, payload) {
        header.id = header.id || `TM${uuid.v4()}`;
        const message = Parser.createPacket(header, preparePayload(payload));
        try {
            this.channel.send(message);
            return header.id;
        }
        catch (e) {
            logInstance.debug("failed to send ", header, e);
            logInstance.trace(e.stack);
            throw e;
        }
    }
}

class WebSocketChannel extends EventEmitter {
    constructor(url) {
        super();
        this.url = url;
        this.socket = null;
        this.url = url;
        this.WebSocket =
            global["WebSocket"] || global["MozWebSocket"] || {};
    }
    get isConnected() {
        return !!this.socket && this.socket.readyState === 1;
    }
    connect() {
        logInstance.trace("connecting to socket");
        let socket;
        try {
            socket = new this.WebSocket(this.url);
        }
        catch (e) {
            logInstance.debug(`Socket error: ${this.url}`);
            this.emit("socketError", e);
            return;
        }
        socket.binaryType = "arraybuffer";
        socket.onopen = () => {
            logInstance.debug(`socket opened ${this.url}`);
            this.emit("connected");
        };
        socket.onclose = (e) => {
            logInstance.debug("socket closed", e);
            this.emit("disconnected", e);
        };
        socket.onerror = (e) => {
            logInstance.debug("Socket error:", e);
            this.emit("socketError", e);
        };
        socket.onmessage = (message) => {
            this.emit("message", message.data);
        };
        this.socket = socket;
    }
    send(message) {
        return this.socket && this.socket.send(message);
    }
    close() {
        logInstance.trace("closing socket");
        if (this.socket) {
            this.socket.onopen = null;
            this.socket.onclose = null;
            this.socket.onerror = null;
            this.socket.onmessage = null;
            try {
                this.socket.close();
            }
            finally {
            }
        }
    }
}

/**
 * Registrations module handles all operations with registration contexts through twilsock.
 * Main role: it automatically refreshes all registrations after reconnect.
 */
class Registrations extends EventEmitter {
    constructor(transport) {
        super();
        this.transport = transport;
        this.registrations = new Map();
        this.registrationsInProgress = new Map();
    }
    async putNotificationContext(contextId, context) {
        const header = {
            method: "put_notification_ctx",
            notification_ctx_id: contextId,
        };
        await this.transport.sendWithReply(header, context);
    }
    async deleteNotificationContext(contextId) {
        const message = {
            method: "delete_notification_ctx",
            notification_ctx_id: contextId,
        };
        await this.transport.sendWithReply(message);
    }
    async updateRegistration(contextId, context) {
        logInstance.debug("update registration for context", contextId);
        let registrationAttempts = this.registrationsInProgress.get(contextId);
        if (!registrationAttempts) {
            registrationAttempts = new Set();
            this.registrationsInProgress.set(contextId, registrationAttempts);
        }
        const attemptId = uuid.v4();
        registrationAttempts.add(attemptId);
        try {
            await this.putNotificationContext(contextId, context);
            logInstance.debug("registration attempt succeeded for context", context);
            registrationAttempts.delete(attemptId);
            if (registrationAttempts.size === 0) {
                this.registrationsInProgress.delete(contextId);
                this.emit("registered", contextId);
            }
        }
        catch (err) {
            logInstance.warn("registration attempt failed for context", context);
            logInstance.debug(err);
            registrationAttempts.delete(attemptId);
            if (registrationAttempts.size === 0) {
                this.registrationsInProgress.delete(contextId);
                this.emit("registrationFailed", contextId, err);
            }
        }
    }
    async updateRegistrations() {
        logInstance.trace(`refreshing ${this.registrations.size} registrations`);
        const promises = [];
        this.registrations.forEach((context, id) => {
            promises.push(this.updateRegistration(id, context));
        });
        await Promise.all(promises);
    }
    async setNotificationsContext(contextId, context) {
        if (!contextId || !context) {
            throw new TwilsockError("Invalid arguments provided");
        }
        this.registrations.set(contextId, context);
        return await this.updateRegistration(contextId, context);
    }
    async removeNotificationsContext(contextId) {
        if (!this.registrations.has(contextId)) {
            return;
        }
        await this.deleteNotificationContext(contextId);
        if (this.transport.isConnected) {
            this.registrations.delete(contextId);
        }
    }
}

class TwilsockUpstreamError extends TwilsockError {
    constructor(status, description, body) {
        super(description);
        this.status = status;
        this.description = description;
        this.body = body;
    }
}

class TransportUnavailableError extends TwilsockError {
    constructor(description) {
        super(description);
    }
}

const REQUEST_TIMEOUT = 20000;
function isHttpSuccess(code) {
    return code >= 200 && code < 300;
}
function isHttpReply(packet) {
    return packet && packet.header && packet.header.http_status;
}
function parseUri(uri) {
    const match = uri.match(/^(https?\:)\/\/(([^:\/?#]*)(?:\:([0-9]+))?)(\/[^?#]*)(\?[^#]*|)(#.*|)$/);
    if (match) {
        const uriStruct = {
            protocol: match[1],
            host: match[2],
            hostname: match[3],
            port: match[4],
            pathname: match[5],
            search: match[6],
            hash: match[7],
            params: {},
        };
        if (uriStruct.search.length > 0) {
            const paramsString = uriStruct.search.substring(1);
            uriStruct.params = paramsString
                .split("&")
                .map((el) => el.split("="))
                .reduce((prev, curr) => {
                if (!prev.hasOwnProperty(curr[0])) {
                    prev[curr[0]] = curr[1];
                }
                else if (Array.isArray(prev[curr[0]])) {
                    prev[curr[0]].push(curr[1]);
                }
                else {
                    prev[curr[0]] = [prev[curr[0]], curr[1]];
                }
                return prev;
            }, {});
        }
        return uriStruct;
    }
    throw new TwilsockError("Incorrect URI: " + uri);
}
function twilsockAddress(method, uri) {
    const parsedUri = parseUri(uri);
    const to = {
        method: method,
        host: parsedUri.host,
        path: parsedUri.pathname,
    };
    if (parsedUri.params) {
        to.params = parsedUri.params;
    }
    return to;
}
function twilsockParams(method, uri, headers, body, grant) {
    return {
        to: twilsockAddress(method, uri),
        headers: headers,
        body: body,
        grant: grant,
    };
}
class Upstream {
    constructor(transport, twilsock, config) {
        this.config = config;
        this.transport = transport;
        this.pendingMessages = [];
        this.twilsock = twilsock;
    }
    saveMessage(message) {
        return new Promise((resolve, reject) => {
            const requestDescriptor = {
                message,
                resolve,
                reject,
                alreadyRejected: false,
                timeout: setTimeout(() => {
                    logInstance.debug("request is timed out");
                    reject(new TwilsockError(`request '${message.to.method}' to '${message.to.host}' timed out`));
                    requestDescriptor.alreadyRejected = true;
                }, REQUEST_TIMEOUT),
            };
            this.pendingMessages.push(requestDescriptor);
        });
    }
    sendPendingMessages() {
        while (this.pendingMessages.length > 0) {
            const request = this.pendingMessages[0];
            // Do not send message if we've rejected its promise already
            if (!request.alreadyRejected) {
                try {
                    const message = request.message;
                    this.actualSend(message)
                        .then((response) => request.resolve(response))
                        .catch((e) => request.reject(e));
                    clearTimeout(request.timeout);
                }
                catch (e) {
                    logInstance.debug("Failed to send pending message", e);
                    break;
                }
            }
            this.pendingMessages.splice(0, 1);
        }
    }
    rejectPendingMessages() {
        this.pendingMessages.forEach((message) => {
            message.reject(new TransportUnavailableError(// @todo Error Unhandled promise rejection!
            "Unable to connect: " + this.twilsock.getTerminationReason));
            message.alreadyRejected = true;
            clearTimeout(message.timeout);
        });
        this.pendingMessages.splice(0, this.pendingMessages.length);
    }
    async actualSend(message) {
        var _a;
        const address = message.to;
        const headers = message.headers;
        const body = message.body;
        const grant = (_a = message.grant) !== null && _a !== void 0 ? _a : this.config.activeGrant;
        const httpRequest = {
            host: address.host,
            path: address.path,
            method: address.method,
            params: address.params,
            headers: headers,
        };
        const upstreamMessage = new Message(grant, headers["Content-Type"] || "application/json", httpRequest);
        logInstance.trace("Sending upstream message", upstreamMessage);
        const reply = await this.transport.sendWithReply(upstreamMessage, body);
        logInstance.trace("Received upstream message response", reply);
        if (isHttpReply(reply) && !isHttpSuccess(reply.header.http_status.code)) {
            throw new TwilsockUpstreamError(reply.header.http_status.code, reply.header.http_status.status, reply.body);
        }
        return {
            status: reply.header.http_status,
            headers: reply.header.http_headers,
            body: reply.body,
        };
    }
    /**
     * Send an upstream message
     * @param {string} method The upstream method
     * @param {string} url URL to send the message to
     * @param {object} [headers] The message headers
     * @param {any} [body] The message body
     * @param {string} [grant] The product grant
     * @returns {Promise<Result>} Result from remote side
     */
    send(method, url, headers = {}, body, grant) {
        if (this.twilsock.isTerminalState) {
            return Promise.reject(new TransportUnavailableError("Unable to connect: " + this.twilsock.getTerminationReason));
        }
        const twilsockMessage = twilsockParams(method, url, headers, body, grant);
        if (!this.twilsock.isConnected) {
            return this.saveMessage(twilsockMessage);
        }
        return this.actualSend(twilsockMessage);
    }
}

class Deferred {
    constructor() {
        this._promise = new Promise((resolve, reject) => {
            this._resolve = resolve;
            this._reject = reject;
        });
    }
    get promise() {
        return this._promise;
    }
    update(value) {
        this._resolve(value);
    }
    set(value) {
        this._resolve(value);
    }
    fail(e) {
        this._reject(e);
    }
}

class OfflineProductStorage {
    constructor(id) {
        this.id = id;
    }
    static create(productPayload) {
        if (productPayload instanceof Object && "storage_id" in productPayload) {
            return new OfflineProductStorage(productPayload.storage_id);
        }
        else {
            throw new TwilsockError('Field "storage_id" is missing');
        }
    }
}

class TokenStorage {
    constructor() {
        this.initializedFlag = "twilio_twilsock_token_storage";
        this.tokenStoragePrefix = "twilio_continuation_token_";
        if (!TokenStorage._instance) {
            this.initialize();
            TokenStorage._instance = this;
        }
        return TokenStorage._instance;
    }
    sessionStorage() {
        try {
            return global["sessionStorage"];
        }
        catch (err) {
            return null;
        }
    }
    window() {
        try {
            return global["window"];
        }
        catch (err) {
            return null;
        }
    }
    storeToken(continuationToken, productId) {
        if (this.canStore()) {
            this.sessionStorage.setItem(this.getKeyName(productId), continuationToken);
        }
    }
    getStoredToken(productId) {
        if (!this.canStore()) {
            return null;
        }
        return this.sessionStorage.getItem(this.getKeyName(productId));
    }
    initialize() {
        if (this.canStore()) {
            const flag = this.sessionStorage.getItem(this.initializedFlag);
            // Duplicated tab, cleaning up all stored keys
            if (flag) {
                this.clear();
            }
            this.sessionStorage.setItem(this.initializedFlag, "true");
            // When leaving page or refreshing
            const removeStorageItem = this.sessionStorage.removeItem;
            this.window.addEventListener("unload", () => {
                removeStorageItem(this.initializedFlag);
            });
        }
    }
    clear() {
        if (this.canStore()) {
            const keyToDelete = [];
            for (let i = 0; i < this.sessionStorage.length; i++) {
                const key = this.sessionStorage.key(i);
                // We manually removed startsWith here due to some problems with babel polyfill setup.
                // Restore it when we figure out what's wrong.
                //if (key.startsWith(TokenStorage.tokenStoragePrefix)) {
                if (key && key.indexOf(this.tokenStoragePrefix) === 0) {
                    keyToDelete.push(key);
                }
            }
            const removeStorageItem = this.sessionStorage.removeItem;
            keyToDelete.forEach((key) => removeStorageItem(key));
            removeStorageItem(this.initializedFlag);
        }
    }
    getKeyName(productId) {
        return `${this.tokenStoragePrefix}${productId}`;
    }
    canStore() {
        return !!(this.sessionStorage && this.sessionStorage.length && this.window);
    }
}
TokenStorage._instance = null;
var TokenStorage$1 = new TokenStorage();

class TelemetryEventDescription {
    constructor(title, details, start, end, type, id) {
        this.title = title;
        this.details = details;
        this.start = start;
        this.type = type;
        this.id = id;
        this.end = end;
    }
    // Prepare telemetry event right before sending it.
    // Convert times to relative.
    toTelemetryEvent() {
        // Fix dates
        const now = new Date();
        let actualStart = this.start;
        let actualEnd = this.end ? this.end : now;
        if (actualEnd < actualStart) {
            const tmp = actualEnd;
            actualEnd = actualStart;
            actualStart = tmp;
        }
        // Converting dates to relative offset from current moment in ms
        const startOffset = actualStart.getTime() - now.getTime();
        const endOffset = actualEnd.getTime() - now.getTime();
        const result = new TelemetryEvent(startOffset, endOffset, this.title, this.details, this.id, this.type);
        return result;
    }
}
exports.TelemetryPoint = void 0;
(function (TelemetryPoint) {
    TelemetryPoint[TelemetryPoint["Start"] = 0] = "Start";
    TelemetryPoint[TelemetryPoint["End"] = 1] = "End";
})(exports.TelemetryPoint || (exports.TelemetryPoint = {}));
exports.EventSendingLimitation = void 0;
(function (EventSendingLimitation) {
    EventSendingLimitation[EventSendingLimitation["MinEventsPortion"] = 0] = "MinEventsPortion";
    EventSendingLimitation[EventSendingLimitation["AnyEvents"] = 1] = "AnyEvents";
    EventSendingLimitation[EventSendingLimitation["AnyEventsIncludingUnfinished"] = 2] = "AnyEventsIncludingUnfinished";
})(exports.EventSendingLimitation || (exports.EventSendingLimitation = {}));
class TelemetryTracker {
    constructor(config, packetInterface) {
        // accumulated events count that is big enough to be sent out of schedule (not on timer but on new event registration)
        this.minEventsPortionToSend = 50;
        // max events batch size to be sent in a single Telemetry message
        this.maxEventsPortionToSend = 100;
        this.pendingEvents = new Map(); // started events: have TelemetryEvent::startTime only
        this.readyEvents = []; // events ready to send
        this.hasInitializationFinished = false;
        this._canSendTelemetry = false;
        this.config = config;
        this.packetInterface = packetInterface;
    }
    // Keeping this private prevents the type declaration from being generated properly.
    // Ideally, this should be private.
    get isTelemetryEnabled() {
        return this.config.confirmedCapabilities.has("telemetry.v1");
    }
    get canSendTelemetry() {
        return this._canSendTelemetry && this.isTelemetryEnabled;
    }
    set canSendTelemetry(enable) {
        logInstance.debug(`TelemetryTracker.canSendTelemetry: ${enable} TelemetryTracker.isTelemetryEnabled: ${this.isTelemetryEnabled}`);
        // We want to keep telemetry events added in advance but
        // we need to purge events from previous connection when being disconnected
        if (this._canSendTelemetry && !enable) {
            this.pendingEvents.clear();
            this.readyEvents = [];
        }
        this._canSendTelemetry = enable;
        if (enable) {
            this.sendTelemetry(exports.EventSendingLimitation.AnyEvents);
        }
        if (enable && !this.hasInitializationFinished) {
            this.hasInitializationFinished = true;
        }
    }
    // Add complete event
    addTelemetryEvent(event) {
        // Allow adding events before initialization.
        if (!this.canSendTelemetry && this.hasInitializationFinished) {
            return;
        }
        this.readyEvents.push(event);
    }
    // Add incomplete event (with either starting or ending time point)
    addPartialEvent(incompleteEvent, eventKey, point) {
        logInstance.debug(`Adding ${point === exports.TelemetryPoint.Start ? "starting" : "ending"} timepoint for '${eventKey}' event`);
        const exists = this.pendingEvents.has(eventKey);
        if (point === exports.TelemetryPoint.Start) {
            if (exists) {
                logInstance.debug(`Overwriting starting point for '${eventKey}' event`);
            }
            this.pendingEvents.set(eventKey, incompleteEvent);
        }
        else {
            if (!exists) {
                logInstance.info(`Could not find started event for '${eventKey}' event`);
                return;
            }
            this.addTelemetryEvent(this.merge(this.pendingEvents.get(eventKey), incompleteEvent));
            this.pendingEvents.delete(eventKey);
        }
    }
    getTelemetryToSend(sendingLimit) {
        if (!this.canSendTelemetry || this.readyEvents.length == 0) {
            return []; // Events are collected but not sent until telemetry is enabled
        }
        if (sendingLimit == exports.EventSendingLimitation.MinEventsPortion &&
            this.readyEvents.length < this.minEventsPortionToSend) {
            return [];
        }
        return this.getTelemetryPortion(sendingLimit == exports.EventSendingLimitation.AnyEventsIncludingUnfinished);
    }
    getTelemetryPortion(includeUnfinished) {
        const eventsPortionToSend = Math.min(this.readyEvents.length, this.maxEventsPortionToSend);
        const res = this.readyEvents.splice(0, eventsPortionToSend);
        if (includeUnfinished && res.length < this.maxEventsPortionToSend) {
            this.pendingEvents.forEach((value, key) => {
                if (res.length >= this.maxEventsPortionToSend) {
                    return; // @fixme does not end the loop early
                }
                const event = this.pendingEvents.get(key);
                this.pendingEvents.delete(key);
                res.push(new TelemetryEventDescription(`[UNFINISHED] ${event.title}`, // add prefix title to mark unfinished events for CleanSock
                event.details, event.start, null, // Not ended, on sending will be replaced with now
                event.type, event.id));
            });
        }
        return res;
    }
    // Merging 2 partial events:
    //   use start.startTime & end.endTime.
    // For other fields,
    //   if there are values in end, use them,
    //   else use values from start.
    merge(start, end) {
        return new TelemetryEventDescription(end.title ? end.title : start.title, end.details ? end.details : start.details, start.start, end.end, end.type ? end.type : start.type, end.id ? end.id : start.id);
    }
    sendTelemetryIfMinimalPortionCollected() {
        this.sendTelemetry(exports.EventSendingLimitation.MinEventsPortion);
    }
    // NB: getTelemetryToSend will return non-empty array only if we have already received initReply
    // and telemetry.v1 capability is enabled there.
    sendTelemetry(limit) {
        const events = this.getTelemetryToSend(limit);
        if (events.length === 0) {
            return; // not enough telemetry data collected
        }
        try {
            this.packetInterface.send(new Telemetry(events.map((e) => e.toTelemetryEvent())));
        }
        catch (err) {
            logInstance.debug(`Error while sending ${events.length} telemetry events due to ${err}; they will be resubmitted`);
            this.readyEvents = this.readyEvents.concat(events);
        }
    }
}

class TelemetryEvents {
}
TelemetryEvents.TWILSOCK_CONNECT = "twilsock.sdk.connect"; // establish WebSocket connection (with WebSocket handshake finished)
TelemetryEvents.TWILSOCK_INIT = "twilsock.sdk.init"; // send "init" message and receive reply
/**
 * @alias Twilsock
 * @classdesc Client library for the Twilsock service
 * It allows to recevie service-generated updates as well as bi-directional transport
 * @fires Twilsock#message
 * @fires Twilsock#connected
 * @fires Twilsock#disconnected
 * @fires Twilsock#tokenAboutToExpire
 * @fires Twilsock#tokenExpired
 * @fires Twilsock#stateChanged
 * @fires Twilsock#connectionError
 */
exports.TwilsockClient = class TwilsockClient extends EventEmitter {
    /**
     * @param {string} token Twilio access token
     * @param {string} productId Product identifier. Should be the same as a grant name in token
     * @param {object} options Twilsock configuration options
     */
    constructor(token, productId, options) {
        super();
        this.version = version;
        this.offlineStorageDeferred = new Deferred();
        options.continuationToken = options.continuationToken
            ? options.continuationToken
            : TokenStorage$1.getStoredToken(productId);
        const config = (this.config = new Configuration(token, productId, options));
        logInstance.setLevel(config.logLevel);
        const websocket = new WebSocketChannel(config.url);
        const transport = new PacketInterface(websocket, config);
        this.channel = new TwilsockChannel(websocket, transport, config);
        this.registrations = new Registrations(transport);
        this.upstream = new Upstream(transport, this.channel, config);
        // Send telemetry only when connected and initialised
        this.telemetryTracker = new TelemetryTracker(config, transport);
        this.channel.on("initialized", () => (this.telemetryTracker.canSendTelemetry = true));
        websocket.on("disconnected", () => (this.telemetryTracker.canSendTelemetry = false));
        this.registrations.on("registered", (id) => this.emit("registered", id));
        this.channel.on("message", (type, message) => setTimeout(() => this.emit("message", type, message), 0));
        this.channel.on("stateChanged", (state) => setTimeout(() => this.emit("stateChanged", state), 0));
        this.channel.on("connectionError", (connectionError) => setTimeout(() => this.emit("connectionError", connectionError), 0));
        this.channel.on("tokenAboutToExpire", () => setTimeout(() => this.emit("tokenAboutToExpire"), 0));
        this.channel.on("tokenExpired", () => setTimeout(() => this.emit("tokenExpired"), 0));
        this.channel.on("connected", () => this.registrations.updateRegistrations());
        this.channel.on("connected", () => this.upstream.sendPendingMessages());
        this.channel.on("connected", () => setTimeout(() => this.emit("connected"), 0));
        // Twilsock telemetry events
        this.channel.on("beforeConnect", () => this.telemetryTracker.addPartialEvent(new TelemetryEventDescription("Establish WebSocket connection", "", new Date()), TelemetryEvents.TWILSOCK_CONNECT, exports.TelemetryPoint.Start));
        this.channel.on("connected", () => this.telemetryTracker.addPartialEvent(new TelemetryEventDescription("Establish WebSocket connection", "", new Date(), new Date()), TelemetryEvents.TWILSOCK_CONNECT, exports.TelemetryPoint.End));
        this.channel.on("beforeSendInit", () => this.telemetryTracker.addPartialEvent(new TelemetryEventDescription("Send Twilsock init", "", new Date()), TelemetryEvents.TWILSOCK_INIT, exports.TelemetryPoint.Start));
        this.channel.on("initialized", () => this.telemetryTracker.addPartialEvent(new TelemetryEventDescription("Send Twilsock init", "Succeeded", new Date(), new Date()), TelemetryEvents.TWILSOCK_INIT, exports.TelemetryPoint.End));
        this.channel.on("sendInitFailed", () => this.telemetryTracker.addPartialEvent(new TelemetryEventDescription("Send Twilsock init", "Failed", new Date(), new Date()), TelemetryEvents.TWILSOCK_INIT, exports.TelemetryPoint.End));
        this.channel.on("initialized", (initReply) => {
            this.handleStorageId(productId, initReply);
            TokenStorage$1.storeToken(initReply.continuationToken, productId);
            setTimeout(() => this.emit("initialized", initReply), 0);
        });
        this.channel.on("disconnected", () => setTimeout(() => this.emit("disconnected"), 0));
        this.channel.on("disconnected", () => this.upstream.rejectPendingMessages());
        this.channel.on("disconnected", () => this.offlineStorageDeferred.fail(new TwilsockError("Client disconnected")));
        this.offlineStorageDeferred.promise.catch(() => void 0);
    }
    emit(event, ...args) {
        logInstance.debug(`Emitting ${event.toString()}(${args
            .map((a) => JSON.stringify(a))
            .join(", ")})`);
        return super.emit(event, ...args);
    }
    handleStorageId(productId, initReply) {
        if (!initReply.offlineStorage) {
            this.offlineStorageDeferred.fail(new TwilsockError("No offline storage id"));
        }
        else if (initReply.offlineStorage.hasOwnProperty(productId)) {
            try {
                this.offlineStorageDeferred.set(OfflineProductStorage.create(initReply.offlineStorage[productId]));
                logInstance.debug(`Offline storage for '${productId}' product: ${JSON.stringify(initReply.offlineStorage[productId])}.`);
            }
            catch (e) {
                this.offlineStorageDeferred.fail(new TwilsockError(`Failed to parse offline storage for ${productId} ${JSON.stringify(initReply.offlineStorage[productId])}. ${e}.`));
            }
        }
        else {
            this.offlineStorageDeferred.fail(new TwilsockError(`No offline storage id for '${productId}' product: ${JSON.stringify(initReply.offlineStorage)}`));
        }
    }
    /**
     * Get offline storage ID
     * @returns {Promise}
     */
    storageId() {
        return this.offlineStorageDeferred.promise;
    }
    /**
     * Indicates if twilsock is connected now
     * @returns {Boolean}
     */
    get isConnected() {
        return this.channel.isConnected;
    }
    /**
     * Current state
     * @returns {ConnectionState}
     */
    get state() {
        return this.channel.state;
    }
    /**
     * Update token
     * @param {String} token
     * @returns {Promise}
     */
    async updateToken(token) {
        logInstance.trace(`updating token '${token}'`);
        if (this.config.token === token) {
            return;
        }
        this.config.updateToken(token);
        return await this.channel.updateToken(token);
    }
    /**
     * Updates notification context.
     * This method shouldn't be used anyone except twilio notifications library
     * @param contextId id of notification context
     * @param context value of notification context
     * @private
     */
    async setNotificationsContext(contextId, context) {
        await this.registrations.setNotificationsContext(contextId, context);
    }
    /**
     * Remove notification context.
     * This method shouldn't be used anyone except twilio notifications library
     * @param contextId id of notification context
     * @private
     */
    async removeNotificationsContext(contextId) {
        await this.registrations.removeNotificationsContext(contextId);
    }
    /**
     * Connect to the server
     * @fires Twilsock#connected
     * @public
     * @returns {void}
     */
    connect() {
        return this.channel.connect();
    }
    /**
     * Disconnect from the server
     * @fires Twilsock#disconnected
     * @public
     * @returns {Promise}
     */
    async disconnect() {
        this.telemetryTracker.sendTelemetry(exports.EventSendingLimitation.AnyEventsIncludingUnfinished);
        return await this.channel.disconnect();
    }
    /**
     * Get HTTP request to upstream service
     * @param {string} url Upstream service url
     * @param {headers} headers Set of custom headers
     * @param {string} [grant] The product grant
     * @returns {Promise}
     */
    async get(url, headers, grant) {
        this.telemetryTracker.sendTelemetry(exports.EventSendingLimitation.AnyEvents); // send collected telemetry (if any) before upstream message shipment
        return await this.upstream.send("GET", url, headers, undefined, grant);
    }
    /**
     * Post HTTP request to upstream service
     * @param {string} url Upstream service url
     * @param {headers} headers Set of custom headers
     * @param {body} body Body to send
     * @param {string} [grant] The product grant
     * @returns {Promise}
     */
    async post(url, headers, body, grant) {
        this.telemetryTracker.sendTelemetry(exports.EventSendingLimitation.AnyEvents); // send collected telemetry (if any) before upstream message shipment
        return (await this.upstream.send("POST", url, headers, body, grant));
    }
    /**
     * Put HTTP request to upstream service
     * @param {string} url Upstream service url
     * @param {headers} headers Set of custom headers
     * @param {body} body Body to send
     * @param {string} [grant] The product grant
     * @returns {Promise}
     */
    async put(url, headers, body, grant) {
        this.telemetryTracker.sendTelemetry(exports.EventSendingLimitation.AnyEvents); // send collected telemetry (if any) before upstream message shipment
        return (await this.upstream.send("PUT", url, headers, body, grant));
    }
    /**
     * Delete HTTP request to upstream service
     * @param {string} url Upstream service url
     * @param {headers} headers Set of custom headers
     * @param {body} body Body to send
     * @param {string} [grant] The product grant
     * @returns {Promise}
     */
    async delete(url, headers, body, grant) {
        this.telemetryTracker.sendTelemetry(exports.EventSendingLimitation.AnyEvents); // send collected telemetry (if any) before upstream message shipment
        return (await this.upstream.send("DELETE", url, headers, body, grant));
    }
    /**
     * Submits internal telemetry event. Not to be used for any customer and/or sensitive data.
     * @param {TelemetryEventDescription} event Event details.
     * @returns {void}
     */
    addTelemetryEvent(event) {
        this.telemetryTracker.addTelemetryEvent(event);
        this.telemetryTracker.sendTelemetryIfMinimalPortionCollected(); // send telemetry if need
    }
    /**
     * Submits internal telemetry event. Not to be used for any customer and/or sensitive data.
     * @param {TelemetryEventDescription} event Event details.
     * @param {string} eventKey Unique event key.
     * @param {TelemetryPoint} point Is this partial event for start or end of measurement.
     * @returns {void}
     */
    addPartialTelemetryEvent(event, eventKey, point) {
        this.telemetryTracker.addPartialEvent(event, eventKey, point);
        if (point === exports.TelemetryPoint.End) {
            // this telemetry event is complete, so minimal portion could become ready to send
            this.telemetryTracker.sendTelemetryIfMinimalPortionCollected(); // send telemetry if need
        }
    }
};
exports.TwilsockClient = __decorate([
    declarativeTypeValidator.validateConstructorTypes(declarativeTypeValidator.nonEmptyString, declarativeTypeValidator.nonEmptyString, [
        declarativeTypeValidator.pureObject,
        "undefined",
        declarativeTypeValidator.literal(null),
    ]),
    __metadata("design:paramtypes", [String, String, Object])
], exports.TwilsockClient);
/**
 * Twilsock destination address descriptor
 * @typedef {Object} Twilsock#Address
 * @property {String} method - HTTP method. (POST, PUT, etc)
 * @property {String} host - host name without path. (e.g. my.company.com)
 * @property {String} path - path on the host (e.g. /my/app/to/call.php)
 */
/**
 * Twilsock upstream message
 * @typedef {Object} Twilsock#Message
 * @property {Twilsock#Address} to - destination address
 * @property {Object} headers - HTTP headers
 * @property {Object} body - Body
 */
/**
 * Fired when new message received
 * @param {Twilsock#Message} message
 * @event Twilsock#message
 */
/**
 * Fired when socket connected
 * @param {String} URI of endpoint
 * @event Twilsock#connected
 */
/**
 * Fired when socket disconnected
 * @event Twilsock#disconnected
 */
/**
 * Fired when token is about to expire and should be updated
 * @event Twilsock#tokenAboutToExpire
 */
/**
 * Fired when token has expired and connection is aborted
 * @event Twilsock#tokenExpired
 */
/**
 * Fired when socket connected
 * @param ConnectionState state - general twilsock state
 * @event Twilsock#stateChanged
 */
/**
 * Fired when connection is interrupted by unexpected reason
 * @type {Object}
 * @property {Boolean} terminal - twilsock will stop connection attempts
 * @property {String} message - root cause
 * @property {Number} [httpStatusCode] - http status code if available
 * @property {Number} [errorCode] - Twilio public error code if available
 * @event Twilsock#connectionError
 */

class InitRegistration {
    constructor(product) {
        this.product = product;
        this.type = "ers";
        this.notification_protocol_version = 0;
        this.message_types = [];
    }
    /*
     * @internal
     *
     * Populate init registrations section in the Twilsock configuration generically with
     * passed-in list of types to register.
     *
     * Used only by the SDK, ignore.
     *
     * @param {string[]} types List of types to add to init registrations in options.
     * @param {object} options Twilsock options object to update. Omit to create a new one.
     */
    populateInitRegistrations(types) {
        const s = new Set(this.message_types);
        // Update options reference in place
        for (const idx in types) {
            s.add(types[idx]);
        }
        this.message_types = Array.from(s);
    }
}

exports.InitRegistration = InitRegistration;
exports.TelemetryEventDescription = TelemetryEventDescription;
exports.TelemetryTracker = TelemetryTracker;
exports.TransportUnavailableError = TransportUnavailableError;
exports.Twilsock = exports.TwilsockClient;
exports.TwilsockError = TwilsockError;
//# sourceMappingURL=react-native.js.map
