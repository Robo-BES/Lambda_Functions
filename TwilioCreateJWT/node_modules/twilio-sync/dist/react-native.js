/*
@license
The following license applies to all parts of this software except as
documented below.

    Copyright (c) 2016, Twilio, inc.
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are
    met:

      1. Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.

      2. Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in
         the documentation and/or other materials provided with the
         distribution.

      3. Neither the name of Twilio nor the names of its contributors may
         be used to endorse or promote products derived from this software
         without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This software includes loglevel under the following license.

    Copyright (c) 2013 Tim Perry

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without
    restriction, including without limitation the rights to use,
    copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following
    conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.

This software includes Backoff library under the following license

    Copyright (C) 2012 Mathieu Turcotte

    Permission is hereby granted, free of charge, to any person obtaining a copy of
    this software and associated documentation files (the "Software"), to deal in
    the Software without restriction, including without limitation the rights to
    use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
    of the Software, and to permit persons to whom the Software is furnished to do
    so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.

This software includes Event-to-Promise library under the following license

    Copyright (c) 2014, Julien Fontanet <julien.fontanet@isonoe.net>.

    Permission to use, copy, modify, and/or distribute this software for any purpose
    with or without fee is hereby granted, provided that the above copyright notice
    and this permission notice appear in all copies.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
    FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
    OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
    TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
    THIS SOFTWARE.

*/
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var declarativeTypeValidator = require('@twilio/declarative-type-validator');
var twilsock = require('twilsock');
var loglevelLog = require('loglevel');
var operationRetrier = require('@twilio/operation-retrier');
var uuid = require('uuid');
var platform = require('platform');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () {
                        return e[k];
                    }
                });
            }
        });
    }
    n['default'] = e;
    return Object.freeze(n);
}

var loglevelLog__namespace = /*#__PURE__*/_interopNamespace(loglevelLog);
var uuid__namespace = /*#__PURE__*/_interopNamespace(uuid);
var platform__namespace = /*#__PURE__*/_interopNamespace(platform);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

var domain;

// This constructor is used to store event handlers. Instantiating this is
// faster than explicitly calling `Object.create(null)` to get a "clean" empty
// object (tested with v8 v4.9).
function EventHandlers() {}
EventHandlers.prototype = Object.create(null);

function EventEmitter() {
  EventEmitter.init.call(this);
}

// nodejs oddity
// require('events') === require('events').EventEmitter
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.usingDomains = false;

EventEmitter.prototype.domain = undefined;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

EventEmitter.init = function() {
  this.domain = null;
  if (EventEmitter.usingDomains) {
    // if there is an active domain, then attach to it.
    if (domain.active ) ;
  }

  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers();
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events, domain;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  domain = this.domain;

  // If there is no 'error' event listener then throw.
  if (doError) {
    er = arguments[1];
    if (domain) {
      if (!er)
        er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain;
      er.domainThrown = false;
      domain.emit('error', er);
    } else if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] :
                                          [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
                            existing.length + ' ' + type + ' listeners added. ' +
                            'Use emitter.setMaxListeners() to increase limit');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }

  return target;
}
function emitWarning(e) {
  typeof console.warn === 'function' ? console.warn(e) : console.log(e);
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function _onceWrap(target, type, listener) {
  var fired = false;
  function g() {
    target.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || (list.listener && list.listener === listener)) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length; i-- > 0;) {
          if (list[i] === listener ||
              (list[i].listener && list[i].listener === listener)) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (list.length === 1) {
          list[0] = undefined;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };
    
// Alias for removeListener added in NodeJS 10.0
// https://nodejs.org/api/events.html#events_emitter_off_eventname_listener
EventEmitter.prototype.off = function(type, listener){
    return this.removeListener(type, listener);
};

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        for (var i = 0, key; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        do {
          this.removeListener(type, listeners[listeners.length - 1]);
        } while (listeners[0]);
      }

      return this;
    };

EventEmitter.prototype.listeners = function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;

  if (!events)
    ret = [];
  else {
    evlistener = events[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === 'function')
      ret = [evlistener.listener || evlistener];
    else
      ret = unwrapListeners(evlistener);
  }

  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, i) {
  var copy = new Array(i);
  while (i--)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

/**
 * Construct URI with query parameters
 */
class UriBuilder {
    constructor(base) {
        this.base = base;
        this.args = new Array();
        this.paths = new Array();
    }
    pathSegment(name) {
        this.paths.push(encodeURIComponent(name));
        return this;
    }
    queryParam(name, value) {
        if (typeof value !== 'undefined') {
            this.args.push(encodeURIComponent(name) + '=' + encodeURIComponent(value));
        }
        return this;
    }
    build() {
        let result = this.base;
        if (this.paths.length) {
            result += '/' + this.paths.join('/');
        }
        if (this.args.length) {
            result += '?' + this.args.join('&');
        }
        return result;
    }
}

/**
 * Generic SyncLibrary error class
 */
class SyncError extends Error {
    constructor(message, status = 0, code = 0) {
        super();
        this.name = this.constructor.name;
        this.message = `${message} (status: ${status}, code: ${code})`;
        this.status = status;
        this.code = code;
    }
}
class SyncNetworkError extends SyncError {
    constructor(message, status = 0, code = 0, body) {
        super(message, status, code);
        this.body = body;
    }
}

/**
 * Deep-clone an object. Note that this does not work on object containing
 * functions.
 * @param {object} obj - the object to deep-clone
 * @return {object}
 */
function deepClone(obj) {
    return JSON.parse(JSON.stringify(obj));
}
function validatePageSize(pageSize) {
    const validPageSize = pageSize === undefined || isPositiveInteger(pageSize);
    if (!validPageSize) {
        throw new SyncError(`Invalid pageSize parameter. Expected a positive integer, was '${pageSize}'.`, 400, 20007);
    }
}
function isInteger(number) {
    return !isNaN(parseInt(number)) && isFinite(number);
}
function isPositiveInteger(number) {
    return isInteger(number) && number > 0;
}

const log = loglevelLog__namespace.getLogger('twilio-sync'); // twilio-sync is used by Flex SDK. Please DO NOT change
function prepareLine(prefix, args) {
    return [`${new Date().toISOString()} Sync ${prefix}:`].concat(Array.from(args));
}
var log$1 = {
    setLevel: function (level) {
        log.setLevel(level);
    },
    trace: function (...args) {
        log.trace.apply(null, prepareLine('T', args));
    },
    debug: function (...args) {
        log.debug.apply(null, prepareLine('D', args));
    },
    info: function (...args) {
        log.info.apply(null, prepareLine('I', args));
    },
    warn: function (...args) {
        log.warn.apply(null, prepareLine('W', args));
    },
    error: function (...args) {
        log.error.apply(null, prepareLine('E', args));
    }
};

const SUBSCRIPTIONS_PATH = '/v4/Subscriptions';
const MAPS_PATH = '/v3/Maps';
const LISTS_PATH = '/v3/Lists';
const DOCUMENTS_PATH = '/v3/Documents';
const STREAMS_PATH = '/v3/Streams';
const INSIGHTS_PATH = '/v3/Insights';
function getWithDefault(container, key, defaultValue) {
    if (container && typeof container[key] !== 'undefined') {
        return container[key];
    }
    return defaultValue;
}
/**
 * Settings container for Sync library
 */
class Configuration {
    /**
     * @param {Object} options
     */
    constructor(options = {}) {
        const region = options.region || 'us1';
        const defaultCdsUrl = `https://cds.${region}.twilio.com`;
        const baseUri = options.cdsUri || defaultCdsUrl;
        this.settings = {
            subscriptionsUri: baseUri + SUBSCRIPTIONS_PATH,
            documentsUri: baseUri + DOCUMENTS_PATH,
            listsUri: baseUri + LISTS_PATH,
            mapsUri: baseUri + MAPS_PATH,
            streamsUri: baseUri + STREAMS_PATH,
            insightsUri: baseUri + INSIGHTS_PATH,
            sessionStorageEnabled: getWithDefault(options.Sync, 'enableSessionStorage', true),
            productId: options.productId,
        };
    }
    get subscriptionsUri() {
        return this.settings.subscriptionsUri;
    }
    get documentsUri() {
        return this.settings.documentsUri;
    }
    get listsUri() {
        return this.settings.listsUri;
    }
    get mapsUri() {
        return this.settings.mapsUri;
    }
    get streamsUri() {
        return this.settings.streamsUri;
    }
    get insightsUri() {
        return this.settings.insightsUri;
    }
    get backoffConfig() {
        return this.settings.backoffConfig || {};
    }
    get sessionStorageEnabled() {
        return this.settings.sessionStorageEnabled;
    }
    get productId() {
        return this.settings.productId;
    }
}

/**
 * A data container used by the Subscriptions class to track subscribed entities' local
 * representations and their state.
 */
class SubscribedEntity {
    constructor(entity) {
        this.localObject = entity;
        this.pendingCorrelationId = null;
        this.pendingAction = null;
        this.established = false;
        this.retryCount = 0;
    }
    get sid() {
        return this.localObject.sid;
    }
    get type() {
        return this.localObject.type;
    }
    get lastEventId() {
        return this.localObject.lastEventId;
    }
    // below properties are specific to Insights only
    get indexName() {
        return this.localObject.indexName;
    }
    get queryString() {
        return this.localObject.queryString;
    }
    get isEstablished() {
        return this.established;
    }
    update(event, isStrictlyOrdered) {
        this.localObject._update(event, isStrictlyOrdered);
    }
    updatePending(action, correlationId) {
        this.pendingAction = action;
        this.pendingCorrelationId = correlationId;
    }
    reset() {
        this.updatePending(null, null);
        this.retryCount = 0;
        this.established = false;
        this.setSubscriptionState('none');
    }
    markAsFailed(message) {
        this.rejectedWithError = message.error;
        this.updatePending(null, null);
        this.localObject.reportFailure(new SyncError(`Failed to subscribe on service events: ${message.error.message}`, message.error.status, message.error.code));
    }
    complete(eventId) {
        this.updatePending(null, null);
        this.established = true;
        this.localObject._advanceLastEventId(eventId);
    }
    setSubscriptionState(newState) {
        this.localObject._setSubscriptionState(newState);
    }
}
/**
 * @class Subscriptions
 * @classdesc A manager which, in batches of varying size, continuously persists the
 *      subscription intent of the caller to the Sync backend until it achieves a
 *      converged state.
 */
class Subscriptions {
    /**
     * @constructor
     * Prepares a new Subscriptions manager object with zero subscribed or persisted subscriptions.
     *
     * @param {object} config may include a key 'backoffConfig', wherein any of the parameters
     *      of Backoff.exponential (from npm 'backoff') are valid and will override the defaults.
     *
     * @param {Network} must be a viable running Sync Network object, useful for routing requests.
     */
    constructor(services) {
        this.isConnected = false;
        this.maxBatchSize = 100;
        // If the server includes a `ttl_in_s` attribute in the poke response, subscriptionTtlTimer is started for that duration
        // such that when it fires, it repokes the entire sync set (i.e., emulates a reconnect). Every reconnect resets the timer.
        // After the timer has fired, the first poke request includes a `reason: ttl` attribute in the body.
        this.subscriptionTtlTimer = null;
        this.pendingPokeReason = null;
        this.services = services;
        this.subscriptions = new Map();
        this.persisted = new Map();
        this.latestPokeResponseArrivalTimestampByCorrelationId = new Map();
        const defaultBackoffConfig = {
            randomisationFactor: 0.2,
            initialDelay: 100,
            maxDelay: 2 * 60 * 1000
        };
        this.backoff = operationRetrier.Backoff.exponential(Object.assign(defaultBackoffConfig, this.services.config.backoffConfig));
        // This block is triggered by #_persist. Every request is executed in a series of (ideally 1)
        // backoff 'ready' event, at which point a new subscription set is calculated.
        this.backoff.on('ready', () => {
            let { action: action, subscriptions: subscriptionRequests } = this.getSubscriptionUpdateBatch();
            if (action) {
                this.applyNewSubscriptionUpdateBatch(action, subscriptionRequests);
            }
            else {
                this.backoff.reset();
                log$1.debug('All subscriptions resolved.');
            }
        });
    }
    getSubscriptionUpdateBatch() {
        function subtract(these, those, action, limit) {
            let result = [];
            for (let [thisKey, thisValue] of these) {
                const otherValue = those.get(thisKey);
                if (!otherValue && action !== thisValue.pendingAction && !thisValue.rejectedWithError) {
                    result.push(thisValue);
                    if (limit && result.length >= limit) {
                        break;
                    }
                }
            }
            return result;
        }
        let listToAdd = subtract(this.subscriptions, this.persisted, 'establish', this.maxBatchSize);
        if (listToAdd.length > 0) {
            return { action: 'establish', subscriptions: listToAdd };
        }
        let listToRemove = subtract(this.persisted, this.subscriptions, 'cancel', this.maxBatchSize);
        if (listToRemove.length > 0) {
            return { action: 'cancel', subscriptions: listToRemove };
        }
        return { action: null, subscriptions: null };
    }
    persist() {
        this.backoff.backoff();
    }
    async applyNewSubscriptionUpdateBatch(action, requests) {
        if (!this.isConnected) {
            log$1.debug(`Twilsock connection (required for subscription) not ready; waiting…`);
            this.backoff.reset();
            return;
        }
        // Keeping in mind that events may begin flowing _before_ we receive the response
        requests = this.processLocalActions(action, requests);
        const correlationId = new Date().getTime();
        for (const subscribed of requests) {
            this.recordActionAttemptOn(subscribed, action, correlationId);
        }
        let reason = this.pendingPokeReason;
        this.pendingPokeReason = null;
        // Send this batch to the service
        try {
            let response = await this.request(action, correlationId, reason, requests);
            let newMaxBatchSize = response.body.max_batch_size;
            if (!isNaN(parseInt(newMaxBatchSize)) && isFinite(newMaxBatchSize) && newMaxBatchSize > 0) {
                this.maxBatchSize = newMaxBatchSize;
            }
            if (!this.subscriptionTtlTimer) {
                let subscriptionTtlInS = response.body.ttl_in_s;
                let isNumeric = !isNaN(parseFloat(subscriptionTtlInS)) && isFinite(subscriptionTtlInS);
                let isValidTtl = isNumeric && subscriptionTtlInS > 0;
                if (isValidTtl) {
                    this.subscriptionTtlTimer = setTimeout(() => this.onSubscriptionTtlElapsed(), subscriptionTtlInS * 1000);
                }
            }
            if (action === 'establish') {
                const estimatedDeliveryInMs = response.body.estimated_delivery_in_ms;
                let isNumeric = !isNaN(parseFloat(estimatedDeliveryInMs)) && isFinite(estimatedDeliveryInMs);
                let isValidTimeout = isNumeric && estimatedDeliveryInMs > 0;
                if (isValidTimeout) {
                    setTimeout(() => this.verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests), estimatedDeliveryInMs);
                }
                else {
                    log$1.error(`Invalid timeout: ${estimatedDeliveryInMs}`);
                }
                requests.filter(r => r.pendingCorrelationId === correlationId)
                    .forEach(r => r.setSubscriptionState('response_in_flight'));
            }
            this.backoff.reset();
        }
        catch (e) {
            for (const attemptedSubscription of requests) {
                this.recordActionFailureOn(attemptedSubscription, action);
            }
            if (e instanceof twilsock.TransportUnavailableError) {
                log$1.debug(`Twilsock connection (required for subscription) not ready (c:${correlationId}); waiting…`);
                this.backoff.reset();
            }
            else {
                log$1.debug(`Failed an attempt to ${action} subscriptions (c:${correlationId}); retrying`, e);
                this.persist();
            }
        }
    }
    verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests) {
        const lastReceived = this.latestPokeResponseArrivalTimestampByCorrelationId.get(correlationId);
        const silencePeriod = lastReceived ? (new Date().getTime() - lastReceived)
            : estimatedDeliveryInMs;
        if (silencePeriod >= estimatedDeliveryInMs) {
            // If we haven't received _any_ responses from that poke request for the duration of estimated_delivery_in_ms, poke again
            requests
                .filter(r => r.pendingCorrelationId === correlationId)
                .forEach(r => {
                r.updatePending(null, null);
                r.retryCount++;
                this.persisted.delete(r.sid);
            });
            this.persist();
            this.latestPokeResponseArrivalTimestampByCorrelationId.delete(correlationId);
        }
        else {
            // Otherwise, the poke responses are probably in transit and we should wait for them
            const timeoutExtension = estimatedDeliveryInMs - silencePeriod;
            setTimeout(() => this.verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests), timeoutExtension);
        }
    }
    processLocalActions(action, requests) {
        if (action === 'cancel') {
            return requests.filter(request => !request.rejectedWithError);
        }
        return requests;
    }
    recordActionAttemptOn(attemptedSubscription, action, correlationId) {
        attemptedSubscription.setSubscriptionState('request_in_flight');
        if (action === 'establish') {
            this.persisted.set(attemptedSubscription.sid, attemptedSubscription);
            attemptedSubscription.updatePending(action, correlationId);
        }
        else { // cancel
            let persistedSubscription = this.persisted.get(attemptedSubscription.sid);
            if (persistedSubscription) {
                persistedSubscription.updatePending(action, correlationId);
            }
        }
    }
    recordActionFailureOn(attemptedSubscription, action) {
        attemptedSubscription.setSubscriptionState('none');
        attemptedSubscription.updatePending(null, null);
        if (action === 'establish') {
            this.persisted.delete(attemptedSubscription.sid);
        }
    }
    request(action, correlationId, reason, objects) {
        let requests = objects.map(object => ({
            object_sid: object.sid,
            object_type: object.type,
            last_event_id: action === 'establish' ? object.lastEventId : undefined,
            index_name: action === 'establish' ? object.indexName : undefined,
            query_string: action === 'establish' ? object.queryString : undefined,
        }));
        let retriedRequests = objects.filter(a => a.retryCount > 0).length;
        log$1.debug(`Attempting '${action}' request (c:${correlationId}):`, requests);
        const requestBody = {
            event_protocol_version: 3,
            action,
            correlation_id: correlationId,
            retried_requests: retriedRequests,
            ttl_in_s: -1,
            requests
        };
        if (reason === 'ttl') {
            requestBody.reason = reason;
        }
        return this.services.network.post(this.services.config.subscriptionsUri, requestBody);
    }
    /**
     * Establishes intent to be subscribed to this entity. That subscription will be effected
     * asynchronously.
     * If subscription to the given sid already exists, it will be overwritten.
     *
     * @param {String} sid should be a well-formed SID, uniquely identifying a single instance of a Sync entity.
     * @param {Object} entity should represent the (singular) local representation of this entity.
     *      Incoming events and modifications to the entity will be directed at the _update() function
     *      of this provided reference.
     *
     * @return undefined
     */
    add(sid, entity) {
        log$1.debug(`Establishing intent to subscribe to ${sid}`);
        const existingSubscription = this.subscriptions.get(sid);
        if (existingSubscription && entity && existingSubscription.lastEventId === entity.lastEventId) {
            // If last event id is the same as before - we're fine
            return;
        }
        this.persisted.delete(sid);
        this.subscriptions.set(sid, new SubscribedEntity(entity));
        this.persist();
    }
    /**
     * Establishes the caller's intent to no longer be subscribed to this entity. Following this
     * call, no further events shall be routed to the local representation of the entity, even
     * though a server-side subscription may take more time to actually terminate.
     *
     * @param {string} sid should be any well-formed SID, uniquely identifying a Sync entity.
     *      This call only has meaningful effect if that entity is subscribed at the
     *      time of call. Otherwise does nothing.
     *
     * @return undefined
     */
    remove(sid) {
        log$1.debug(`Establishing intent to unsubscribe from ${sid}`);
        const removed = this.subscriptions.delete(sid);
        if (removed) {
            this.persist();
        }
    }
    /**
     * The point of ingestion for remote incoming messages (e.g. new data was written to a map
     * to which we are subscribed).
     *
     * @param {object} message is the full, unaltered body of the incoming notification.
     *
     * @return undefined
     */
    acceptMessage(message, isStrictlyOrdered) {
        log$1.trace('Subscriptions received', message);
        if (message.correlation_id) {
            this.latestPokeResponseArrivalTimestampByCorrelationId.set(message.correlation_id, new Date().getTime());
        }
        let event_type;
        switch (message.event_type) {
            case 'subscription_established':
                this.applySubscriptionEstablishedMessage(message.event, message.correlation_id);
                break;
            case 'subscription_canceled':
                this.applySubscriptionCancelledMessage(message.event, message.correlation_id);
                break;
            case 'subscription_failed':
                this.applySubscriptionFailedMessage(message.event, message.correlation_id);
                break;
            case (event_type = message.event_type.match(/^(?:map|list|document|stream|live_query)_/) || {}).input:
                {
                    let typedSid;
                    switch (event_type[0]) {
                        case 'map_':
                            typedSid = message.event.map_sid;
                            break;
                        case 'list_':
                            typedSid = message.event.list_sid;
                            break;
                        case 'document_':
                            typedSid = message.event.document_sid;
                            break;
                        case 'stream_':
                            typedSid = message.event.stream_sid;
                            break;
                        case 'live_query_':
                            typedSid = message.event.query_id;
                            // hack to mark replay events for LiveQuery as strictly ordered, due to lack of special type of notification for them
                            // (normally only replay events would have `twilio.sync.event` type, but LiveQuery non-replay events were also assigned
                            // to this type in legacy clients, which we have to support now; hence a hack)
                            isStrictlyOrdered = false; // explicitly override it due to code in router.ts does not know about LiveQueries
                            if (message.strictly_ordered === true) {
                                isStrictlyOrdered = true;
                            }
                            break;
                        default:
                            typedSid = undefined;
                    }
                    this.applyEventToSubscribedEntity(typedSid, message, isStrictlyOrdered);
                }
                break;
            default:
                log$1.debug(`Dropping unknown message type ${message.event_type}`);
                break;
        }
    }
    applySubscriptionEstablishedMessage(message, correlationId) {
        const sid = message.object_sid;
        let subscriptionIntent = this.persisted.get(message.object_sid);
        if (subscriptionIntent && subscriptionIntent.pendingCorrelationId === correlationId) {
            if (message.replay_status === 'interrupted') {
                log$1.debug(`Event Replay for subscription to ${sid} (c:${correlationId}) interrupted; continuing eagerly.`);
                subscriptionIntent.updatePending(null, null);
                this.persisted.delete(subscriptionIntent.sid);
                this.backoff.reset();
            }
            else if (message.replay_status === 'completed') {
                log$1.debug(`Event Replay for subscription to ${sid} (c:${correlationId}) completed. Subscription is ready.`);
                subscriptionIntent.complete(message.last_event_id);
                this.persisted.set(message.object_sid, subscriptionIntent);
                subscriptionIntent.setSubscriptionState('established');
                this.backoff.reset();
            }
        }
        else {
            log$1.debug(`Late message for ${message.object_sid} (c:${correlationId}) dropped.`);
        }
        this.persist();
    }
    applySubscriptionCancelledMessage(message, correlationId) {
        let persistedSubscription = this.persisted.get(message.object_sid);
        if (persistedSubscription && persistedSubscription.pendingCorrelationId === correlationId) {
            persistedSubscription.updatePending(null, null);
            persistedSubscription.setSubscriptionState('none');
            this.persisted.delete(message.object_sid);
        }
        else {
            log$1.debug(`Late message for ${message.object_sid} (c:${correlationId}) dropped.`);
        }
        this.persist();
    }
    applySubscriptionFailedMessage(message, correlationId) {
        const sid = message.object_sid;
        let subscriptionIntent = this.subscriptions.get(sid);
        let subscription = this.persisted.get(sid);
        if (subscriptionIntent && subscription) {
            if (subscription.pendingCorrelationId === correlationId) {
                log$1.error(`Failed to subscribe on ${subscription.sid}`, message.error);
                subscription.markAsFailed(message);
                subscription.setSubscriptionState('none');
            }
        }
        else if (!subscriptionIntent && subscription) {
            this.persisted.delete(sid);
            subscription.setSubscriptionState('none');
        }
        this.persist();
    }
    applyEventToSubscribedEntity(sid, message, isStrictlyOrdered) {
        if (!sid) {
            return;
        }
        // Looking for subscription descriptor to check if poke has been completed
        isStrictlyOrdered = isStrictlyOrdered || (() => {
            let subscription = this.persisted.get(sid);
            return subscription && subscription.isEstablished;
        })();
        // Still searching for subscriptionIntents. User could remove subscription already
        let subscriptionIntent = this.subscriptions.get(sid);
        if (subscriptionIntent) {
            message.event.type = message.event_type;
            subscriptionIntent.update(message.event, isStrictlyOrdered);
        }
        else {
            log$1.debug(`Message dropped for SID '${sid}', for which there is no subscription.`);
        }
    }
    onConnectionStateChanged(isConnected) {
        this.isConnected = isConnected;
        if (isConnected) {
            this.poke('reconnect');
        }
    }
    onSubscriptionTtlElapsed() {
        if (this.isConnected) {
            this.poke('ttl');
        }
    }
    /**
     * Prompts a playback of any missed changes made to any subscribed object. This method
     * should be invoked whenever the connectivity layer has experienced cross-cutting
     * delivery failures that would affect the entire local sync set. Any tangible result
     * of this operation will result in calls to the _update() function of subscribed
     * Sync entities.
     */
    poke(reason) {
        log$1.debug(`Triggering event replay for all subscriptions, reason=${reason}`);
        this.pendingPokeReason = reason;
        if (this.subscriptionTtlTimer) {
            clearTimeout(this.subscriptionTtlTimer);
            this.subscriptionTtlTimer = null;
        }
        let failedSubscriptions = [];
        for (let it of this.persisted.values()) {
            it.reset();
            if (it.rejectedWithError) {
                failedSubscriptions.push(it);
            }
        }
        this.persisted.clear();
        for (let it of failedSubscriptions) {
            this.persisted.set(it.sid, it);
        }
        this.persist();
    }
    /**
     * Stops all communication, clears any subscription intent, and returns.
     */
    shutdown() {
        this.backoff.reset();
        this.subscriptions.clear();
    }
}

const MINIMUM_RETRY_DELAY = 4000;
const MAXIMUM_RETRY_DELAY = 60000;
const MAXIMUM_ATTEMPTS_TIME = 90000;
const RETRY_DELAY_RANDOMNESS = 0.2;
function messageFromErrorBody(transportError) {
    if (transportError.body) {
        if (transportError.body.message) {
            return transportError.body.message;
        }
    }
    switch (transportError.status) {
        case 429:
            return 'Throttled by server';
        case 404:
            return 'Not found from server';
        default:
            return 'Error from server';
    }
}
function codeFromErrorBody(trasportError) {
    if (trasportError.body) {
        return trasportError.body.code;
    }
    return 0;
}
function mapTransportError(transportError) {
    if (transportError.status === 409) {
        return new SyncNetworkError(messageFromErrorBody(transportError), transportError.status, codeFromErrorBody(transportError), transportError.body);
    }
    else if (transportError.status) {
        return new SyncError(messageFromErrorBody(transportError), transportError.status, codeFromErrorBody(transportError));
    }
    else if (transportError instanceof twilsock.TransportUnavailableError) {
        return transportError;
    }
    else {
        return new SyncError(transportError.message, 0, 0);
    }
}
/**
 * @classdesc Incapsulates network operations to make it possible to add some optimization/caching strategies
 */
class NetworkService {
    constructor(clientInfo, config, transport) {
        this.clientInfo = clientInfo;
        this.config = config;
        this.transport = transport;
    }
    createHeaders() {
        return {
            'Content-Type': 'application/json',
            'Twilio-Sync-Client-Info': JSON.stringify(this.clientInfo),
            'Twilio-Request-Id': 'RQ' + uuid__namespace.v4().replace(/-/g, '')
        };
    }
    backoffConfig() {
        return Object.assign({
            min: MINIMUM_RETRY_DELAY,
            max: MAXIMUM_RETRY_DELAY,
            maxAttemptsTime: MAXIMUM_ATTEMPTS_TIME,
            randomness: RETRY_DELAY_RANDOMNESS
        }, this.config.backoffConfig);
    }
    executeWithRetry(request, retryWhenThrottled = true) {
        return new Promise((resolve, reject) => {
            let codesToRetryOn = [502, 503, 504];
            if (retryWhenThrottled) {
                codesToRetryOn.push(429);
            }
            let retrier = new operationRetrier.Retrier(this.backoffConfig());
            retrier.on('attempt', () => {
                request()
                    .then(result => retrier.succeeded(result))
                    .catch(err => {
                    if (codesToRetryOn.includes(err.status)) {
                        let delayOverride = parseInt(err.headers ? err.headers['Retry-After'] : null);
                        retrier.failed(mapTransportError(err), isNaN(delayOverride) ? null : delayOverride * 1000);
                    }
                    else if (err.message === 'Twilsock disconnected') {
                        // Ugly hack. We must make a proper exceptions for twilsock
                        retrier.failed(mapTransportError(err));
                    }
                    else {
                        // Fatal error
                        retrier.removeAllListeners();
                        retrier.cancel();
                        reject(mapTransportError(err));
                    }
                });
            });
            retrier.on('succeeded', result => {
                resolve(result);
            });
            retrier.on('cancelled', err => reject(mapTransportError(err)));
            retrier.on('failed', err => reject(mapTransportError(err)));
            retrier.start();
        });
    }
    /**
     * Make a GET request by given URI
     * @Returns Promise<Response> Result of successful get request
     */
    get(uri) {
        let headers = this.createHeaders();
        log$1.debug('GET', uri, 'ID:', headers['Twilio-Request-Id']);
        return this.executeWithRetry(() => this.transport.get(uri, headers, this.config.productId), true);
    }
    post(uri, body, revision, retryWhenThrottled = false) {
        let headers = this.createHeaders();
        if (typeof revision !== 'undefined' && revision !== null) {
            headers['If-Match'] = revision;
        }
        log$1.debug('POST', uri, 'ID:', headers['Twilio-Request-Id']);
        return this.executeWithRetry(() => this.transport.post(uri, headers, body, this.config.productId), retryWhenThrottled);
    }
    put(uri, body, revision) {
        let headers = this.createHeaders();
        if (typeof revision !== 'undefined' && revision !== null) {
            headers['If-Match'] = revision;
        }
        log$1.debug('PUT', uri, 'ID:', headers['Twilio-Request-Id']);
        return this.executeWithRetry(() => this.transport.put(uri, headers, body, this.config.productId), false);
    }
    delete(uri) {
        let headers = this.createHeaders();
        log$1.debug('DELETE', uri, 'ID:', headers['Twilio-Request-Id']);
        return this.executeWithRetry(() => this.transport.delete(uri, headers, this.config.productId), false);
    }
}

class SessionStorage {
    constructor(config, storage) {
        this.config = config;
        this.storageId = null;
        try {
            this.storage = storage || sessionStorage;
        }
        catch (e) {
        }
    }
    storageKey(type, key) {
        return `${this.storageId}::${type}::${key}`;
    }
    get isReady() {
        return this.config.sessionStorageEnabled && !!this.storageId;
    }
    updateStorageId(storageId) {
        this.storageId = storageId;
    }
    store(type, id, value) {
        if (!this.isReady) {
            return null;
        }
        return this._store(this.storageKey(type, id), value);
    }
    read(type, id) {
        if (!this.isReady) {
            return null;
        }
        return this._read(this.storageKey(type, id));
    }
    remove(type, sid, uniqueName) {
        if (!this.isReady) {
            return null;
        }
        try {
            this.storage.removeItem(this.storageKey(type, sid));
            if (uniqueName) {
                this.storage.removeItem(this.storageKey(type, uniqueName));
            }
        }
        catch (e) {
        }
    }
    update(type, sid, uniqueName, patch) {
        if (!this.isReady) {
            return null;
        }
        // Currently cache may have root stored twice - by sid and by uniqueName
        // Maybe need to create some index if needed
        this._apply(this.storageKey(type, sid), patch);
        if (uniqueName) {
            this._apply(this.storageKey(type, uniqueName), patch);
        }
    }
    _store(key, value) {
        try {
            this.storage.setItem(key, JSON.stringify(value));
        }
        catch (e) {
        }
    }
    _read(key) {
        try {
            let storedData = this.storage.getItem(key);
            if (storedData) {
                return JSON.parse(storedData);
            }
        }
        catch (e) {
        }
        return null;
    }
    _apply(key, patch) {
        let value = this._read(key);
        if (!value) {
            return false;
        }
        this._store(key, Object.assign(value, patch));
    }
}

class SyncEntity {
    constructor(services, removalHandler) {
        this.services = services;
        this.removalHandler = removalHandler;
        this.subscriptionState = 'none';
        this._attachedListeners = new Map();
    }
    _advanceLastEventId(eventId, revision) {
    }
    reportFailure(err) {
        if (err.status === 404) {
            // assume that 404 means that entity has been removed while we were away
            this.onRemoved(false);
        }
        else {
            this.broadcastEventToListeners('failure', err);
        }
    }
    /**
     * Subscribe to changes of data entity
     * @private
     */
    _subscribe() {
        this.services.router._subscribe(this.sid, this);
    }
    /**
     * Unsubscribe from changes of current data entity
     * @private
     */
    _unsubscribe() {
        this.services.router._unsubscribe(this.sid);
    }
    _setSubscriptionState(newState) {
        this.subscriptionState = newState;
        this.broadcastEventToListeners('_subscriptionStateChanged', newState);
    }
    /**
     * @public
     */
    close() {
        this._unsubscribe();
        if (this.removalHandler != null) {
            this.removalHandler(this.type, this.sid, this.uniqueName);
        }
    }
    attach(closeable) {
        const uuid = closeable.listenerUuid;
        const existingRecord = this._attachedListeners.get(uuid);
        if (existingRecord) {
            return;
        }
        if (!this._attachedListeners.size) {
            // the first one to arrive
            this._subscribe();
        }
        this._attachedListeners.set(uuid, closeable);
    }
    detach(listenerUuid) {
        this._attachedListeners.delete(listenerUuid);
        if (!this._attachedListeners.size) {
            // last one out, turn off lights, shut the door
            this.close(); // invokes unsubscribe and removal handler
        }
    }
    broadcastEventToListeners(eventName, args) {
        for (let listener of this._attachedListeners.values()) {
            listener.emit(eventName, args);
        }
    }
}

class MergingQueue {
    constructor(inputMergingFunction) {
        this.queuedRequests = [];
        this.isRequestInFlight = false;
        this.inputMergingFunction = inputMergingFunction;
    }
    add(input, requestFunction) {
        let promise = new Promise((resolve, reject) => this.queuedRequests.push({ input, requestFunction, resolve, reject }));
        this.wakeupQueue();
        return promise;
    }
    squashAndAdd(input, requestFunction) {
        let queueToSquash = this.queuedRequests;
        this.queuedRequests = [];
        let reducedInput;
        if (queueToSquash.length > 0) {
            reducedInput = queueToSquash.map(r => r.input).reduce(this.inputMergingFunction);
            reducedInput = this.inputMergingFunction(reducedInput, input);
        }
        else {
            reducedInput = input;
        }
        let promise = this.add(reducedInput, requestFunction);
        queueToSquash.forEach(request => promise.then(request.resolve, request.reject));
        return promise;
    }
    isEmpty() {
        return this.queuedRequests.length === 0 && !this.isRequestInFlight;
    }
    wakeupQueue() {
        if (this.queuedRequests.length === 0 || this.isRequestInFlight) {
            return;
        }
        else {
            let requestToExecute = this.queuedRequests.shift();
            this.isRequestInFlight = true;
            requestToExecute.requestFunction(requestToExecute.input)
                .then(requestToExecute.resolve, requestToExecute.reject)
                .then(__ => {
                this.isRequestInFlight = false;
                this.wakeupQueue();
            });
        }
    }
}
class NamespacedMergingQueue {
    constructor(inputReducer) {
        this.queueByNamespaceKey = new Map();
        this.inputReducer = inputReducer;
    }
    async add(namespaceKey, input, requestFunction) {
        return this.invokeQueueMethod(namespaceKey, queue => queue.add(input, requestFunction));
    }
    async squashAndAdd(namespaceKey, input, requestFunction) {
        return this.invokeQueueMethod(namespaceKey, queue => queue.squashAndAdd(input, requestFunction));
    }
    async invokeQueueMethod(namespaceKey, queueMethodInvoker) {
        if (!this.queueByNamespaceKey.has(namespaceKey)) {
            this.queueByNamespaceKey.set(namespaceKey, new MergingQueue(this.inputReducer));
        }
        const queue = this.queueByNamespaceKey.get(namespaceKey);
        const result = queueMethodInvoker(queue);
        if (this.queueByNamespaceKey.get(namespaceKey).isEmpty()) {
            this.queueByNamespaceKey.delete(namespaceKey);
        }
        return result;
    }
}

class Closeable extends EventEmitter {
    constructor() {
        super();
        this.closed = false;
        this.uuid = uuid.v4();
    }
    get listenerUuid() {
        return this.uuid;
    }
    close() {
        this.removeAllListeners();
        this.closed = true;
    }
    ensureNotClosed() {
        if (this.closed) {
            throw new Error('Invalid operation on closed object');
        }
    }
}

class SyncDocumentImpl extends SyncEntity {
    /**
     * @internal
     */
    constructor(services, descriptor, removalHandler) {
        super(services, removalHandler);
        this.isDeleted = false;
        const updateRequestReducer = (acc, input) => (typeof input.ttl === 'number') ? { ttl: input.ttl }
            : acc;
        this.updateMergingQueue = new MergingQueue(updateRequestReducer);
        this.descriptor = descriptor;
        this.descriptor.data = this.descriptor.data || {};
        this.descriptor.date_updated = new Date(this.descriptor.date_updated);
    }
    // private props
    get uri() {
        return this.descriptor.url;
    }
    get revision() {
        return this.descriptor.revision;
    }
    get lastEventId() {
        return this.descriptor.last_event_id;
    }
    get dateExpires() {
        return this.descriptor.date_expires;
    }
    static get type() {
        return 'document';
    }
    get type() {
        return 'document';
    }
    // below properties are specific to Insights only
    get indexName() {
        return undefined;
    }
    get queryString() {
        return undefined;
    }
    // public props, documented along with class description
    get sid() {
        return this.descriptor.sid;
    }
    get data() {
        return this.descriptor.data;
    }
    get dateUpdated() {
        return this.descriptor.date_updated;
    }
    get uniqueName() {
        return this.descriptor.unique_name || null;
    }
    /**
     * Update data entity with new data
     * @private
     */
    _update(update) {
        update.date_created = new Date(update.date_created);
        switch (update.type) {
            case 'document_updated':
                if (update.id <= this.lastEventId) {
                    log$1.trace('Document update skipped, current:', this.lastEventId, ', remote:', update.id);
                    break;
                }
                const previousData = this.descriptor.data !== undefined ? deepClone(this.descriptor.data) : null;
                this.descriptor.last_event_id = update.id;
                this.descriptor.revision = update.document_revision;
                this.descriptor.date_updated = update.date_created;
                this.descriptor.data = update.document_data;
                this.broadcastEventToListeners('updated', { data: update.document_data, isLocal: false, previousData });
                this.services.storage.update(this.type, this.sid, this.uniqueName, {
                    last_event_id: update.id,
                    revision: update.document_revision,
                    date_updated: update.date_created,
                    data: update.document_data
                });
                break;
            case 'document_removed':
                this.onRemoved(false);
                break;
        }
    }
    async set(value, metadataUpdates) {
        const input = metadataUpdates || {};
        return this.updateMergingQueue.squashAndAdd(input, input => this._setUnconditionally(value, input.ttl));
    }
    async mutate(mutator, metadataUpdates) {
        const input = metadataUpdates || {};
        return this.updateMergingQueue.add(input, input => this._setWithIfMatch(mutator, input.ttl));
    }
    async update(obj, metadataUpdates) {
        return this.mutate(remote => Object.assign(remote, obj), metadataUpdates);
    }
    async setTtl(ttl) {
        const response = await this._postUpdateToServer({ ttl });
        this.descriptor.date_expires = response.date_expires;
    }
    /**
     * @private
     */
    async _setUnconditionally(value, ttl) {
        let result = await this._postUpdateToServer({ data: value, revision: undefined, ttl });
        this._handleSuccessfulUpdateResult(result);
        return this.descriptor.data;
    }
    /**
     * @private
     */
    async _setWithIfMatch(mutatorFunction, ttl) {
        let data = mutatorFunction(deepClone(this.descriptor.data));
        if (data) {
            let revision = this.revision;
            try {
                let result = await this._postUpdateToServer({ data, revision, ttl });
                this._handleSuccessfulUpdateResult(result);
                return this.descriptor.data;
            }
            catch (error) {
                if (error.status === 412) {
                    await this._softSync();
                    return this._setWithIfMatch(mutatorFunction);
                }
                else {
                    throw error;
                }
            }
        }
        else {
            return this.descriptor.data;
        }
    }
    /**
     * @private
     */
    _handleSuccessfulUpdateResult(result) {
        // Ignore returned value if we already got a newer one
        if (result.last_event_id <= this.descriptor.last_event_id) {
            return;
        }
        const previousData = this.descriptor.data !== undefined ? deepClone(this.descriptor.data) : null;
        this.descriptor.revision = result.revision;
        this.descriptor.data = result.data;
        this.descriptor.last_event_id = result.last_event_id;
        this.descriptor.date_expires = result.date_expires;
        this.descriptor.date_updated = new Date(result.date_updated);
        this.services.storage.update(this.type, this.sid, this.uniqueName, {
            last_event_id: result.last_event_id,
            revision: result.revision,
            date_updated: result.date_updated,
            data: result.data
        });
        this.broadcastEventToListeners('updated', { data: this.descriptor.data, isLocal: true, previousData });
    }
    /**
     * @private
     */
    async _postUpdateToServer(request) {
        if (!this.isDeleted) {
            const requestBody = {
                data: request.data
            };
            if (request.ttl !== undefined) {
                requestBody.ttl = request.ttl;
            }
            const ifMatch = request.revision;
            try {
                const response = await this.services.network.post(this.uri, requestBody, ifMatch);
                return {
                    revision: response.body.revision,
                    data: request.data,
                    last_event_id: response.body.last_event_id,
                    date_updated: response.body.date_updated,
                    date_expires: response.body.date_expires
                };
            }
            catch (error) {
                if (error.status === 404) {
                    this.onRemoved(false);
                }
                throw error;
            }
        }
        else {
            return Promise.reject(new SyncError('The Document has been removed', 404, 54100));
        }
    }
    /**
     * Get new data from server
     * @private
     */
    async _softSync() {
        return this.services.network.get(this.uri)
            .then(response => {
            const event = {
                type: 'document_updated',
                id: response.body.last_event_id,
                document_revision: response.body.revision,
                document_data: response.body.data,
                date_created: response.body.date_updated
            };
            this._update(event);
            return this;
        })
            .catch(err => {
            if (err.status === 404) {
                this.onRemoved(false);
            }
            else {
                log$1.error(`Can't get updates for ${this.sid}:`, err);
            }
        });
    }
    onRemoved(locally) {
        if (this.isDeleted) {
            return;
        }
        const previousData = this.descriptor.data !== undefined ? deepClone(this.descriptor.data) : null;
        this.isDeleted = true;
        this._unsubscribe();
        this.removalHandler(this.type, this.sid, this.uniqueName);
        this.broadcastEventToListeners('removed', { isLocal: locally, previousData });
    }
    async removeDocument() {
        if (!this.isDeleted) {
            await this.services.network.delete(this.uri);
            this.onRemoved(true);
        }
        else {
            return Promise.reject(new SyncError('The Document has been removed', 404, 54100));
        }
    }
}
/**
 * Represents a Sync document, the contents of which is a single JSON object.
 * Use the {@link SyncClient.document} method to obtain a reference to a Sync document.
 * Information about rate limits can be found [here](https://www.twilio.com/docs/sync/limits).
 */
class SyncDocument extends Closeable {
    /**
     * @internal
     */
    constructor(syncDocumentImpl) {
        super();
        this.syncDocumentImpl = syncDocumentImpl;
        this.syncDocumentImpl.attach(this);
    }
    // private props
    get uri() {
        return this.syncDocumentImpl.uri;
    }
    get revision() {
        return this.syncDocumentImpl.revision;
    }
    get lastEventId() {
        return this.syncDocumentImpl.lastEventId;
    }
    get dateExpires() {
        return this.syncDocumentImpl.dateExpires;
    }
    static get type() {
        return SyncDocumentImpl.type;
    }
    get type() {
        return SyncDocumentImpl.type;
    }
    /**
     * The immutable identifier of this document, assigned by the system.
     */
    get sid() {
        return this.syncDocumentImpl.sid;
    }
    /**
     * The contents of this document.
     */
    get data() {
        return this.syncDocumentImpl.data;
    }
    /**
     * Date when the document was last updated.
     */
    get dateUpdated() {
        return this.syncDocumentImpl.dateUpdated;
    }
    /**
     * An optional immutable identifier that may be assigned by the programmer
     * to this document during creation. Globally unique among other documents.
     */
    get uniqueName() {
        return this.syncDocumentImpl.uniqueName;
    }
    /**
     * Assign new contents to this document. The current data will be overwritten.
     * @param data The new contents to assign.
     * @param metadataUpdates New document metadata.
     * @return A promise resolving to the new data of the document.
     * @example
     * ```typescript
     * // Say, the Document data is `{ name: 'John Smith', age: 34 }`
     * document.set({ name: 'Barbara Oaks' }, { ttl: 86400 })
     *   .then((newValue) => {
     *     // Now the Document data is `{ name: 'Barbara Oaks' }`
     *     console.log('Document set() successful, new data:', newValue);
     *   })
     *   .catch((error) => {
     *     console.error('Document set() failed', error);
     *   });
     * ```
     */
    async set(data, metadataUpdates) {
        this.ensureNotClosed();
        return this.syncDocumentImpl.set(data, metadataUpdates);
    }
    /**
     * Schedules a modification to this document that will apply a mutation function.
     * @param mutator A function that outputs new data based on the existing data.
     * May be called multiple times, particularly if this document is modified concurrently by remote code.
     * If the mutation ultimately succeeds, the document will have made the particular transition described
     * by this function.
     * @param metadataUpdates New document metadata.
     * @return Resolves with the most recent Document state, whether the output of a
     * successful mutation or a state that prompted graceful cancellation (mutator returned `null`).
     * @example
     * ```typescript
     * const mutatorFunction = (currentValue) => {
     *     currentValue.viewCount = (currentValue.viewCount ?? 0) + 1;
     *     return currentValue;
     * };
     * document.mutate(mutatorFunction, { ttl: 86400 }))
     *   .then((newValue) => {
     *     console.log('Document mutate() successful, new data:', newValue);
     *   })
     *   .catch((error) => {
     *     console.error('Document mutate() failed', error);
     *   });
     * ```
     */
    async mutate(mutator, metadataUpdates) {
        this.ensureNotClosed();
        return this.syncDocumentImpl.mutate(mutator, metadataUpdates);
    }
    /**
     * Modify a document by appending new fields (or by overwriting existing ones) with the values from the provided Object.
     * This is equivalent to:
     * ```typescript
     * document.mutate((currentValue) => Object.assign(currentValue, obj));
     * ```
     * @param obj Specifies the particular (top-level) attributes that will receive new values.
     * @param metadataUpdates New document metadata.
     * @return A promise resolving to the new data of the document.
     * @example
     * ```typescript
     * // Say, the Document data is `{ name: 'John Smith' }`
     * document.update({ age: 34 }, { ttl: 86400 })
     *   .then((newValue) => {
     *     // Now the Document data is `{ name: 'John Smith', age: 34 }`
     *     console.log('Document update() successful, new data:', newValue);
     *   })
     *   .catch((error) => {
     *     console.error('Document update() failed', error);
     *   });
     * ```
     */
    async update(obj, metadataUpdates) {
        this.ensureNotClosed();
        return this.syncDocumentImpl.update(obj, metadataUpdates);
    }
    /**
     * Update the time-to-live of the document.
     * @param ttl Specifies the time-to-live in seconds after which the document is subject to automatic deletion. The value 0 means infinity.
     * @return A promise that resolves after the TTL update was successful.
     * @example
     * ```typescript
     * document.setTtl(3600)
     *   .then(() => {
     *     console.log('Document setTtl() successful');
     *   })
     *   .catch((error) => {
     *     console.error('Document setTtl() failed', error);
     *   });
     * ```
     */
    async setTtl(ttl) {
        this.ensureNotClosed();
        return this.syncDocumentImpl.setTtl(ttl);
    }
    /**
     * Delete a document.
     * @return A promise which resolves if (and only if) the document is ultimately deleted.
     * @example
     * ```typescript
     * document.removeDocument()
     *   .then(() => {
     *     console.log('Document removeDocument() successful');
     *   })
     *   .catch((error) => {
     *     console.error('Document removeDocument() failed', error);
     *   });
     * ```
     */
    async removeDocument() {
        this.ensureNotClosed();
        return this.syncDocumentImpl.removeDocument();
    }
    /**
     * Conclude work with the document instance and remove all event listeners attached to it.
     * Any subsequent operation on this object will be rejected with error.
     * Other local copies of this document will continue operating and receiving events normally.
     * @example
     * ```typescript
     * document.close();
     * ```
     */
    close() {
        super.close();
        this.syncDocumentImpl.detach(this.listenerUuid);
    }
}
/**
 * Fired when the document is removed, regardless of whether the remover was local or remote.
 *
 * Parameters:
 * 1. object `args` - info object provided with the event. It has following properties:
 *     * boolean `isLocal` - is true if document was removed by a local actor, false otherwise
 *     * object `previousData` - contains a snapshot of the document data before removal
 * @example
 * ```typescript
 * document.on('removed', (args) => {
 *   console.log(`Document ${document.sid} was removed`);
 *   console.log('args.isLocal:', args.isLocal);
 *   console.log('args.previousData:', args.previousData);
 * });
 * ```
 * @event
 */
SyncDocument.removed = 'removed';
/**
 * Fired when the document's contents have changed, regardless of whether the updater was local or remote.
 *
 * Parameters:
 * 1. object `args` - info object provided with the event. It has the following properties:
 *     * boolean `isLocal` - is true if document was updated by a local actor, false otherwise
 *     * object `data` - a snapshot of the document's new contents
 *     * object `previousData` - contains a snapshot of the document data before the update
 * @example
 * ```typescript
 * document.on('updated', (args) => {
 *   console.log(`Document ${document.sid} was updated`);
 *   console.log('args.data:', args.data);
 *   console.log('args.isLocal:', args.isLocal);
 *   console.log('args.previousData:', args.previousData);
 * });
 * ```
 * @event
 */
SyncDocument.updated = 'updated';
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.pureObject, [
        'undefined',
        declarativeTypeValidator.objectSchema('document metadata', {
            ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined']
        })
    ]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], SyncDocument.prototype, "set", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync('function', [
        'undefined',
        declarativeTypeValidator.objectSchema('document metadata', {
            ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined']
        })
    ]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function, Object]),
    __metadata("design:returntype", Promise)
], SyncDocument.prototype, "mutate", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.pureObject, [
        'undefined',
        declarativeTypeValidator.objectSchema('document metadata', {
            ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined']
        })
    ]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], SyncDocument.prototype, "update", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", Promise)
], SyncDocument.prototype, "setTtl", null);

/**
 * Represents an individual element in a Sync list.
 */
class SyncListItem {
    /**
     * @param descriptor Item descriptor
     * @internal
     */
    constructor(descriptor) {
        this.descriptor = descriptor;
    }
    get uri() {
        return this.descriptor.uri;
    }
    get revision() {
        return this.descriptor.revision;
    }
    get lastEventId() {
        return this.descriptor.lastEventId;
    }
    /**
     * Date when the list item was last updated.
     */
    get dateUpdated() {
        return this.descriptor.dateUpdated;
    }
    get dateExpires() {
        return this.descriptor.dateExpires;
    }
    /**
     * The index, within the containing list, of this item. This index is stable;
     * even if lower-indexed items are removed, this index will remain as is.
     */
    get index() {
        return this.descriptor.index;
    }
    /**
     * The contents of the item.
     */
    get data() {
        return this.descriptor.data;
    }
    /**
     * @internal
     */
    update(eventId, revision, data, dateUpdated) {
        this.descriptor.lastEventId = eventId;
        this.descriptor.revision = revision;
        this.descriptor.data = data;
        this.descriptor.dateUpdated = dateUpdated;
        return this;
    }
    /**
     * @internal
     */
    updateDateExpires(dateExpires) {
        this.descriptor.dateExpires = dateExpires;
    }
}

/**
 * Pagination helper class.
 */
class Paginator {
    /**
     * @internal
     */
    constructor(items, source, prevToken, nextToken) {
        this.prevToken = prevToken;
        this.nextToken = nextToken;
        this.items = items;
        this.source = source;
    }
    /**
     * Indicates the existence of the next page.
     */
    get hasNextPage() {
        return !!this.nextToken;
    }
    /**
     * Indicates the existence of the previous page.
     */
    get hasPrevPage() {
        return !!this.prevToken;
    }
    /**
     * Request next page.
     * Does not modify existing object.
     */
    async nextPage() {
        if (!this.hasNextPage) {
            throw new Error('No next page');
        }
        return this.source(this.nextToken);
    }
    /**
     * Request previous page.
     * Does not modify existing object.
     */
    async prevPage() {
        if (!this.hasPrevPage) {
            throw new Error('No previous page');
        }
        return this.source(this.prevToken);
    }
}

class Node {
    constructor(key, value) {
        this.balanceFactor = 0;
        this.key = key;
        this.value = value;
        this.parent = null;
        this.left = null;
        this.right = null;
    }
    get isRoot() { return this.parent === null; }
    get isLeaf() { return (this.left === null) && (this.right === null); }
    get isLeftChild() { return this.parent.left === this; }
    update(value) {
        this.value = value;
    }
    replace(target, replacement) {
        if (!target) {
            return;
        }
        if (this.left === replacement) {
            this.left = replacement;
        }
        else if (this.right === replacement) {
            this.right = replacement;
        }
    }
}
/**
 * @property length
 */
class TreeMap {
    constructor(less, equal) {
        this.isLessThan = less || ((x, y) => x < y);
        this.isEqual = equal || ((x, y) => x === y);
        this.root = null;
        this.count = null;
    }
    get size() { return this.count; }
    clear() {
        this.root = null;
        this.count = 0;
    }
    set(key, value) {
        let node = this.getNode(key);
        if (node) {
            node.update(value);
        }
        else {
            this.insert(key, value);
        }
        // return node;
    }
    insert(key, value) {
        let node = new Node(key, value);
        this.count++;
        if (!this.root) {
            this.root = node;
            // return node;
            return;
        }
        let currNode = this.root;
        for (;;) {
            if (this.isLessThan(key, currNode.key)) {
                if (currNode.left) {
                    currNode = currNode.left;
                }
                else {
                    currNode.left = node;
                    break;
                }
            }
            else {
                if (currNode.right) { // eslint-disable-line no-lonely-if
                    currNode = currNode.right;
                }
                else {
                    currNode.right = node;
                    break;
                }
            }
        }
        node.parent = currNode;
        currNode = node;
        while (currNode.parent) {
            let parent = currNode.parent;
            let prevBalanceFactor = parent.balanceFactor;
            if (currNode.isLeftChild) {
                parent.balanceFactor++;
            }
            else {
                parent.balanceFactor--;
            }
            if (Math.abs(parent.balanceFactor) < Math.abs(prevBalanceFactor)) {
                break;
            }
            if (parent.balanceFactor < -1 || parent.balanceFactor > 1) {
                this.rebalance(parent);
                break;
            }
            currNode = parent;
        }
        // return node;
    }
    get(key) {
        let currentNode = this.root;
        while (currentNode) {
            if (this.isEqual(key, currentNode.key)) {
                return currentNode.value;
            }
            if (this.isLessThan(key, currentNode.key)) {
                currentNode = currentNode.left;
            }
            else {
                currentNode = currentNode.right;
            }
        }
        return null;
    }
    delete(key) {
        // update this algorithm and remove any
        let node = this.getNode(key);
        if (!node || node.key !== key) {
            return null;
        }
        let parent = node.parent;
        let left = node.left;
        let right = node.right;
        if (!!left !== !!right) { // one child
            let child = left || right;
            if (!parent && !child) {
                this.root = null;
            }
            else if (parent && !child) {
                this.root = child;
            }
            else {
                parent.replace(node, null);
                this.rebalance(parent);
            }
        }
        else { // two children
            let maxLeft = node.left;
            while (maxLeft.right) {
                maxLeft = maxLeft.right;
            }
            if (node.left === maxLeft) {
                if (node.isRoot) {
                    this.root = maxLeft;
                    maxLeft.parent = null;
                }
                else {
                    if (node.isLeftChild) {
                        node.parent.left = maxLeft;
                    }
                    else {
                        node.parent.right = maxLeft;
                    }
                    maxLeft.parent = node.parent;
                }
                maxLeft.right = node.right;
                maxLeft.right.parent = maxLeft;
                maxLeft.balanceFactor = node.balanceFactor;
                node = {
                    parent: maxLeft, isLeftChild: true
                };
            }
            else {
                let mlParent = maxLeft.parent;
                let mlLeft = maxLeft.left;
                mlParent.right = mlLeft;
                if (mlLeft) {
                    mlLeft.parent = mlParent;
                }
                if (node.isRoot) {
                    this.root = maxLeft;
                    maxLeft.parent = null;
                }
                else {
                    if (node.isLeftChild) {
                        node.parent.left = maxLeft;
                    }
                    else {
                        node.parent.right = maxLeft;
                    }
                    maxLeft.parent = node.parent;
                }
                maxLeft.right = node.right;
                maxLeft.right.parent = maxLeft;
                maxLeft.left = node.left;
                maxLeft.left.parent = maxLeft;
                maxLeft.balanceFactor = node.balanceFactor;
                node = {
                    parent: mlParent, isLeftChild: false
                };
            }
        }
        this.count--;
        while (node.parent) {
            let parent = node.parent;
            let prevBalanceFactor = parent.balanceFactor;
            if (node.isLeftChild) {
                parent.balanceFactor -= 1;
            }
            else {
                parent.balanceFactor += 1;
            }
            if (Math.abs(parent.balanceFactor) > Math.abs(prevBalanceFactor)) {
                if (parent.balanceFactor < -1 || parent.balanceFactor > 1) {
                    this.rebalance(parent);
                    if (parent.parent.balanceFactor === 0) {
                        node = parent.parent;
                    }
                    else {
                        break;
                    }
                }
                else {
                    break;
                }
            }
            else {
                node = parent;
            }
        }
        return null;
    }
    getNode(key) {
        let currentNode = this.root;
        while (currentNode) {
            if (this.isEqual(key, currentNode.key)) {
                return currentNode;
            }
            if (this.isLessThan(key, currentNode.key)) {
                currentNode = currentNode.left;
            }
            else {
                currentNode = currentNode.right;
            }
        }
        return null;
    }
    rebalance(node) {
        if (node.balanceFactor < 0) {
            if (node.right.balanceFactor > 0) {
                this.rotateRight(node.right);
                this.rotateLeft(node);
            }
            else {
                this.rotateLeft(node);
            }
        }
        else if (node.balanceFactor > 0) {
            if (node.left.balanceFactor < 0) {
                this.rotateLeft(node.left);
                this.rotateRight(node);
            }
            else {
                this.rotateRight(node);
            }
        }
    }
    rotateLeft(pivot) {
        let root = pivot.right;
        pivot.right = root.left;
        if (root.left !== null) {
            root.left.parent = pivot;
        }
        root.parent = pivot.parent;
        if (root.parent === null) {
            this.root = root;
        }
        else if (pivot.isLeftChild) {
            root.parent.left = root;
        }
        else {
            root.parent.right = root;
        }
        root.left = pivot;
        pivot.parent = root;
        pivot.balanceFactor = pivot.balanceFactor + 1 - Math.min(root.balanceFactor, 0);
        root.balanceFactor = root.balanceFactor + 1 - Math.max(pivot.balanceFactor, 0);
    }
    rotateRight(pivot) {
        let root = pivot.left;
        pivot.left = root.right;
        if (root.right !== null) {
            root.right.parent = pivot;
        }
        root.parent = pivot.parent;
        if (root.parent === null) {
            this.root = root;
        }
        else if (pivot.isLeftChild) {
            root.parent.left = root;
        }
        else {
            root.parent.right = root;
        }
        root.right = pivot;
        pivot.parent = root;
        pivot.balanceFactor = pivot.balanceFactor - 1 - Math.min(root.balanceFactor, 0);
        root.balanceFactor = root.balanceFactor - 1 - Math.max(pivot.balanceFactor, 0);
    }
    *[Symbol.iterator]() {
        for (let iter of this.getIterator()) {
            yield iter;
        }
    }
    *getIterator(key = null) {
        let currentNode = this.root;
        while (currentNode) {
            if (this.isEqual(key, currentNode.key) || ((key === null) && !currentNode.left)) {
                break;
            }
            if (this.isLessThan(key, currentNode.key) || (key === null)) {
                currentNode = currentNode.left;
            }
            else {
                currentNode = currentNode.right;
            }
        }
        if (!currentNode) {
            return null;
        }
        let fromleft = true;
        for (;;) {
            if (fromleft) {
                yield [currentNode.key, currentNode.value];
                fromleft = false;
                if (currentNode.right) {
                    currentNode = currentNode.right;
                    while (currentNode.left) {
                        currentNode = currentNode.left;
                    }
                    fromleft = true;
                }
                else if (currentNode.parent) {
                    fromleft = (currentNode.parent.left === currentNode);
                    currentNode = currentNode.parent;
                }
                else {
                    break;
                }
            }
            else if (currentNode.parent) {
                fromleft = (currentNode.parent.left === currentNode);
                currentNode = currentNode.parent;
            }
            else {
                break;
            }
        }
        return null;
    }
    *getReverseIterator(key = null) {
        let currentNode = this.root;
        while (currentNode) {
            if (this.isEqual(key, currentNode.key) || ((key === null) && !currentNode.right)) {
                break;
            }
            if (!this.isLessThan(key, currentNode.key) || (key === null)) {
                currentNode = currentNode.right;
            }
            else {
                currentNode = currentNode.left;
            }
        }
        if (!currentNode) {
            return null;
        }
        let fromright = true;
        for (;;) {
            if (fromright) {
                yield [currentNode.key, currentNode.value];
                fromright = false;
                if (currentNode.left) {
                    currentNode = currentNode.left;
                    while (currentNode.right) {
                        currentNode = currentNode.right;
                    }
                    fromright = true;
                }
                else if (currentNode.parent) {
                    fromright = (currentNode.parent.right === currentNode);
                    currentNode = currentNode.parent;
                }
                else {
                    break;
                }
            }
            else if (currentNode.parent) {
                fromright = (currentNode.parent.right === currentNode);
                currentNode = currentNode.parent;
            }
            else {
                break;
            }
        }
        return null;
    }
}

class Entry {
    constructor(value, revision) {
        this.value = value;
        this.revision = (revision || 0);
    }
    get isValid() {
        return true;
    }
}
class Tombstone {
    constructor(revision) {
        this.revision = revision;
    }
    get isValid() {
        return false;
    }
}
class Cache {
    constructor() {
        this.items = new TreeMap();
    }
    store(key, value, revision) {
        let entry = this.items.get(key);
        if (entry && entry.revision > revision) {
            if (entry.isValid) {
                return entry.value;
            }
            return null;
        }
        this.items.set(key, new Entry(value, revision));
        return value;
    }
    delete(key, revision, force = false) {
        let curr = this.items.get(key);
        if (!curr || curr.revision < revision ||
            (curr && force === true) /* forced delete when revision is unknown */) {
            this.items.set(key, new Tombstone(revision));
        }
    }
    isKnown(key, revision) {
        let curr = this.items.get(key);
        return curr && curr.revision >= revision;
    }
    get(key) {
        let entry = this.items.get(key);
        if (entry && entry.isValid) {
            return entry.value;
        }
        return null;
    }
    has(key) {
        let entry = this.items.get(key);
        return entry && entry.isValid;
    }
    forEach(callbackfn) {
        if (this.items) {
            for (let [key, entry] of this.items) {
                if (entry.isValid) {
                    callbackfn(key, entry.value);
                }
            }
        }
    }
}

class SyncListImpl extends SyncEntity {
    /**
     * @private
     */
    constructor(services, descriptor, removalHandler) {
        super(services, removalHandler);
        const updateRequestReducer = (acc, input) => (typeof input.ttl === 'number') ? { ttl: input.ttl }
            : acc;
        this.updateMergingQueue = new NamespacedMergingQueue(updateRequestReducer);
        this.cache = new Cache();
        this.descriptor = descriptor;
        this.descriptor.date_updated = new Date(this.descriptor.date_updated);
    }
    // private props
    get uri() {
        return this.descriptor.url;
    }
    get revision() {
        return this.descriptor.revision;
    }
    get lastEventId() {
        return this.descriptor.last_event_id;
    }
    get links() {
        return this.descriptor.links;
    }
    get dateExpires() {
        return this.descriptor.date_expires;
    }
    static get type() {
        return 'list';
    }
    get type() {
        return 'list';
    }
    // below properties are specific to Insights only
    get indexName() {
        return undefined;
    }
    get queryString() {
        return undefined;
    }
    // public props, documented along with class description
    get sid() {
        return this.descriptor.sid;
    }
    get uniqueName() {
        return this.descriptor.unique_name || null;
    }
    get dateUpdated() {
        return this.descriptor.date_updated;
    }
    async _addOrUpdateItemOnServer(url, data, ifMatch, ttl) {
        const requestBody = { data };
        if (ttl !== undefined) {
            requestBody.ttl = ttl;
        }
        const response = await this.services.network.post(url, requestBody, ifMatch);
        response.body.data = data;
        response.body.date_updated = new Date(response.body.date_updated);
        return response.body;
    }
    async push(value, itemMetadata) {
        let ttl = (itemMetadata || {}).ttl;
        let item = await this._addOrUpdateItemOnServer(this.links.items, value, undefined, ttl);
        let index = Number(item.index);
        this._handleItemMutated(index, item.url, item.last_event_id, item.revision, value, item.date_updated, item.date_expires, true, false);
        return this.cache.get(index);
    }
    async set(index, value, itemMetadataUpdates) {
        const input = itemMetadataUpdates || {};
        return this.updateMergingQueue.squashAndAdd(index, input, (input) => this._updateItemUnconditionally(index, value, input.ttl));
    }
    async _updateItemUnconditionally(index, data, ttl) {
        let existingItem = await this.get(index);
        const itemDescriptor = await this._addOrUpdateItemOnServer(existingItem.uri, data, undefined, ttl);
        this._handleItemMutated(index, itemDescriptor.url, itemDescriptor.last_event_id, itemDescriptor.revision, itemDescriptor.data, itemDescriptor.date_updated, itemDescriptor.date_expires, false, false);
        return this.cache.get(index);
    }
    async _updateItemWithIfMatch(index, mutatorFunction, ttl) {
        const existingItem = await this.get(index);
        const data = mutatorFunction(deepClone(existingItem.data));
        if (data) {
            const ifMatch = existingItem.revision;
            try {
                const itemDescriptor = await this._addOrUpdateItemOnServer(existingItem.uri, data, ifMatch, ttl);
                this._handleItemMutated(index, itemDescriptor.url, itemDescriptor.last_event_id, itemDescriptor.revision, itemDescriptor.data, itemDescriptor.date_updated, itemDescriptor.date_expires, false, false);
                return this.cache.get(index);
            }
            catch (error) {
                if (error.status === 412) {
                    await this._getItemFromServer(index);
                    return this._updateItemWithIfMatch(index, mutatorFunction, ttl);
                }
                else {
                    throw error;
                }
            }
        }
        else {
            return existingItem;
        }
    }
    async mutate(index, mutator, itemMetadataUpdates) {
        const input = itemMetadataUpdates || {};
        return this.updateMergingQueue.add(index, input, (input) => this._updateItemWithIfMatch(index, mutator, input.ttl));
    }
    async update(index, obj, itemMetadataUpdates) {
        return this.mutate(index, remote => Object.assign(remote, obj), itemMetadataUpdates);
    }
    async remove(index) {
        const item = await this.get(index);
        const previousItemData = deepClone(item.data);
        const response = await this.services.network.delete(item.uri);
        this._handleItemRemoved(index, response.body.last_event_id, previousItemData, new Date(response.body.date_updated), false);
    }
    async get(index) {
        let cachedItem = this.cache.get(index);
        if (cachedItem) {
            return cachedItem;
        }
        else {
            return this._getItemFromServer(index);
        }
    }
    async _getItemFromServer(index) {
        let result = await this.queryItems({ index });
        if (result.items.length < 1) {
            throw new SyncError(`No item with index ${index} found`, 404, 54151);
        }
        else {
            return result.items[0];
        }
    }
    /**
     * Query items from the List
     * @private
     */
    async queryItems(arg) {
        arg = arg || {};
        const url = new UriBuilder(this.links.items)
            .queryParam('From', arg.from)
            .queryParam('PageSize', arg.limit)
            .queryParam('Index', arg.index)
            .queryParam('PageToken', arg.pageToken)
            .queryParam('Order', arg.order)
            .build();
        let response = await this.services.network.get(url);
        let items = response.body.items.map(el => {
            el.date_updated = new Date(el.date_updated);
            let itemInCache = this.cache.get(el.index);
            if (itemInCache) {
                this._handleItemMutated(el.index, el.url, el.last_event_id, el.revision, el.data, el.date_updated, el.date_expires, false, true);
            }
            else {
                this.cache.store(Number(el.index), new SyncListItem({
                    index: Number(el.index),
                    uri: el.url,
                    revision: el.revision,
                    lastEventId: el.last_event_id,
                    dateUpdated: el.date_updated,
                    dateExpires: el.date_expires,
                    data: el.data
                }), el.last_event_id);
            }
            return this.cache.get(el.index);
        });
        let meta = response.body.meta;
        return new Paginator(items, pageToken => this.queryItems({ pageToken }), meta.previous_token, meta.next_token);
    }
    async getItems(args) {
        args = args || {};
        validatePageSize(args.pageSize);
        args.limit = args.pageSize || args.limit || 50;
        args.order = args.order || 'asc';
        return this.queryItems(args);
    }
    /**
     * @return {Promise<Object>} Context of List
     * @private
     */
    async getContext() {
        if (!this.context) {
            let response = await this.services.network.get(this.links.context);
            // store fetched context if we have't received any newer update
            this._updateContextIfRequired(response.body.data, response.body.last_event_id);
        }
        return this.context;
    }
    async setTtl(ttl) {
        try {
            const requestBody = { ttl };
            const response = await this.services.network.post(this.uri, requestBody);
            this.descriptor.date_expires = response.body.date_expires;
        }
        catch (error) {
            if (error.status === 404) {
                this.onRemoved(false);
            }
            throw error;
        }
    }
    async setItemTtl(index, ttl) {
        let existingItem = await this.get(index);
        const requestBody = { ttl };
        const response = await this.services.network.post(existingItem.uri, requestBody);
        existingItem.updateDateExpires(response.body.date_expires);
    }
    async removeList() {
        await this.services.network.delete(this.uri);
        this.onRemoved(true);
    }
    onRemoved(locally) {
        this._unsubscribe();
        this.removalHandler(this.type, this.sid, this.uniqueName);
        this.broadcastEventToListeners('removed', { isLocal: locally });
    }
    shouldIgnoreEvent(key, eventId) {
        return this.cache.isKnown(key, eventId);
    }
    /**
     * Handle update, which came from the server.
     * @private
     */
    _update(update, isStrictlyOrdered) {
        const itemIndex = Number(update.item_index);
        update.date_created = new Date(update.date_created);
        switch (update.type) {
            case 'list_item_added':
            case 'list_item_updated':
                {
                    this._handleItemMutated(itemIndex, update.item_url, update.id, update.item_revision, update.item_data, update.date_created, undefined, // orchestration does not include date_expires  -- @todo  it does now?
                    update.type === 'list_item_added', true);
                }
                break;
            case 'list_item_removed':
                {
                    this._handleItemRemoved(itemIndex, update.id, update.item_data, update.date_created, true);
                }
                break;
            case 'list_context_updated':
                {
                    this._handleContextUpdate(update.context_data, update.id, update.date_created);
                }
                break;
            case 'list_removed':
                {
                    this.onRemoved(false);
                }
                break;
        }
        if (isStrictlyOrdered) {
            this._advanceLastEventId(update.id, update.list_revision);
        }
    }
    _advanceLastEventId(eventId, revision) {
        if (this.lastEventId < eventId) {
            this.descriptor.last_event_id = eventId;
            if (revision) {
                this.descriptor.revision = revision;
            }
        }
    }
    _updateRootDateUpdated(dateUpdated) {
        if (!this.descriptor.date_updated || dateUpdated.getTime() > this.descriptor.date_updated.getTime()) {
            this.descriptor.date_updated = dateUpdated;
            this.services.storage.update(this.type, this.sid, this.uniqueName, { date_updated: dateUpdated });
        }
    }
    _handleItemMutated(index, uri, lastEventId, revision, data, dateUpdated, dateExpires, added, remote) {
        if (this.shouldIgnoreEvent(index, lastEventId)) {
            log$1.trace(`Item ${index} update skipped, current: ${this.lastEventId}, remote: ${lastEventId}`);
            return;
        }
        this._updateRootDateUpdated(dateUpdated);
        const item = this.cache.get(index);
        if (!item) {
            const newItem = new SyncListItem({ index, uri, lastEventId, revision, data, dateUpdated, dateExpires });
            this.cache.store(index, newItem, lastEventId);
            this.emitItemMutationEvent(newItem, remote, added);
            return;
        }
        const previousItemData = deepClone(item.data);
        item.update(lastEventId, revision, data, dateUpdated);
        this.cache.store(index, item, lastEventId);
        if (dateExpires !== undefined) {
            item.updateDateExpires(dateExpires);
        }
        this.emitItemMutationEvent(item, remote, false, previousItemData);
    }
    /**
     * @private
     */
    emitItemMutationEvent(item, remote, added, previousItemData = null) {
        const eventName = added ? 'itemAdded' : 'itemUpdated';
        const args = { item, isLocal: !remote };
        if (!added) {
            args.previousItemData = previousItemData;
        }
        this.broadcastEventToListeners(eventName, args);
    }
    /**
     * @private
     */
    _handleItemRemoved(index, eventId, oldData, dateUpdated, remote) {
        this._updateRootDateUpdated(dateUpdated);
        this.cache.delete(index, eventId);
        this.broadcastEventToListeners('itemRemoved', { index: index, isLocal: !remote, previousItemData: oldData });
    }
    /**
     * @private
     */
    _handleContextUpdate(data, eventId, dateUpdated) {
        this._updateRootDateUpdated(dateUpdated);
        if (this._updateContextIfRequired(data, eventId)) {
            this.broadcastEventToListeners('contextUpdated', { context: data, isLocal: false });
        }
    }
    /**
     * @private
     */
    _updateContextIfRequired(data, eventId) {
        if (!this.contextEventId || eventId > this.contextEventId) {
            this.context = data;
            this.contextEventId = eventId;
            return true;
        }
        else {
            log$1.trace('Context update skipped, current:', this.lastEventId, ', remote:', eventId);
            return false;
        }
    }
}
/**
 * Represents a Sync list, which stores an ordered list of values.
 * Use the {@link SyncClient.list} method to obtain a reference to a Sync list.
 * Information about rate limits can be found [here](https://www.twilio.com/docs/sync/limits).
 */
class SyncList extends Closeable {
    /**
     * @internal
     */
    constructor(syncListImpl) {
        super();
        this.syncListImpl = syncListImpl;
        this.syncListImpl.attach(this);
    }
    // private props
    get uri() {
        return this.syncListImpl.uri;
    }
    get revision() {
        return this.syncListImpl.revision;
    }
    get lastEventId() {
        return this.syncListImpl.lastEventId;
    }
    get links() {
        return this.syncListImpl.links;
    }
    get dateExpires() {
        return this.syncListImpl.dateExpires;
    }
    static get type() {
        return SyncListImpl.type;
    }
    get type() {
        return SyncListImpl.type;
    }
    /**
     * Unique ID of the list, immutable identifier assigned by the system.
     */
    get sid() {
        return this.syncListImpl.sid;
    }
    /**
     * Unique name of the list, immutable identifier that can be assigned to the list during creation.
     */
    get uniqueName() {
        return this.syncListImpl.uniqueName;
    }
    /**
     * Date when the list was last updated, given in UTC ISO 8601 format (e.g., '2018-04-26T15:23:19.732Z').
     */
    get dateUpdated() {
        return this.syncListImpl.dateUpdated;
    }
    /**
     * Add a new item to the list.
     * @param data Data to be added.
     * @param itemMetadata Item metadata.
     * @return The newly added item.
     * @example
     * ```typescript
     * list.push({ name: 'John Smith' }, { ttl: 86400 })
     *   .then((item) => {
     *     console.log(`List Item push() successful, item index: ${item.index}, data:`, item.data)
     *   })
     *   .catch((error) => {
     *     console.error('List Item push() failed', error);
     *   });
     * ```
     */
    async push(data, itemMetadata) {
        this.ensureNotClosed();
        return this.syncListImpl.push(data, itemMetadata);
    }
    /**
     * Assign new data to an existing item, given its index.
     * @param index Index of the item to be updated.
     * @param value New data to be assigned to an item.
     * @param itemMetadataUpdates New item metadata.
     * @return A promise with the updated item containing latest known data.
     * The promise will be rejected if the item does not exist.
     * @example
     * ```typescript
     * list.set(42, { name: 'John Smith' }, { ttl: 86400 })
     *   .then((item) => {
     *     console.log('List Item set() successful, item data:', item.data)
     *   })
     *   .catch((error) => {
     *     console.error('List Item set() failed', error);
     *   });
     * ```
     */
    async set(index, value, itemMetadataUpdates) {
        this.ensureNotClosed();
        return this.syncListImpl.set(index, value, itemMetadataUpdates);
    }
    /**
     * Modify an existing item by applying a mutation function to it.
     * @param index Index of the item to be changed.
     * @param mutator A function that outputs a new data based on the existing data.
     * @param itemMetadataUpdates New item metadata.
     * @return Resolves with the most recent item state, the output of a successful
     * mutation or a state that prompted graceful cancellation (mutator returned `null`). This promise
     * will be rejected if the indicated item does not already exist.
     * @example
     * ```typescript
     * const mutatorFunction = (currentValue) => {
     *     currentValue.viewCount = (currentValue.viewCount || 0) + 1;
     *     return currentValue;
     * };
     * list.mutate(42, mutatorFunction, { ttl: 86400 })
     *   .then((item) => {
     *     console.log('List Item mutate() successful, new data:', item.data)
     *   })
     *   .catch((error) => {
     *     console.error('List Item mutate() failed', error);
     *   });
     * ```
     */
    async mutate(index, mutator, itemMetadataUpdates) {
        this.ensureNotClosed();
        return this.syncListImpl.mutate(index, mutator, itemMetadataUpdates);
    }
    /**
     * Modify an existing item by appending new fields (or overwriting existing ones) with the values from the object.
     * This is equivalent to
     * ```typescript
     * list.mutate(42, (currentValue) => Object.assign(currentValue, obj));
     * ```
     * @param index Index of an item to be changed.
     * @param obj Set of fields to update.
     * @param itemMetadataUpdates New item metadata.
     * @return A promise with a modified item containing latest known data.
     * The promise will be rejected if the item was not found.
     * @example
     * ```typescript
     * // Say, the List Item (index: 42) data is `{ name: 'John Smith' }`
     * list.update(42, { age: 34 }, { ttl: 86400 })
     *   .then((item) => {
     *     // Now the List Item data is `{ name: 'John Smith', age: 34 }`
     *     console.log('List Item update() successful, new data:', item.data);
     *   })
     *   .catch((error) => {
     *     console.error('List Item update() failed', error);
     *   });
     * ```
     */
    async update(index, obj, itemMetadataUpdates) {
        this.ensureNotClosed();
        return this.syncListImpl.update(index, obj, itemMetadataUpdates);
    }
    /**
     * Delete an item given its index.
     * @param index Index of the item to be removed.
     * @return A promise to remove the item.
     * The promise will be rejected if the item was not found.
     * @example
     * ```typescript
     * list.remove(42)
     *   .then(() => {
     *     console.log('List Item remove() successful');
     *   })
     *   .catch((error) => {
     *     console.error('List Item remove() failed', error);
     *   });
     * ```
     */
    async remove(index) {
        this.ensureNotClosed();
        return this.syncListImpl.remove(index);
    }
    /**
     * Retrieve an item by List index.
     * @param index Item index in the list.
     * @return A promise with the item containing latest known data.
     * The promise will be rejected if the item was not found.
     * @example
     * ```typescript
     * list.get(42)
     *   .then((item) => {
     *     console.log('List Item get() successful, item data:', item.data)
     *   })
     *   .catch((error) => {
     *     console.error('List Item get() failed', error);
     *   });
     * ```
     */
    async get(index) {
        this.ensureNotClosed();
        return this.syncListImpl.get(index);
    }
    /**
     * Retrieve a list context
     * @return A promise with the list's context
     * @internal
     */
    async getContext() {
        this.ensureNotClosed();
        return this.syncListImpl.getContext();
    }
    /**
     * Query a list of items from collection.
     * Information about the query limits can be found {@link https://www.twilio.com/docs/sync/limits|here}.
     * @param queryOptions Query options.
     * @example
     * ```typescript
     * const pageHandler = (paginator) => {
     *   paginator.items.forEach((item) => {
     *     console.log(`Item ${item.index}:`, item.data);
     *   });
     *   return paginator.hasNextPage
     *     ? paginator.nextPage().then(pageHandler)
     *     : null;
     * };
     * list.getItems({ from: 0, order: 'asc' })
     *   .then(pageHandler)
     *   .catch((error) => {
     *     console.error('List getItems() failed', error);
     *   });
     * ```
     */
    async getItems(queryOptions) {
        this.ensureNotClosed();
        return this.syncListImpl.getItems(queryOptions);
    }
    /**
     * Update the time-to-live of the list.
     * @param ttl Specifies the TTL in seconds after which the list is subject to automatic deletion. The value 0 means infinity.
     * @return A promise that resolves after the TTL update was successful.
     * @example
     * ```typescript
     * list.setTtl(3600)
     *   .then(() => {
     *     console.log('List setTtl() successful');
     *   })
     *   .catch((error) => {
     *     console.error('List setTtl() failed', error);
     *   });
     * ```
     */
    async setTtl(ttl) {
        this.ensureNotClosed();
        return this.syncListImpl.setTtl(ttl);
    }
    /**
     * Update the time-to-live of a list item.
     * @param index Item index.
     * @param ttl Specifies the TTL in seconds after which the list item is subject to automatic deletion. The value 0 means infinity.
     * @return A promise that resolves after the TTL update was successful.
     * @example
     * ```typescript
     * list.setItemTtl(42, 86400)
     *   .then(() => {
     *     console.log('List setItemTtl() successful');
     *   })
     *   .catch((error) => {
     *     console.error('List setItemTtl() failed', error);
     *   });
     * ```
     */
    async setItemTtl(index, ttl) {
        this.ensureNotClosed();
        return this.syncListImpl.setItemTtl(index, ttl);
    }
    /**
     * Delete this list. It will be impossible to restore it.
     * @return A promise that resolves when the list has been deleted.
     * @example
     * list.removeList()
     *   .then(() => {
     *     console.log('List removeList() successful');
     *   })
     *   .catch((error) => {
     *     console.error('List removeList() failed', error);
     *   });
     */
    async removeList() {
        this.ensureNotClosed();
        return this.syncListImpl.removeList();
    }
    /**
     * Conclude work with the list instance and remove all event listeners attached to it.
     * Any subsequent operation on this object will be rejected with error.
     * Other local copies of this list will continue operating and receiving events normally.
     * @example
     * ```typescript
     * list.close();
     * ```
     */
    close() {
        super.close();
        this.syncListImpl.detach(this.listenerUuid);
    }
}
/**
 * Fired when a new item appears in the list, regardless of whether its creator was local or remote.
 *
 * Parameters:
 * 1. object `args` - info object provided with the event. It has the following properties:
 *     * {@link SyncListItem} `item` - added item
 *     * boolean `isLocal` - equals true if the item was added by a local actor, false otherwise
 * @example
 * ```typescript
 * list.on('itemAdded', (args) => {
 *   console.log(`List item ${args.item.index} was added`);
 *   console.log('args.item.data:', args.item.data);
 *   console.log('args.isLocal:', args.isLocal);
 * });
 * ```
 * @event
 */
SyncList.itemAdded = 'itemAdded';
/**
 * Fired when a list item is updated (not added or removed, but changed), regardless of whether the updater was local or remote.
 *
 * Parameters:
 * 1. object `args` - info object provided with the event. It has the following properties:
 *     * {@link SyncListItem} `item` - updated item
 *     * boolean `isLocal` - equals true if the item was updated by a local actor, false otherwise
 *     * object `previousItemData` - contains a snapshot of the item data before the update
 * @example
 * ```typescript
 * list.on('itemUpdated', (args) => {
 *   console.log(`List item ${args.item.index} was updated`);
 *   console.log('args.item.data:', args.item.data);
 *   console.log('args.isLocal:', args.isLocal);
 *   console.log('args.previousItemData:', args.previousItemData);
 * });
 * ```
 * @event
 */
SyncList.itemUpdated = 'itemUpdated';
/**
 * Fired when a list item is removed, regardless of whether the remover was local or remote.
 *
 * Parameters:
 * 1. object `args` - info object provided with the event. It has the following properties:
 *     * number `index` - index of the removed item
 *     * boolean `isLocal` - equals true if the item was removed by a local actor, false otherwise
 *     * object `previousItemData` - contains a snapshot of the item data before the removal
 * @example
 * ```typescript
 * list.on('itemRemoved', (args) => {
 *   console.log(`List item ${args.index} was removed`);
 *   console.log('args.previousItemData:', args.previousItemData);
 *   console.log('args.isLocal:', args.isLocal);
 * });
 * ```
 * @event
 */
SyncList.itemRemoved = 'itemRemoved';
/**
 * Fired when a list is deleted entirely, by any actor local or remote.
 *
 * Parameters:
 * 1. object `args` - info object provided with the event. It has the following properties:
 *     * boolean `isLocal` - equals true if the list was removed by a local actor, false otherwise
 * @example
 * ```typescript
 * list.on('removed', (args) => {
 *   console.log(`List ${list.sid} was removed`);
 *   console.log('args.isLocal:', args.isLocal);
 * });
 * ```
 * @event
 */
SyncList.removed = 'removed';
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.pureObject, [
        'undefined',
        declarativeTypeValidator.objectSchema('item metadata', {
            ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined']
        })
    ]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], SyncList.prototype, "push", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger, declarativeTypeValidator.pureObject, [
        'undefined',
        declarativeTypeValidator.objectSchema('item metadata', {
            ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined']
        })
    ]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, Object, Object]),
    __metadata("design:returntype", Promise)
], SyncList.prototype, "set", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger, 'function', [
        'undefined',
        declarativeTypeValidator.objectSchema('item metadata', {
            ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined']
        })
    ]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, Function, Object]),
    __metadata("design:returntype", Promise)
], SyncList.prototype, "mutate", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger, declarativeTypeValidator.pureObject, [
        'undefined',
        declarativeTypeValidator.objectSchema('item metadata', {
            ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined']
        })
    ]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, Object, Object]),
    __metadata("design:returntype", Promise)
], SyncList.prototype, "update", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", Promise)
], SyncList.prototype, "remove", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", Promise)
], SyncList.prototype, "get", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync([
        'undefined',
        declarativeTypeValidator.objectSchema('query options', {
            from: [declarativeTypeValidator.nonNegativeInteger, 'undefined'],
            pageSize: [declarativeTypeValidator.custom((value) => [isPositiveInteger(value), 'a positive integer']), 'undefined']
        })
    ]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], SyncList.prototype, "getItems", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", Promise)
], SyncList.prototype, "setTtl", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger, declarativeTypeValidator.nonNegativeInteger),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, Number]),
    __metadata("design:returntype", Promise)
], SyncList.prototype, "setItemTtl", null);

/**
 * Represents an individual element in a Sync map.
 */
class SyncMapItem {
    /**
     * @internal
     */
    constructor(descriptor) {
        this.descriptor = descriptor;
    }
    get uri() {
        return this.descriptor.url;
    }
    get revision() {
        return this.descriptor.revision;
    }
    get lastEventId() {
        return this.descriptor.last_event_id;
    }
    get dateExpires() {
        return this.descriptor.date_expires;
    }
    /**
     * The identifier that maps to this item within the containing Map.
     */
    get key() {
        return this.descriptor.key;
    }
    /**
     * The contents of the item.
     */
    get data() {
        return this.descriptor.data;
    }
    /**
     * Date when the map item was last updated.
     */
    get dateUpdated() {
        return this.descriptor.date_updated;
    }
    /**
     * @internal
     */
    update(eventId, revision, value, dateUpdated) {
        this.descriptor.last_event_id = eventId;
        this.descriptor.revision = revision;
        this.descriptor.data = value;
        this.descriptor.date_updated = dateUpdated;
        return this;
    }
    /**
     * @internal
     */
    updateDateExpires(dateExpires) {
        this.descriptor.date_expires = dateExpires;
    }
}

class SyncMapImpl extends SyncEntity {
    /**
     * @private
     */
    constructor(services, descriptor, removalHandler) {
        super(services, removalHandler);
        const updateRequestReducer = (acc, input) => (typeof input.ttl === 'number') ? { ttl: input.ttl }
            : acc;
        this.updateMergingQueue = new NamespacedMergingQueue(updateRequestReducer);
        this.cache = new Cache();
        this.descriptor = descriptor;
        this.descriptor.date_updated = new Date(this.descriptor.date_updated);
        if (descriptor.items) {
            descriptor.items.forEach(itemDescriptor => {
                itemDescriptor.date_updated = new Date(itemDescriptor.date_updated);
                this.cache.store(itemDescriptor.key, new SyncMapItem(itemDescriptor), itemDescriptor.last_event_id);
            });
        }
    }
    // private props
    get uri() {
        return this.descriptor.url;
    }
    get links() {
        return this.descriptor.links;
    }
    get revision() {
        return this.descriptor.revision;
    }
    get lastEventId() {
        return this.descriptor.last_event_id;
    }
    get dateExpires() {
        return this.descriptor.date_expires;
    }
    static get type() {
        return 'map';
    }
    get type() {
        return 'map';
    }
    // below properties are specific to Insights only
    get indexName() {
        return undefined;
    }
    get queryString() {
        return undefined;
    }
    // public props, documented along with class description
    get sid() {
        return this.descriptor.sid;
    }
    get uniqueName() {
        return this.descriptor.unique_name || null;
    }
    get dateUpdated() {
        return this.descriptor.date_updated;
    }
    async set(key, value, itemMetadataUpdates) {
        const input = itemMetadataUpdates || {};
        return this.updateMergingQueue.squashAndAdd(key, input, (input) => this._putItemUnconditionally(key, value, input.ttl));
    }
    async get(key) {
        if (key === null || key === undefined) {
            throw new SyncError('SyncMapItem key may not be empty', 400, 54209);
        }
        if (this.cache.has(key)) {
            return this.cache.get(key);
        }
        else {
            return this._getItemFromServer(key);
        }
    }
    async _getItemFromServer(key) {
        let result = await this.queryItems({ key: key });
        if (result.items.length < 1) {
            throw new SyncError(`The specified Map Item does not exist`, 404, 54201);
        }
        else {
            return result.items[0];
        }
    }
    async mutate(key, mutator, itemMetadataUpdates) {
        const input = itemMetadataUpdates || {};
        return this.updateMergingQueue.add(key, input, (input) => this._putItemWithIfMatch(key, mutator, input.ttl));
    }
    async update(key, obj, itemMetadataUpdates) {
        return this.mutate(key, remote => Object.assign(remote, obj), itemMetadataUpdates);
    }
    async _putItemUnconditionally(key, data, ttl) {
        const result = await this._putItemToServer(key, data, undefined, ttl);
        const item = result.item;
        this._handleItemMutated(item.key, item.url, item.last_event_id, item.revision, item.data, item.date_updated, item.date_expires, result.added, false);
        return this.cache.get(item.key);
    }
    async _putItemWithIfMatch(key, mutatorFunction, ttl) {
        const currentItem = await this.get(key)
            .catch(error => {
            if (error.status === 404) {
                // PUT /Items/myKey with `If-Match: -1` acts as "put if not exists"
                return new SyncMapItem({ key: key, data: {}, last_event_id: -1, revision: '-1', url: null, date_updated: null, date_expires: null });
            }
            else {
                throw error;
            }
        });
        let data = mutatorFunction(deepClone(currentItem.data));
        if (data) {
            let ifMatch = currentItem.revision;
            try {
                const result = await this._putItemToServer(key, data, ifMatch, ttl);
                const item = result.item;
                this._handleItemMutated(item.key, item.url, item.last_event_id, item.revision, item.data, item.date_updated, item.date_expires, result.added, false);
                return this.cache.get(item.key);
            }
            catch (error) {
                if (error.status === 412) {
                    await this._getItemFromServer(key);
                    return this._putItemWithIfMatch(key, mutatorFunction, ttl);
                }
                else {
                    throw error;
                }
            }
        }
        else {
            return currentItem;
        }
    }
    async _putItemToServer(key, data, ifMatch, ttl) {
        const url = new UriBuilder(this.links.items).pathSegment(key).build();
        const requestBody = { data };
        if (ttl !== undefined) {
            requestBody.ttl = ttl;
        }
        try {
            const response = await this.services.network.put(url, requestBody, ifMatch);
            const mapItemDescriptor = response.body;
            mapItemDescriptor.data = data; // The server does not return the data in the response
            mapItemDescriptor.date_updated = new Date(mapItemDescriptor.date_updated);
            const added = response.status.code === 201;
            return { added, item: mapItemDescriptor };
        }
        catch (error) {
            if (error.status === 404) {
                this.onRemoved(false);
            }
            throw error;
        }
    }
    async remove(key) {
        const item = await this.get(key);
        const previousItemData = deepClone(item.data);
        const response = await this.services.network.delete(item.uri);
        this._handleItemRemoved(key, response.body.last_event_id, previousItemData, new Date(response.body.date_updated), false);
    }
    /**
     * @private
     */
    async queryItems(args) {
        args = args || {};
        const uri = new UriBuilder(this.links.items)
            .queryParam('From', args.from)
            .queryParam('PageSize', args.limit)
            .queryParam('Key', args.key)
            .queryParam('PageToken', args.pageToken)
            .queryParam('Order', args.order)
            .build();
        let response = await this.services.network.get(uri);
        let items = response.body.items.map(el => {
            el.date_updated = new Date(el.date_updated);
            let itemInCache = this.cache.get(el.key);
            if (itemInCache) {
                this._handleItemMutated(el.key, el.url, el.last_event_id, el.revision, el.data, el.date_updated, el.date_expires, false, true);
            }
            else {
                this.cache.store(el.key, new SyncMapItem(el), el.last_event_id);
            }
            return this.cache.get(el.key);
        });
        const meta = response.body.meta;
        return new Paginator(items, pageToken => this.queryItems({ pageToken }), meta.previous_token, meta.next_token);
    }
    async getItems(args) {
        args = args || {};
        validatePageSize(args.pageSize);
        args.limit = args.pageSize || args.limit || 50;
        args.order = args.order || 'asc';
        return this.queryItems(args);
    }
    shouldIgnoreEvent(key, eventId) {
        return this.cache.isKnown(key, eventId);
    }
    /**
     * Handle update from the server
     * @private
     */
    _update(update, isStrictlyOrdered) {
        update.date_created = new Date(update.date_created);
        switch (update.type) {
            case 'map_item_added':
            case 'map_item_updated':
                {
                    this._handleItemMutated(update.item_key, update.item_url, update.id, update.item_revision, update.item_data, update.date_created, undefined, // orchestration events do not include date_expires
                    update.type === 'map_item_added', true);
                }
                break;
            case 'map_item_removed':
                {
                    this._handleItemRemoved(update.item_key, update.id, update.item_data, update.date_created, true);
                }
                break;
            case 'map_removed':
                {
                    this.onRemoved(false);
                }
                break;
        }
        if (isStrictlyOrdered) {
            this._advanceLastEventId(update.id, update.map_revision);
        }
    }
    _advanceLastEventId(eventId, revision) {
        if (this.lastEventId < eventId) {
            this.descriptor.last_event_id = eventId;
            if (revision) {
                this.descriptor.revision = revision;
            }
        }
    }
    _updateRootDateUpdated(dateUpdated) {
        if (!this.descriptor.date_updated || dateUpdated.getTime() > this.descriptor.date_updated.getTime()) {
            this.descriptor.date_updated = dateUpdated;
            this.services.storage.update(this.type, this.sid, this.uniqueName, { date_updated: dateUpdated });
        }
    }
    _handleItemMutated(key, url, lastEventId, revision, data, dateUpdated, dateExpires, added, remote) {
        if (this.shouldIgnoreEvent(key, lastEventId)) {
            log$1.trace('SyncMapItem ', key, ' update skipped, current:', this.lastEventId, ', remote:', lastEventId);
            return;
        }
        this._updateRootDateUpdated(dateUpdated);
        const item = this.cache.get(key);
        if (!item) {
            const newItem = new SyncMapItem({
                key: key,
                url,
                last_event_id: lastEventId,
                revision,
                data,
                date_updated: dateUpdated,
                date_expires: dateExpires,
            });
            this.cache.store(key, newItem, lastEventId);
            this.emitItemMutationEvent(newItem, remote, added);
            return;
        }
        const previousItemData = deepClone(item.data);
        item.update(lastEventId, revision, data, dateUpdated);
        this.cache.store(key, item, lastEventId);
        if (dateExpires !== undefined) {
            item.updateDateExpires(dateExpires);
        }
        this.emitItemMutationEvent(item, remote, false, previousItemData);
    }
    emitItemMutationEvent(item, remote, added, previousItemData = null) {
        const eventName = added ? 'itemAdded' : 'itemUpdated';
        const args = { item, isLocal: !remote };
        if (!added) {
            args.previousItemData = previousItemData;
        }
        this.broadcastEventToListeners(eventName, args);
    }
    /**
     * @private
     */
    _handleItemRemoved(key, eventId, oldData, dateUpdated, remote) {
        this._updateRootDateUpdated(dateUpdated);
        this.cache.delete(key, eventId);
        this.broadcastEventToListeners('itemRemoved', { key: key, isLocal: !remote, previousItemData: oldData });
    }
    onRemoved(locally) {
        this._unsubscribe();
        this.removalHandler(this.type, this.sid, this.uniqueName);
        this.broadcastEventToListeners('removed', { isLocal: locally });
    }
    async setTtl(ttl) {
        try {
            const requestBody = { ttl };
            const response = await this.services.network.post(this.uri, requestBody);
            this.descriptor.date_expires = response.body.date_expires;
        }
        catch (error) {
            if (error.status === 404) {
                this.onRemoved(false);
            }
            throw error;
        }
    }
    async setItemTtl(key, ttl) {
        let existingItem = await this.get(key);
        const requestBody = { ttl };
        const response = await this.services.network.post(existingItem.uri, requestBody);
        existingItem.updateDateExpires(response.body.date_expires);
    }
    async removeMap() {
        await this.services.network.delete(this.uri);
        this.onRemoved(true);
    }
}
/**
 * Represents a Sync map, which is a data structure that stores an unordered set of key-value pairs.
 * Use the {@link SyncClient.map} method to obtain a reference to a Sync map.
 * Information about rate limits can be found [here](https://www.twilio.com/docs/sync/limits).
 */
class SyncMap extends Closeable {
    /**
     * @internal
     */
    constructor(syncMapImpl) {
        super();
        this.syncMapImpl = syncMapImpl;
        this.syncMapImpl.attach(this);
    }
    // private props
    get uri() {
        return this.syncMapImpl.uri;
    }
    get links() {
        return this.syncMapImpl.links;
    }
    get revision() {
        return this.syncMapImpl.revision;
    }
    get lastEventId() {
        return this.syncMapImpl.lastEventId;
    }
    get dateExpires() {
        return this.syncMapImpl.dateExpires;
    }
    static get type() {
        return SyncMapImpl.type;
    }
    get type() {
        return SyncMapImpl.type;
    }
    /**
     * An immutable identifier (a SID) assigned by the system on creation.
     */
    get sid() {
        return this.syncMapImpl.sid;
    }
    /**
     * An optional immutable identifier that may be assigned by the
     * programmer to this map on creation. Unique among other Maps.
     */
    get uniqueName() {
        return this.syncMapImpl.uniqueName;
    }
    /**
     * Date when the map was last updated.
     */
    get dateUpdated() {
        return this.syncMapImpl.dateUpdated;
    }
    /**
     * Add a new item to the map with the given key-value pair. Overwrites any data that might already exist with that key.
     * @param key Unique item identifier.
     * @param data Data to be set.
     * @param itemMetadataUpdates New item metadata.
     * @return Newly added item, or modified one if already exists, with the latest known data.
     * @example
     * ```typescript
     * map.set('myKey', { name: 'John Smith' }, { ttl: 86400 })
     *   .then((item) => {
     *     console.log('Map SyncMapItem set() successful, item data:', item.data);
     *   })
     *   .catch((error) => {
     *     console.error('Map SyncMapItem set() failed', error);
     *   });
     * ```
     */
    async set(key, data, itemMetadataUpdates) {
        this.ensureNotClosed();
        return this.syncMapImpl.set(key, data, itemMetadataUpdates);
    }
    /**
     * Retrieve an item by key.
     * @param key Identifies the desired item.
     * @return A promise that resolves when the item has been fetched.
     * This promise will be rejected if item was not found.
     * @example
     * ```typescript
     * map.get('myKey')
     *   .then((item) => {
     *     console.log('Map SyncMapItem get() successful, item data:', item.data)
     *   })
     *   .catch((error) => {
     *     console.error('Map SyncMapItem get() failed', error);
     *   });
     * ```
     */
    async get(key) {
        this.ensureNotClosed();
        return this.syncMapImpl.get(key);
    }
    /**
     * Schedules a modification to this Map SyncMapItem that will apply a mutation function.
     * If no SyncMapItem with the given key exists, it will first be created, having the default data (`{}`).
     * @param key Selects the map item to be mutated.
     * @param mutator A function that outputs a new data based on the existing data.
     * May be called multiple times, particularly if this Map SyncMapItem is modified concurrently by remote code.
     * If the mutation ultimately succeeds, the Map SyncMapItem will have made the particular transition described
     * by this function.
     * @param itemMetadataUpdates New item metadata.
     * @return Resolves with the most recent item state, the output of a successful
     * mutation or a state that prompted graceful cancellation (mutator returned `null`).
     * @example
     * ```typescript
     * const mutatorFunction = (currentData) => {
     *     currentData.viewCount = (currentData.viewCount || 0) + 1;
     *     return currentData;
     * };
     * map.mutate('myKey', mutatorFunction, { ttl: 86400 })
     *   .then((item) => {
     *     console.log('Map SyncMapItem mutate() successful, new data:', item.data)
     *   })
     *   .catch((error) => {
     *     console.error('Map SyncMapItem mutate() failed', error);
     *   });
     * ```
     */
    async mutate(key, mutator, itemMetadataUpdates) {
        this.ensureNotClosed();
        return this.syncMapImpl.mutate(key, mutator, itemMetadataUpdates);
    }
    /**
     * Modify a map item by appending new fields (or by overwriting existing ones) with the values from
     * the provided Object. Creates a new item if no item by this key exists, copying all given fields and values
     * into it.
     * This is equivalent to
     * ```typescript
     * map.mutate('myKey', (currentData) => Object.assign(currentData, obj));
     * ```
     * @param key Selects the map item to update.
     * @param obj Specifies the particular (top-level) attributes that will receive new values.
     * @param itemMetadataUpdates New item metadata.
     * @return A promise resolving to the modified item in its new state.
     * @example
     * ```typescript
     * // Say, the Map SyncMapItem (key: `'myKey'`) data is `{ name: 'John Smith' }`
     * map.update('myKey', { age: 34 }, { ttl: 86400 })
     *   .then((item) => {
     *     // Now the Map SyncMapItem data is `{ name: 'John Smith', age: 34 }`
     *     console.log('Map SyncMapItem update() successful, new data:', item.data);
     *   })
     *   .catch((error) => {
     *     console.error('Map SyncMapItem update() failed', error);
     *   });
     * ```
     */
    async update(key, obj, itemMetadataUpdates) {
        this.ensureNotClosed();
        return this.syncMapImpl.update(key, obj, itemMetadataUpdates);
    }
    /**
     * Delete an item, given its key.
     * @param key Selects the item to delete.
     * @return A promise to remove an item.
     * The promise will be rejected if 'key' is undefined or an item was not found.
     * @example
     * ```typescript
     * map.remove('myKey')
     *   .then(() => {
     *     console.log('Map SyncMapItem remove() successful');
     *   })
     *   .catch((error) => {
     *     console.error('Map SyncMapItem remove() failed', error);
     *   });
     * ```
     */
    async remove(key) {
        this.ensureNotClosed();
        return this.syncMapImpl.remove(key);
    }
    /**
     * Get a complete list of items from the map.
     * Information about the query limits can be found [here](https://www.twilio.com/docs/sync/limits).
     * @param queryOptions Query options.
     * @example
     * ```typescript
     * const pageHandler = (paginator) => {
     *   paginator.items.forEach((item) => {
     *     console.log(`SyncMapItem ${item.key}: `, item.data);
     *   });
     *   return paginator.hasNextPage
     *     ? paginator.nextPage().then(pageHandler)
     *     : null;
     * };
     * map.getItems({ from: 'myKey', order: 'asc' })
     *   .then(pageHandler)
     *   .catch((error) => {
     *     console.error('Map getItems() failed', error);
     *   });
     * ```
     */
    async getItems(queryOptions) {
        this.ensureNotClosed();
        return this.syncMapImpl.getItems(queryOptions);
    }
    /**
     * Update the time-to-live of the map.
     * @param ttl Specifies the TTL in seconds after which the map is subject to automatic deletion. The value 0 means infinity.
     * @return A promise that resolves after the TTL update was successful.
     * @example
     * ```typescript
     * map.setTtl(3600)
     *   .then(() => {
     *     console.log('Map setTtl() successful');
     *   })
     *   .catch((error) => {
     *     console.error('Map setTtl() failed', error);
     *   });
     * ```
     */
    async setTtl(ttl) {
        this.ensureNotClosed();
        return this.syncMapImpl.setTtl(ttl);
    }
    /**
     * Update the time-to-live of a map item.
     * @param key SyncMapItem key.
     * @param ttl Specifies the TTL in seconds after which the map item is subject to automatic deletion. The value 0 means infinity.
     * @return A promise that resolves after the TTL update was successful.
     * @example
     * ```typescript
     * map.setItemTtl('myKey', 86400)
     *   .then(() => {
     *     console.log('Map setItemTtl() successful');
     *   })
     *   .catch((error) => {
     *     console.error('Map setItemTtl() failed', error);
     *   });
     * ```
     */
    async setItemTtl(key, ttl) {
        this.ensureNotClosed();
        return this.syncMapImpl.setItemTtl(key, ttl);
    }
    /**
     * Delete this map. It will be impossible to restore it.
     * @return A promise that resolves when the map has been deleted.
     * @example
     * ```typescript
     * map.removeMap()
     *   .then(() => {
     *     console.log('Map removeMap() successful');
     *   })
     *   .catch((error) => {
     *     console.error('Map removeMap() failed', error);
     *   });
     * ```
     */
    async removeMap() {
        this.ensureNotClosed();
        await this.syncMapImpl.removeMap();
    }
    /**
     * Conclude work with the map instance and remove all event listeners attached to it.
     * Any subsequent operation on this object will be rejected with error.
     * Other local copies of this map will continue operating and receiving events normally.
     * @example
     * ```typescript
     * map.close();
     * ````
     */
    close() {
        super.close();
        this.syncMapImpl.detach(this.listenerUuid);
    }
}
/**
 * Fired when a new item appears in the map, regardless of whether its creator was local or remote.
 *
 * Parameters:
 * 1. object `args` - info object provided with the event. It has the following properties:
 *     * {@link SyncMapItem} `item` - added item
 *     * boolean `isLocal` - equals true if the item was added by a local actor, false otherwise
 * @example
 * ```typescript
 * map.on('itemAdded', (args) => {
 *   console.log(`Map item ${args.item.key} was added`);
 *   console.log('args.item.data:', args.item.data);
 *   console.log('args.isLocal:', args.isLocal);
 * });
 * ```
 * @event
 */
SyncMap.itemAdded = 'itemAdded';
/**
 * Fired when a map item is updated (not added or removed, but changed), regardless of whether the updater was local or remote.
 *
 * Parameters:
 * 1. object `args` - info object provided with the event. It has the following properties:
 *     * {@link SyncMapItem} `item` - updated item
 *     * boolean `isLocal` - equals true if the item was updated by a local actor, false otherwise
 *     * object `previousItemData` - contains a snapshot of the item data before the update
 * @example
 * ```typescript
 * map.on('itemUpdated', (args) => {
 *   console.log(`Map item ${args.item.key} was updated`);
 *   console.log('args.item.data:', args.item.data);
 *   console.log('args.isLocal:', args.isLocal);
 *   console.log('args.previousItemData:', args.previousItemData);
 * });
 * ```
 * @event
 */
SyncMap.itemUpdated = 'itemUpdated';
/**
 * Fired when a map item is removed, regardless of whether the remover was local or remote.
 *
 * Parameters:
 * 1. object `args` - info object provided with the event. It has the following properties:
 *     * string `key` - the key of the removed item
 *     * boolean `isLocal` - equals true if the item was added by a local actor, false otherwise
 *     * object `previousItemData` - contains a snapshot of the item data before removal
 * @example
 * ```typescript
 * map.on('itemRemoved', (args) => {
 *   console.log(`Map item ${args.key} was removed`);
 *   console.log('args.previousItemData:', args.previousItemData);
 *   console.log('args.isLocal:', args.isLocal);
 * });
 * ```
 * @event
 */
SyncMap.itemRemoved = 'itemRemoved';
/**
 * Fired when a map is deleted entirely, by any actor local or remote.
 *
 * Parameters:
 * 1. object `args` - info object provided with the event. It has the following properties:
 *     * boolean `isLocal` - equals true if the map was removed by a local actor, false otherwise
 * @example
 * ```typescript
 * map.on('removed', (args) => {
 *   console.log(`Map ${map.sid} was removed`);
 *   console.log('args.isLocal:', args.isLocal);
 * });
 * ```
 * @event
 */
SyncMap.removed = 'removed';
__decorate([
    declarativeTypeValidator.validateTypesAsync('string', declarativeTypeValidator.pureObject, [
        'undefined',
        declarativeTypeValidator.objectSchema('item metadata', {
            ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined']
        })
    ]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], SyncMap.prototype, "set", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync('string'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], SyncMap.prototype, "get", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync('string', 'function', [
        'undefined',
        declarativeTypeValidator.objectSchema('item metadata', {
            ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined']
        })
    ]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Function, Object]),
    __metadata("design:returntype", Promise)
], SyncMap.prototype, "mutate", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync('string', declarativeTypeValidator.pureObject, [
        'undefined',
        declarativeTypeValidator.objectSchema('item metadata', {
            ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined']
        })
    ]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], SyncMap.prototype, "update", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync('string'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], SyncMap.prototype, "remove", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync([
        'undefined',
        declarativeTypeValidator.objectSchema('query options', {
            from: ['string', 'undefined'],
            pageSize: [declarativeTypeValidator.custom((value) => [isPositiveInteger(value), 'a positive integer']), 'undefined']
        })
    ]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], SyncMap.prototype, "getItems", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", Promise)
], SyncMap.prototype, "setTtl", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync('string', declarativeTypeValidator.nonNegativeInteger),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Number]),
    __metadata("design:returntype", Promise)
], SyncMap.prototype, "setItemTtl", null);

class SyncStreamImpl extends SyncEntity {
    /**
     * @internal
     */
    constructor(services, descriptor, removalHandler) {
        super(services, removalHandler);
        this.descriptor = descriptor;
    }
    // private props
    get uri() {
        return this.descriptor.url;
    }
    get links() {
        return this.descriptor.links;
    }
    static get type() {
        return 'stream';
    }
    get dateExpires() {
        return this.descriptor.date_expires;
    }
    get type() {
        return 'stream';
    }
    get lastEventId() {
        return null;
    }
    // below properties are specific to Insights only
    get indexName() {
        return undefined;
    }
    get queryString() {
        return undefined;
    }
    // public props, documented along with class description
    get sid() {
        return this.descriptor.sid;
    }
    get uniqueName() {
        return this.descriptor.unique_name || null;
    }
    async publishMessage(data) {
        const requestBody = { data };
        const response = await this.services.network.post(this.links.messages, requestBody);
        const responseBody = response.body;
        const event = this._handleMessagePublished(responseBody.sid, data, false);
        return event;
    }
    async setTtl(ttl) {
        try {
            const requestBody = { ttl: ttl };
            const response = await this.services.network.post(this.uri, requestBody);
            this.descriptor.date_expires = response.body.date_expires;
        }
        catch (error) {
            if (error.status === 404) {
                this.onRemoved(false);
            }
            throw error;
        }
    }
    async removeStream() {
        await this.services.network.delete(this.uri);
        this.onRemoved(true);
    }
    /**
     * Handle event from the server
     * @private
     */
    _update(update) {
        switch (update.type) {
            case 'stream_message_published': {
                this._handleMessagePublished(update.message_sid, update.message_data, true);
                break;
            }
            case 'stream_removed': {
                this.onRemoved(false);
                break;
            }
        }
    }
    _handleMessagePublished(sid, data, remote) {
        const event = {
            sid: sid,
            data: data
        };
        this.broadcastEventToListeners('messagePublished', { message: event, isLocal: !remote });
        return event;
    }
    onRemoved(isLocal) {
        this._unsubscribe();
        this.removalHandler(this.type, this.sid, this.uniqueName);
        this.broadcastEventToListeners('removed', { isLocal: isLocal });
    }
}
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.pureObject),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], SyncStreamImpl.prototype, "publishMessage", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", Promise)
], SyncStreamImpl.prototype, "setTtl", null);
/**
 * A Sync primitive for pub-sub messaging. Stream Messages are not persisted, exist
 * only in transit, and will be dropped if (due to congestion or network anomalies) they
 * cannot be delivered promptly. Use the {@link SyncClient.stream} method to obtain a reference to a Sync Message Stream.
 * Information about rate limits can be found [here](https://www.twilio.com/docs/sync/limits).
 */
class SyncStream extends Closeable {
    /**
     * @internal
     */
    constructor(syncStreamImpl) {
        super();
        this.syncStreamImpl = syncStreamImpl;
        this.syncStreamImpl.attach(this);
    }
    // private props
    get uri() {
        return this.syncStreamImpl.uri;
    }
    get links() {
        return this.syncStreamImpl.links;
    }
    static get type() {
        return SyncStreamImpl.type;
    }
    get dateExpires() {
        return this.syncStreamImpl.dateExpires;
    }
    get type() {
        return SyncStreamImpl.type;
    }
    get lastEventId() {
        return null;
    }
    /**
     * The immutable system-assigned identifier of this stream. Never null.
     */
    get sid() {
        return this.syncStreamImpl.sid;
    }
    /**
     * A unique identifier optionally assigned to the stream on creation.
     */
    get uniqueName() {
        return this.syncStreamImpl.uniqueName;
    }
    /**
     * Publish a message to the stream. The system will attempt delivery to all online subscribers.
     * @param data The body of the dispatched message. Maximum size in serialized JSON: 4KB.
     * A rate limit applies to this operation, refer to the [Sync API documentation](https://www.twilio.com/docs/api/sync) for details.
     * @return A promise which resolves after the message is successfully published
     * to the Sync service. Resolves irrespective of ultimate delivery to any subscribers.
     * @example
     * ```typescript
     * stream.publishMessage({ x: 42, y: 123 })
     *   .then((message) => {
     *     console.log('Stream publishMessage() successful, message SID:', message.sid);
     *   })
     *   .catch((error) => {
     *     console.error('Stream publishMessage() failed', error);
     *   });
     * ```
     */
    async publishMessage(data) {
        this.ensureNotClosed();
        return this.syncStreamImpl.publishMessage(data);
    }
    /**
     * Update the time-to-live of the stream.
     * @param ttl Specifies the TTL in seconds after which the stream is subject to automatic deletion. The value 0 means infinity.
     * @return A promise that resolves after the TTL update was successful.
     * @example
     * ```typescript
     * stream.setTtl(3600)
     *   .then(() => {
     *     console.log('Stream setTtl() successful');
     *   })
     *   .catch((error) => {
     *     console.error('Stream setTtl() failed', error);
     *   });
     * ```
     */
    async setTtl(ttl) {
        this.ensureNotClosed();
        return this.syncStreamImpl.setTtl(ttl);
    }
    /**
     * Permanently delete this Stream.
     * @return A promise which resolves after the Stream is successfully deleted.
     * @example
     * ```typescript
     * stream.removeStream()
     *   .then(() => {
     *     console.log('Stream removeStream() successful');
     *   })
     *   .catch((error) => {
     *     console.error('Stream removeStream() failed', error);
     *   });
     * ```
     */
    async removeStream() {
        this.ensureNotClosed();
        return this.syncStreamImpl.removeStream();
    }
    /**
     * Conclude work with the stream instance and remove all event listeners attached to it.
     * Any subsequent operation on this object will be rejected with error.
     * Other local copies of this stream will continue operating and receiving events normally.
     * @example
     * ```typescript
     * stream.close();
     * ```
     */
    close() {
        super.close();
        this.syncStreamImpl.detach(this.listenerUuid);
    }
}
/**
 * Fired when a message is published to the stream either locally or by a remote actor.
 *
 * Parameters:
 * 1. object `args` - info object provided with the event. It has the following properties:
 *     * {@link SyncStreamMessage} `message` -  Published message
 *     * boolean `isLocal` - equals true if the message was published by a local actor, false otherwise
 * @example
 * ```typescript
 * stream.on('messagePublished', (args) => {
 *   console.log('Stream message published');
 *   console.log('Message SID:', args.message.sid);
 *   console.log('Message data: ', args.message.data);
 *   console.log('args.isLocal:', args.isLocal);
 * });
 * ```
 * @event
 */
SyncStream.messagePublished = 'messagePublished';
/**
 * Fired when a stream is removed entirely, regardless of whether the remover was local or remote.
 *
 * Parameters:
 * 1. object `args` - info object provided with the event. It has the following properties:
 *     * boolean `isLocal` - equals true if the stream was removed by a local actor, false otherwise
 * @example
 * ```typescript
 * stream.on('removed', (args) => {
 *   console.log(`Stream ${stream.sid} was removed`);
 *   console.log('args.isLocal:', args.isLocal);
 * });
 * ```
 * @event
 */
SyncStream.removed = 'removed';
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.pureObject),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], SyncStream.prototype, "publishMessage", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", Promise)
], SyncStream.prototype, "setTtl", null);

class ClientInfo {
    constructor(version) {
        this.sdk = 'js';
        this.sdkVer = version;
        this.os = platform__namespace.os.family;
        this.osVer = platform__namespace.os.version;
        this.pl = platform__namespace.name;
        this.plVer = platform__namespace.version;
    }
}

/**
 * Container for entities which are known by the client
 * It's needed for deduplication when client obtain the same object several times
 */
class EntitiesCache {
    constructor() {
        this.names = new Map();
        this.entities = new Map();
    }
    store(entity) {
        let stored = this.entities.get(entity.sid);
        if (stored) {
            return stored;
        }
        this.entities.set(entity.sid, entity);
        if (entity.uniqueName) {
            this.names.set(entity.type + '::' + entity.uniqueName, entity.sid);
        }
        return entity;
    }
    getResolved(id, type) {
        let resolvedSid = this.names.get(type + '::' + id);
        return resolvedSid ? this.entities.get(resolvedSid) : null;
    }
    get(id, type) {
        return this.entities.get(id) || this.getResolved(id, type) || null;
    }
    remove(sid) {
        let cached = this.entities.get(sid);
        if (cached) {
            this.entities.delete(sid);
            if (cached.uniqueName) {
                this.names.delete(cached.type + '::' + cached.uniqueName);
            }
        }
    }
}

/**
 * An individual result from a LiveQuery or InstantQuery result set.
 */
class InsightsItem {
    /**
     * @internal
     */
    constructor() { }
}
class LiveQueryImpl extends SyncEntity {
    constructor(descriptor, services, removalHandler, items) {
        super(services, removalHandler);
        this.descriptor = descriptor;
        this.cache = new Cache();
        if (items) {
            items.forEach(item => {
                this.cache.store(item.key, { key: item.key, value: item.data }, item.revision);
            });
        }
    }
    // public
    get sid() {
        return this.descriptor.sid;
    }
    // private extension of SyncEntity
    get uniqueName() {
        return null;
    }
    get type() {
        return LiveQueryImpl.type;
    }
    static get type() {
        return 'live_query';
    }
    get lastEventId() {
        return this.descriptor.last_event_id;
    }
    get indexName() {
        return this.descriptor.indexName;
    }
    get queryString() {
        return this.descriptor.queryExpression;
    }
    // custom private props
    get queryUri() {
        return this.descriptor.queryUri;
    }
    get liveQueryDescriptor() {
        return this.descriptor;
    }
    // dummy stub from iface
    onRemoved() {
    }
    getItems() {
        const dataByKey = {};
        this.cache.forEach((key, item) => {
            dataByKey[key] = item.value;
        });
        return dataByKey;
    }
    /**
     * @internal
     */
    _update(message, isStrictlyOrdered) {
        switch (message.type) {
            case 'live_query_item_updated':
                this.handleItemMutated(message.item_key, message.item_data, message.item_revision);
                break;
            case 'live_query_item_removed':
                this.handleItemRemoved(message.item_key, message.item_revision);
                break;
            case 'live_query_updated':
                this.handleBatchUpdate(message.items);
                break;
        }
        if (isStrictlyOrdered) {
            this._advanceLastEventId(message.last_event_id);
        }
    }
    handleItemMutated(key, value, revision) {
        if (this.shouldIgnoreEvent(key, revision)) {
            log$1.trace(`Item ${key} update skipped, revision: ${revision}`);
        }
        else {
            const newItem = { key, value };
            this.cache.store(key, newItem, revision);
            this.broadcastEventToListeners('itemUpdated', newItem);
        }
    }
    handleItemRemoved(key, revision) {
        const force = (revision === null);
        if (this.shouldIgnoreEvent(key, revision)) {
            log$1.trace(`Item ${key} delete skipped, revision: ${revision}`);
        }
        else {
            this.cache.delete(key, revision, force);
            this.broadcastEventToListeners('itemRemoved', { key });
        }
    }
    handleBatchUpdate(items) {
        // preprocess item set for easy key-based access (it's a one-time constant time operation)
        let newItems = {};
        if (items != null) {
            items.forEach(item => {
                newItems[item.key] = {
                    data: item.data,
                    revision: item.revision
                };
            });
        }
        // go through existing items and generate update/remove events for them
        this.cache.forEach((key, item) => {
            const newItem = newItems[key];
            if (newItem != null) {
                this.handleItemMutated(key, newItem.data, newItem.revision);
            }
            else {
                this.handleItemRemoved(key, null); // force deletion w/o revision
            }
            // once item is handled, remove it from incoming array
            delete newItems[key];
        });
        // once we handled all the known items, handle remaining pack
        for (let key in newItems) {
            this.handleItemMutated(key, newItems[key].data, newItems[key].revision);
        }
    }
    shouldIgnoreEvent(key, eventId) {
        return key != null && eventId != null && this.cache.isKnown(key, eventId);
    }
    /**
     * @internal
     */
    _advanceLastEventId(eventId, revision) {
        // LiveQuery is not revisioned in any way, so simply ignore second param and act upon lastEventId only
        if (this.lastEventId < eventId) {
            this.descriptor.last_event_id = eventId;
        }
    }
}
async function queryItems(params) {
    let { network, queryString, uri, type } = params;
    if (queryString == null) { // should not be null or undefined
        throw new SyncError(`Invalid query`, 400, 54507);
    }
    const liveQueryRequestBody = {
        query_string: queryString // raw query string (like `key == "value" AND key2 != "value2"`)
    };
    if (type === LiveQuery.type) {
        liveQueryRequestBody.type = type;
    }
    let response = await network.post(uri, liveQueryRequestBody, undefined, true);
    return response.body;
}
/**
 * Represents a long-running query against Flex data wherein the returned result set
 * subsequently receives pushed updates whenever new (or updated) records would match the
 * given expression. Updated results are presented row-by-row until this query is explicitly
 * closed.
 *
 * Use the {@link SyncClient.liveQuery} method to create a live query.
 */
class LiveQuery extends Closeable {
    /**
     * @internal
     */
    constructor(liveQueryImpl) {
        super();
        this.liveQueryImpl = liveQueryImpl;
        this.liveQueryImpl.attach(this);
    }
    // private props
    static get type() {
        return LiveQueryImpl.type;
    }
    get type() {
        return LiveQueryImpl.type;
    }
    get lastEventId() {
        return this.liveQueryImpl.lastEventId;
    }
    /**
     * The immutable identifier of this query object, assigned by the system.
     */
    get sid() {
        return this.liveQueryImpl.sid;
    }
    /**
     * Closes this query instance and unsubscribes from further service events.
     * This will eventually stop the physical inflow of updates over the network, when all other instances of this query are closed as well.
     */
    close() {
        super.close();
        this.liveQueryImpl.detach(this.listenerUuid);
    }
    /**
     * @return A snapshot of items matching the current query expression.
     */
    getItems() {
        this.ensureNotClosed();
        return this.liveQueryImpl.getItems();
    }
}
/**
 * Fired when an item has been added or updated.
 *
 * Parameters:
 * 1. {@link InsightsItem} `item` - updated item
 * @example
 * ```typescript
 * liveQuery.on('itemUpdated', (item) => {
 *   console.log(`Item ${item.key} was updated`'`);
 *   console.log('Item value:', item.value);
 * });
 * ```
 * @event
 */
LiveQuery.itemUpdated = 'itemUpdated';
/**
 * Fired when an existing item has been removed.
 *
 * Parameters:
 * 1. object `args` - info object provided with the event. It has the following properties:
 *     * object `key` - the key of the removed item
 * @example
 * ```typescript
 * liveQuery.on('itemRemoved', (args) => {
 *   console.log(`Item ${args.key} was removed`);
 * });
 * ```
 * @event
 */
LiveQuery.itemRemoved = 'itemRemoved';
/**
 * Allows repetitive quick searches against a specific Flex data. Unlike a
 * LiveQuery, this result set does not subscribe to any updates and therefore receives no events
 * beyond the initial result set.
 *
 * Use the {@link SyncClient.instantQuery} method to create an Instant Query.
 */
class InstantQuery extends EventEmitter {
    /**
     * @internal
     */
    constructor(params) {
        super();
        this.queryExpression = null;
        this.items = {};
        Object.assign(this, params);
        this.updateIndexName(params.indexName);
    }
    // private props
    static get type() {
        return 'instant_query';
    }
    get type() {
        return InstantQuery.type;
    }
    /**
     * Spawns a new search request. The result will be provided asynchronously via the {@link InstantQuery.searchResult}
     * event.
     * @param queryExpression A query expression to be executed against the given data index. For more information
     * on the syntax read {@link SyncClient.liveQuery}.
     * @return A promise that resolves when query result has been received.
     */
    async search(queryExpression) {
        this.items = {};
        return queryItems({
            network: this.network,
            uri: this.queryUri,
            queryString: queryExpression,
        })
            .then((response) => {
            this.queryExpression = queryExpression;
            if (response.items) {
                response.items.forEach((item) => {
                    this.items[item.key] = item.data;
                });
            }
            this.emit('searchResult', this.getItems());
        })
            .catch((err) => {
            log$1.error(`Error '${err.message}' while executing query '${queryExpression}'`);
            this.queryExpression = null;
            throw err;
        });
    }
    /**
     * Instantiates a LiveQuery object based on the last known query expression that was passed to the
     * {@link InstantQuery.search} method. This LiveQuery will start receiving updates with new results,
     * while current object can be still used to execute repetitive searches.
     * @return A promise which resolves when the LiveQuery object is ready.
     */
    async subscribe() {
        if (this.queryExpression == null) { // should not be null or undefined
            return Promise.reject(new SyncError(`Invalid query`, 400, 54507));
        }
        return this.liveQueryCreator(this.indexName, this.queryExpression);
    }
    /**
     * @return A snapshot of items matching current query expression.
     */
    getItems() {
        return this.items;
    }
    /**
     * Set new index name
     * @param indexName New index name to set
     */
    updateIndexName(indexName) {
        this.indexName = indexName;
        this.queryUri = this.generateQueryUri(this.indexName);
    }
    generateQueryUri(indexName) {
        return new UriBuilder(this.insightsUri)
            .pathSegment(indexName)
            .pathSegment('Items')
            .build();
    }
}
/**
 * Fired when a search result is ready.
 *
 * Parameters:
 * 1. {@link ItemsSnapshot} `items` - a snapshot of items matching current query expression.
 * @example
 * ```typescript
 * instantQuery.on('searchResult', (items) => {
 *    Object.entries(items).forEach(([key, value]) => {
 *      console.log('Search result item key:', key);
 *      console.log('Search result item value:', value);
 *    });
 * });
 * ```
 * @event
 */
InstantQuery.searchResult = 'searchResult';
__decorate([
    declarativeTypeValidator.validateTypesAsync('string'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], InstantQuery.prototype, "search", null);
__decorate([
    declarativeTypeValidator.validateTypes(declarativeTypeValidator.nonEmptyString),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", void 0)
], InstantQuery.prototype, "updateIndexName", null);

var version = "3.0.5";

const SYNC_PRODUCT_ID = 'data_sync';
const SDK_VERSION = version;
function decompose(arg) {
    if (!arg) {
        return { mode: 'create_new' };
    }
    else if (typeof arg === 'string') {
        return { id: arg, mode: 'open_or_create' };
    }
    else {
        let mode = arg.mode || (arg.id ? 'open_or_create' : 'create_new');
        return Object.assign(Object.assign({}, arg), { mode: mode });
    }
}
const SYNC_DOCUMENT_NOTIFICATION_TYPE = 'com.twilio.rtd.cds.document';
const SYNC_LIST_NOTIFICATION_TYPE = 'com.twilio.rtd.cds.list';
const SYNC_MAP_NOTIFICATION_TYPE = 'com.twilio.rtd.cds.map';
const SYNC_NOTIFICATION_TYPE = 'twilio.sync.event';
/**
 * Client for the Twilio Sync service.
 *
 * @example
 * ```typescript
 * // Using NPM resolution
 * const SyncClient = require('twilio-sync');
 * const syncClient = new SyncClient(token, { loglevel: 'debug' });
 *
 * // Using CDN
 * const syncClient = new Twilio.Sync.Client(token, { logLevel: 'debug' });
 * ```
 */
class Client extends EventEmitter {
    /**
     * @param fpaToken Twilio access token.
     * @param options Options to customize the client.
     */
    constructor(fpaToken, options = {}) {
        super();
        if (!fpaToken) {
            throw new Error('Sync library needs a valid Twilio token to be passed');
        }
        if (options.hasOwnProperty('logLevel')) {
            log$1.setLevel(options.logLevel);
        }
        else {
            log$1.setLevel('silent');
        }
        const productId = options.productId = options.productId || SYNC_PRODUCT_ID;
        // Fill ClientMetadata
        options.clientMetadata = options.clientMetadata || {};
        if (!options.clientMetadata.hasOwnProperty('type')) {
            options.clientMetadata.type = 'sync';
        }
        if (!options.clientMetadata.hasOwnProperty('sdk')) {
            options.clientMetadata.sdk = 'JS';
            options.clientMetadata.sdkv = SDK_VERSION;
        }
        const startTwilsock = !options.twilsockClient;
        // Create default init registrations if none were provided.
        // Otherwise, the outside party have to list all the init registrations they need, including Sync ones.
        if (!options.initRegistrations) {
            let initRegistration = new twilsock.InitRegistration(productId);
            Client.populateInitRegistrations(initRegistration);
            options.initRegistrations = [initRegistration];
        }
        let twilsock$1 = options.twilsockClient = options.twilsockClient || new twilsock.Twilsock(fpaToken, productId, options);
        twilsock$1.on('tokenAboutToExpire', ttl => this.emit('tokenAboutToExpire', ttl));
        twilsock$1.on('tokenExpired', () => this.emit('tokenExpired'));
        twilsock$1.on('connectionError', err => this.emit('connectionError', err));
        twilsock$1.on('stateChanged', (state) => {
            this.emit('connectionStateChanged', state);
            /**
             * Handle transport establishing event
             * If we have any subscriptions - we should check object for modifications
             */
            this.services.subscriptions.onConnectionStateChanged(state === 'connected');
        });
        twilsock$1.on('message', (messageType, payload) => this._routeMessage(messageType, payload));
        let config = new Configuration(options);
        let network = new NetworkService(new ClientInfo(SDK_VERSION), config, twilsock$1);
        let storage = new SessionStorage(config);
        this.services = {
            config,
            twilsock: twilsock$1,
            network,
            storage,
            router: this,
            subscriptions: null
        };
        this.services.subscriptions = new Subscriptions(this.services);
        this.entities = new EntitiesCache();
        // Start only if we created twilsock locally,
        // otherwise it's the responsibility of whoever created the Twilsock client.
        if (startTwilsock) {
            twilsock$1.connect();
        }
    }
    static populateInitRegistrations(reg) {
        reg.populateInitRegistrations([SYNC_NOTIFICATION_TYPE, SYNC_DOCUMENT_NOTIFICATION_TYPE,
            SYNC_LIST_NOTIFICATION_TYPE, SYNC_MAP_NOTIFICATION_TYPE]);
    }
    /**
     * Entry point for all the incoming messages (Router).
     *
     * @param type Type of the incoming message
     * @param message Message to route
     * @internal
     */
    _routeMessage(type, message) {
        log$1.trace('Notification type:', type, 'content:', message);
        switch (type) {
            case SYNC_DOCUMENT_NOTIFICATION_TYPE:
            case SYNC_LIST_NOTIFICATION_TYPE:
            case SYNC_MAP_NOTIFICATION_TYPE:
                this.services.subscriptions.acceptMessage(message, false);
                break;
            case SYNC_NOTIFICATION_TYPE:
                this.services.subscriptions.acceptMessage(message, true);
                break;
        }
    }
    /**
     * Subscribe for events (Router)
     *
     * @internal
     */
    _subscribe(sid, entity) {
        this.services.subscriptions.add(sid, entity);
    }
    /**
     * Unsubscribe from events (Router)
     *
     * @internal
     */
    _unsubscribe(sid) {
        this.services.subscriptions.remove(sid);
    }
    /**
     * Current version of the Sync client.
     */
    static get version() {
        return SDK_VERSION;
    }
    /**
     * Current service connection state.
     */
    get connectionState() {
        return this.services.twilsock.state;
    }
    /**
     * Returns a promise which resolves when library is correctly initialized
     * Or throws if initialization is impossible
     *
     * @internal
     */
    async ensureReady() {
        if (!this.services.config.sessionStorageEnabled) {
            return;
        }
        try {
            let storageSettings = await this.services.twilsock.storageId();
            this.services.storage.updateStorageId(storageSettings.id);
        }
        catch (e) {
            log$1.warn('Failed to initialize storage', e);
        }
    }
    storeRootInSessionCache(type, id, value) {
        // can't store without id
        if (!this.services.config.sessionStorageEnabled || !id) {
            return;
        }
        let valueToStore = deepClone(value);
        if (type === SyncList.type || type === SyncMap.type) {
            valueToStore['last_event_id'] = null;
            delete valueToStore['items'];
        }
        this.services.storage.store(type, id, valueToStore);
    }
    readRootFromSessionCache(type, id) {
        if (!this.services.config.sessionStorageEnabled || !id) {
            return null;
        }
        return this.services.storage.read(type, id);
    }
    async _get(baseUri, id, optimistic = false) {
        if (!id) {
            throw new SyncError(`Cannot get entity without id`, 404);
        }
        const uri = new UriBuilder(baseUri).pathSegment(id)
            .queryParam('Include', optimistic ? 'items' : undefined).build();
        let response = await this.services.network.get(uri);
        return response.body;
    }
    _createDocument(id, data, ttl) {
        const requestBody = {
            unique_name: id,
            data: data || {}
        };
        if (ttl !== undefined) {
            requestBody.ttl = ttl;
        }
        return this.services.network.post(this.services.config.documentsUri, requestBody)
            .then(response => {
            response.body.data = requestBody.data;
            return response.body;
        });
    }
    async _getDocument(id) {
        return (this.readRootFromSessionCache(SyncDocument.type, id) || this._get(this.services.config.documentsUri, id));
    }
    _createList(id, purpose, context, ttl) {
        const requestBody = {
            unique_name: id,
            purpose: purpose,
            context: context
        };
        if (ttl !== undefined) {
            requestBody.ttl = ttl;
        }
        return this.services.network.post(this.services.config.listsUri, requestBody).then(response => response.body);
    }
    async _getList(id) {
        return (this.readRootFromSessionCache(SyncList.type, id) || this._get(this.services.config.listsUri, id));
    }
    _createMap(id, ttl) {
        const requestBody = {
            unique_name: id
        };
        if (ttl !== undefined) {
            requestBody.ttl = ttl;
        }
        return this.services.network.post(this.services.config.mapsUri, requestBody).then(response => response.body);
    }
    async _getMap(id, optimistic = false) {
        return (this.readRootFromSessionCache(SyncMap.type, id) || this._get(this.services.config.mapsUri, id, optimistic));
    }
    async _getStream(id) {
        return (this.readRootFromSessionCache(SyncStream.type, id) || this._get(this.services.config.streamsUri, id, false));
    }
    async _createStream(id, ttl) {
        const requestBody = {
            unique_name: id
        };
        if (ttl !== undefined) {
            requestBody.ttl = ttl;
        }
        const response = await this.services.network.post(this.services.config.streamsUri, requestBody);
        return response.body;
    }
    _getLiveQuery(sid) {
        return this.readRootFromSessionCache(LiveQuery.type, sid);
    }
    getCached(id, type) {
        if (id) {
            return this.entities.get(id, type) || null;
        }
        return null;
    }
    removeFromCacheAndSession(type, sid, uniqueName) {
        this.entities.remove(sid);
        if (this.services.config.sessionStorageEnabled) {
            this.services.storage.remove(type, sid, uniqueName);
        }
    }
    /**
     * Read or create a Sync document.
     * @param arg Could be any of the following:
     * * Unique name or SID identifying the Sync document - opens the document with the given identifier or creates one if it does not exist.
     * * none - creates a new document with a randomly assigned SID and no unique name.
     * * {@link OpenDocumentOptions} object for more granular control.
     * @return A promise which resolves after the document is successfully read (or created).
     * This promise may reject if the document could not be created or if this endpoint lacks the necessary permissions to access it.
     * @example
     * ```typescript
     * syncClient.document('MyDocument')
     *   .then((document) => {
     *     console.log('Successfully opened a document. SID:', document.sid);
     *     document.on('updated', (event) => {
     *       console.log('Received an "updated" event: ', event);
     *     });
     *   })
     *   .catch((error) => {
     *     console.error('Unexpected error', error);
     *   });
     * ```
     */
    async document(arg) {
        await this.ensureReady();
        let opts = decompose(arg);
        let docDescriptor;
        if (opts.mode === 'create_new') {
            docDescriptor = await this._createDocument(opts.id, opts.data, opts.ttl);
        }
        else {
            let docFromInMemoryCache = this.getCached(opts.id, SyncDocument.type);
            if (docFromInMemoryCache) {
                return new SyncDocument(docFromInMemoryCache);
            }
            else {
                try {
                    docDescriptor = await this._getDocument(opts.id);
                }
                catch (err) {
                    if (err.status !== 404 || opts.mode === 'open_existing') {
                        throw err;
                    }
                    else {
                        try {
                            docDescriptor = await this._createDocument(opts.id, opts.data, opts.ttl);
                        }
                        catch (err) {
                            if (err.status === 409) {
                                return this.document(arg);
                            }
                            else {
                                throw err;
                            }
                        }
                    }
                }
            }
        }
        this.storeRootInSessionCache(SyncDocument.type, opts.id, docDescriptor);
        let syncDocumentImpl = new SyncDocumentImpl(this.services, docDescriptor, (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName));
        syncDocumentImpl = this.entities.store(syncDocumentImpl);
        return new SyncDocument(syncDocumentImpl);
    }
    /**
     * Read or create a Sync map.
     * @param arg Could be any of the following:
     * * Unique name or SID identifying the Sync map - opens the map with the given identifier or creates one if it does not exist.
     * * none - creates a new map with a randomly assigned SID and no unique name.
     * * {@link OpenMapOptions} object for more granular control.
     * @return A promise which resolves after the map is successfully read (or created).
     * This promise may reject if the map could not be created or if this endpoint lacks the necessary permissions to access it.
     * @example
     * ```typescript
     * syncClient.map('MyMap')
     *   .then((map) => {
     *     console.log('Successfully opened a map. SID:', map.sid);
     *     map.on('itemUpdated', (event) => {
     *       console.log('Received an "itemUpdated" event:', event);
     *     });
     *   })
     *   .catch((error) => {
     *     console.error('Unexpected error', error);
     *   });
     * ```
     */
    async map(arg) {
        await this.ensureReady();
        let opts = decompose(arg);
        let mapDescriptor;
        if (opts.mode === 'create_new') {
            mapDescriptor = await this._createMap(opts.id, opts.ttl);
        }
        else {
            let mapFromInMemoryCache = this.getCached(opts.id, SyncMap.type);
            if (mapFromInMemoryCache) {
                return new SyncMap(mapFromInMemoryCache);
            }
            else {
                try {
                    mapDescriptor = await this._getMap(opts.id, opts.includeItems);
                }
                catch (err) {
                    if (err.status !== 404 || opts.mode === 'open_existing') {
                        throw err;
                    }
                    else {
                        try {
                            mapDescriptor = await this._createMap(opts.id, opts.ttl);
                        }
                        catch (err) {
                            if (err.status === 409) {
                                return this.map(arg);
                            }
                            else {
                                throw err;
                            }
                        }
                    }
                }
            }
        }
        this.storeRootInSessionCache(SyncMap.type, opts.id, mapDescriptor);
        let syncMapImpl = new SyncMapImpl(this.services, mapDescriptor, (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName));
        syncMapImpl = this.entities.store(syncMapImpl);
        return new SyncMap(syncMapImpl);
    }
    /**
     * Read or create a Sync list.
     * @param arg Could be any of the following:
     * * Unique name or SID identifying a Sync list - opens the list with the given identifier or creates one if it does not exist.
     * * none - creates a new list with a randomly assigned SID and no unique name.
     * * {@link OpenListOptions} object for more granular control.
     * @return A promise which resolves after the list is successfully read (or created).
     * This promise may reject if the list could not be created or if this endpoint lacks the necessary permissions to access it.
     * @example
     * ```typescript
     * syncClient.list('MyList')
     *   .then((list) => {
     *     console.log('Successfully opened a List. SID:', list.sid);
     *     list.on('itemAdded', (event) => {
     *       console.log('Received an "itemAdded" event:', event);
     *     });
     *   })
     *   .catch((error) => {
     *     console.error('Unexpected error', error);
     *   });
     * ```
     */
    async list(arg) {
        await this.ensureReady();
        let opts = decompose(arg);
        let listDescriptor;
        if (opts.mode === 'create_new') {
            listDescriptor = await this._createList(opts.id, opts.purpose, opts.context, opts.ttl);
        }
        else {
            let listFromInMemoryCache = this.getCached(opts.id, SyncList.type);
            if (listFromInMemoryCache) {
                return new SyncList(listFromInMemoryCache);
            }
            else {
                try {
                    listDescriptor = await this._getList(opts.id);
                }
                catch (err) {
                    if (err.status !== 404 || opts.mode === 'open_existing') {
                        throw err;
                    }
                    else {
                        try {
                            listDescriptor = await this._createList(opts.id, opts.purpose, opts.context, opts.ttl);
                        }
                        catch (err) {
                            if (err.status === 409) {
                                return this.list(arg);
                            }
                            else {
                                throw err;
                            }
                        }
                    }
                }
            }
        }
        this.storeRootInSessionCache(SyncList.type, opts.id, listDescriptor);
        let syncListImpl = new SyncListImpl(this.services, listDescriptor, (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName));
        syncListImpl = this.entities.store(syncListImpl);
        return new SyncList(syncListImpl);
    }
    /**
     * Read or create a Sync message stream.
     * @param arg Could be any of the following:
     * * Unique name or SID identifying a stream - opens the stream with the given identifier or creates one if it does not exist.
     * * none - creates a new stream with a randomly assigned SID and no unique name.
     * * {@link OpenStreamOptions} object for more granular control.
     * @return A promise which resolves after the stream is successfully read (or created).
     * The flow of messages will begin imminently (but not necessarily immediately) upon resolution.
     * This promise may reject if the stream could not be created or if this endpoint lacks the necessary permissions to access it.
     * @example
     * ```typescript
     * syncClient.stream('MyStream')
     *   .then((stream) => {
     *     console.log('Successfully opened a message stream. SID:', stream.sid);
     *     stream.on('messagePublished', (event) => {
     *       console.log('Received a "messagePublished" event:', event);
     *     });
     *   })
     *   .catch((error) => {
     *     console.error('Unexpected error', error);
     *   });
     * ```
     */
    async stream(arg) {
        await this.ensureReady();
        let opts = decompose(arg);
        let streamDescriptor;
        if (opts.mode === 'create_new') {
            streamDescriptor = await this._createStream(opts.id, opts.ttl);
        }
        else {
            let streamFromInMemoryCache = this.getCached(opts.id, SyncStream.type);
            if (streamFromInMemoryCache) {
                return new SyncStream(streamFromInMemoryCache);
            }
            else {
                try {
                    streamDescriptor = await this._getStream(opts.id);
                }
                catch (err) {
                    if (err.status !== 404 || opts.mode === 'open_existing') {
                        throw err;
                    }
                    else {
                        try {
                            streamDescriptor = await this._createStream(opts.id, opts.ttl);
                        }
                        catch (err) {
                            if (err.status === 409) {
                                return this.stream(arg);
                            }
                            else {
                                throw err;
                            }
                        }
                    }
                }
            }
        }
        this.storeRootInSessionCache(SyncStream.type, opts.id, streamDescriptor);
        const streamRemovalHandler = (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName);
        let syncStreamImpl = new SyncStreamImpl(this.services, streamDescriptor, streamRemovalHandler);
        syncStreamImpl = this.entities.store(syncStreamImpl);
        return new SyncStream(syncStreamImpl);
    }
    /**
     * Gracefully shuts the Sync client down.
     */
    async shutdown() {
        await this.services.subscriptions.shutdown();
        await this.services.twilsock.disconnect();
    }
    /**
     * Set the authentication token.
     * @param token New token to set.
     */
    async updateToken(token) {
        return this.services.twilsock.updateToken(token)
            .catch((error) => {
            var _a;
            const status = (_a = error === null || error === void 0 ? void 0 : error.reply) === null || _a === void 0 ? void 0 : _a.status;
            if ((status === null || status === void 0 ? void 0 : status.code) === 401 && (status === null || status === void 0 ? void 0 : status.status) === 'UNAUTHORIZED') {
                throw new SyncError('Updated token was rejected by server', 400, 51130);
            }
            throw error;
        });
    }
    /**
     * For Flex customers only. Establishes a long-running query against Flex data wherein the returned
     * result set is updated whenever new (or updated) records match the given expression. Updated results
     * are presented row-by-row according to the lifetime of the returned LiveQuery object.
     *
     * @param indexName Must specify one of the Flex data classes for which Live Queries are available.
     * @param queryExpression A query expression to be executed against the given data index.
     * Please review the [Live Query Language](https://www.twilio.com/docs/sync/live-query)
     * page for Sync client limits and a full list of operators currently supported in query expressions.
     *
     * @return A promise that resolves when the query has been successfully executed.
     * @example
     * ```typescript
     * syncClient.liveQuery('tr-worker', 'data.attributes.worker_name == "Bob"')
     *   .then((args) => {
     *      console.log('Subscribed to live data updates for worker Bob');
     *      const items = args.getItems();
     *      Object.entries(items).forEach(([key, value]) => {
     *        console.log('Search result item key:', key);
     *        console.log('Search result item value:', value);
     *      });
     *   })
     *   .catch((err) => {
     *      console.error('Error when subscribing to live updates for worker Bob', err);
     *   });
     * ```
     */
    async liveQuery(indexName, queryExpression) {
        await this.ensureReady();
        const queryUri = new UriBuilder(this.services.config.insightsUri)
            .pathSegment(indexName)
            .pathSegment('Items')
            .build();
        // send query to CDS to get server-generated sid and item list
        const response = await queryItems({
            network: this.services.network,
            uri: queryUri,
            queryString: queryExpression,
            type: LiveQuery.type
        });
        let liveQueryImpl = this.getCached(response.query_id, LiveQuery.type);
        if (!liveQueryImpl) {
            let descriptor = this._getLiveQuery(response.query_id);
            if (!descriptor) {
                descriptor = {
                    indexName,
                    queryExpression,
                    sid: response.query_id,
                    queryUri,
                    last_event_id: response.last_event_id
                };
            }
            const liveQueryRemovalHandler = (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName);
            liveQueryImpl = new LiveQueryImpl(descriptor, this.services, liveQueryRemovalHandler, response.items);
        }
        this.storeRootInSessionCache(LiveQuery.type, response.query_id, liveQueryImpl.liveQueryDescriptor);
        liveQueryImpl = this.entities.store(liveQueryImpl);
        return new LiveQuery(liveQueryImpl);
    }
    /**
     * For Flex customers only. Creates a query object that can be used to issue one-time queries repeatedly
     * against the target index.
     *
     * @param indexName Must specify one of the Flex data classes for which live queries are available.
     * @return A promise which resolves after the instance of InstantQuery is successfully created.
     * @example
     * ```typescript
     * syncClient.instantQuery('tr-worker')
     *   .then((q) => {
     *     q.on('searchResult', (items) => {
     *       Object.entries(items).forEach(([key, value]) => {
     *         console.log('Search result item key:', key);
     *         console.log('Search result item value:', value);
     *       });
     *     });
     *   });
     * ```
     */
    async instantQuery(indexName) {
        await this.ensureReady();
        const liveQueryCreator = (indexName, queryExpression) => {
            return this.liveQuery(indexName, queryExpression);
        };
        return new InstantQuery({
            indexName,
            network: this.services.network,
            insightsUri: this.services.config.insightsUri,
            liveQueryCreator
        });
    }
}
/**
 * Fired when connection state has been changed.
 *
 * Parameters:
 * 1. {@link ConnectionState} `connectionState` - contains current service connection state.
 * @example
 * ```typescript
 * syncClient.on('connectionStateChanged', (newState) => {
 *   console.log('Received a new connection state:', newState);
 * });
 * ```
 * @event
 */
Client.connectionStateChanged = 'connectionStateChanged';
/**
 * Fired when connection is interrupted by unexpected reason.
 *
 * Parameters:
 * 1. object `connectionError` - connection error details. It has following properties:
 *     * boolean `terminal` - twilsock will stop connection attempts
 *     * string `message` - root cause
 *     * number? `httpStatusCode` - HTTP status code if available
 *     * number? `errorCode` - Twilio public error code if available
 * @example
 * ```typescript
 * syncClient.on('connectionError', (connectionError) => {
 *   console.error('Connection was interrupted:', connectionError.message);
 *   console.error('Is terminal:', connectionError.terminal);
 * });
 * ```
 * @event
 */
Client.connectionError = 'connectionError';
/**
 * Fired when the access token is about to expire and needs to be updated.
 * The trigger takes place three minutes before the JWT access token expiry.
 * For long living applications, you should refresh the token when either
 * {@link SyncClient.tokenAboutToExpire | tokenAboutToExpire} or
 * {@link SyncClient.tokenExpired | tokenExpire} events occur; handling just
 * one of them is sufficient.
 * @example
 * The following example illustrates access token refresh.
 * ```typescript
 * syncClient.on('tokenAboutToExpire', () => {
 *   // Obtain a JWT access token: https://www.twilio.com/docs/sync/identity-and-access-tokens
 *   const token = '<your-access-token-here>';
 *   syncClient.updateToken(token);
 * });
 * ```
 * @event
 */
Client.tokenAboutToExpire = 'tokenAboutToExpire';
/**
 * Fired when the access token is expired.
 * In case the token is not refreshed, all subsequent Sync operations will fail and the client will disconnect.
 * For long living applications, you should refresh the token when either
 * {@link SyncClient.tokenAboutToExpire | tokenAboutToExpire} or
 * {@link SyncClient.tokenExpired | tokenExpire} events occur; handling just
 * one of them is sufficient.
 * @event
 */
Client.tokenExpired = 'tokenExpired';
__decorate([
    declarativeTypeValidator.validateTypesAsync([
        'undefined',
        'string',
        declarativeTypeValidator.objectSchema('open document options', {
            id: ['string', 'undefined'],
            mode: [declarativeTypeValidator.literal('open_or_create', 'open_existing', 'create_new'), 'undefined'],
            ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined'],
            data: [declarativeTypeValidator.pureObject, 'undefined', declarativeTypeValidator.literal(null)]
        })
    ]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], Client.prototype, "document", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync([
        'undefined',
        'string',
        declarativeTypeValidator.objectSchema('open map options', {
            id: ['string', 'undefined'],
            mode: [declarativeTypeValidator.literal('open_or_create', 'open_existing', 'create_new'), 'undefined'],
            ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined'],
            data: [declarativeTypeValidator.pureObject, 'undefined', declarativeTypeValidator.literal(null)],
            includeItems: ['boolean', 'undefined']
        })
    ]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], Client.prototype, "map", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync([
        'undefined',
        'string',
        declarativeTypeValidator.objectSchema('open list options', {
            id: ['string', 'undefined'],
            mode: [declarativeTypeValidator.literal('open_or_create', 'open_existing', 'create_new'), 'undefined'],
            ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined'],
            data: [declarativeTypeValidator.pureObject, 'undefined', declarativeTypeValidator.literal(null)],
            purpose: ['string', 'undefined'],
            context: [declarativeTypeValidator.pureObject, 'undefined'],
            includeItems: ['boolean', 'undefined']
        })
    ]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], Client.prototype, "list", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync([
        'undefined',
        'string',
        declarativeTypeValidator.objectSchema('open stream options', {
            id: ['string', 'undefined'],
            mode: [declarativeTypeValidator.literal('open_or_create', 'open_existing', 'create_new'), 'undefined'],
            ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined'],
            data: [declarativeTypeValidator.pureObject, 'undefined', declarativeTypeValidator.literal(null)]
        })
    ]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], Client.prototype, "stream", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], Client.prototype, "updateToken", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString, 'string'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], Client.prototype, "liveQuery", null);
__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], Client.prototype, "instantQuery", null);

exports.Client = Client;
exports.InsightsItem = InsightsItem;
exports.InstantQuery = InstantQuery;
exports.LiveQuery = LiveQuery;
exports.Paginator = Paginator;
exports.SyncClient = Client;
exports.SyncDocument = SyncDocument;
exports.SyncList = SyncList;
exports.SyncListItem = SyncListItem;
exports.SyncMap = SyncMap;
exports.SyncMapItem = SyncMapItem;
exports.SyncStream = SyncStream;
//# sourceMappingURL=react-native.js.map
